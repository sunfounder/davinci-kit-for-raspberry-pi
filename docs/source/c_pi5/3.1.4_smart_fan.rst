
.. note::

    Ciao, benvenuto nella Community su Facebook per gli appassionati di SunFounder Raspberry Pi, Arduino e ESP32! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **PerchÃ© unirti a noi?**

    - **Supporto esperto**: Risolvi i problemi post-vendita e le sfide tecniche con lâ€™aiuto della nostra community e del nostro team.
    - **Impara e Condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci dei nuovi prodotti e anteprime esclusive.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni e Giveaway Festivi**: Partecipa a concorsi e promozioni in occasione delle festivitÃ .

    ðŸ‘‰ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

3.1.4 Ventilatore Intelligente
=================================

Introduzione
---------------

In questo corso, utilizzeremo motori, pulsanti e termistori per creare un 
ventilatore intelligente manuale e automatico, con velocitÃ  regolabile.

Componenti
------------

.. image:: img/list_Smart_Fan.png
    :align: center

Schema di Collegamento
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: img/Schematic_three_one4.png
    :width: 500
    :align: center

Procedure Sperimentali
--------------------------

**Passo 1:** Costruisci il circuito.

.. image:: img/image245.png
   :width: 800
   :align: center

.. note::
    Il modulo di alimentazione puÃ² essere collegato a una batteria da 9V con 
    la clip per batteria inclusa nel kit. Inserisci il jumper del modulo di 
    alimentazione nelle strisce da 5V della breadboard.

.. image:: img/image118.jpeg
   :width: 2.80694in
   :height: 0.94375in
   :align: center

**Per gli utenti del linguaggio C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Passo 2:** Accedi alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.4/

**Passo 3:** Compila.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.4_SmartFan.c -lwiringPi -lm

**Passo 4:** Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Una volta eseguito il codice, avvia il ventilatore premendo il pulsante. 
Ogni pressione aumenta o diminuisce la velocitÃ  di 1 livello. Sono disponibili 
**5** livelli di velocitÃ : **0~4**. Se raggiungi il **4Â°** livello e premi di 
nuovo, il ventilatore si ferma con velocitÃ  pari a **0**.

.. note::

    Se non funziona dopo l'esecuzione o compare un messaggio di errore: \"wiringPi.h: No such file or directory\", consulta :ref:`Il codice C non funziona?`.

Quando la temperatura aumenta o diminuisce di piÃ¹ di 2â„ƒ, la velocitÃ  aumenta 
o diminuisce automaticamente di 1 livello.


**Spiegazione del Codice**

.. code-block:: c

    intÂ temperture(){
    Â Â Â Â unsignedÂ charÂ analogVal;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â analogValÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(analogVal)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â intÂ t=cel;
    Â Â Â Â returnÂ t;
    }

La funzione temperture() converte i valori del termistore letti da ADC0834 
in valori di temperatura. Consulta :ref:`2.2.2 Termistore` per ulteriori dettagli.

.. code-block:: c

    intÂ motor(intÂ level){
        if(level==0){
            digitalWrite(MotorEnable,LOW);
    Â Â Â Â Â Â Â Â returnÂ 0;
        }
    Â Â Â Â ifÂ (level>=4){
    Â Â Â Â Â Â Â Â levelÂ =4;
        }
        digitalWrite(MotorEnable,HIGH);
    Â Â Â Â softPwmWrite(MotorPin1,Â level*25);
    Â Â Â Â returnÂ level;Â Â Â Â 
    }

Questa funzione controlla la velocitÃ  di rotazione del motore. Lâ€™intervallo 
di **level** va da **0 a 4** (il livello **0** arresta il motore). 
Ogni livello rappresenta un aumento del **25%** della velocitÃ  del vento.

.. code-block:: c

    intÂ main(void)
    {
        setup();
    Â Â Â Â intÂ currentState,lastState=0;
    Â Â Â Â intÂ levelÂ =Â 0;
    Â Â Â Â intÂ currentTemp,markTemp=0;
        while(1){
    Â Â Â Â Â Â Â Â currentState=digitalRead(BtnPin);
    Â Â Â Â Â Â Â Â currentTemp=temperture();
    Â Â Â Â Â Â Â Â ifÂ (currentTemp<=0){continue;}
    Â Â Â Â Â Â Â Â ifÂ (currentState==1&&lastState==0){
    Â Â Â Â Â Â Â Â Â Â Â Â level=(level+1)%5;
    Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
                delay(500);
            }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (level!=0){
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp<=-2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level-1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
                }
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp>=2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level+1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
                }
            }
    Â Â Â Â Â Â Â Â level=motor(level);
        }
    Â Â Â Â returnÂ 0;
    }

La funzione **main()** contiene lâ€™intero processo del programma, come segue:

1) Legge costantemente lo stato del pulsante e la temperatura corrente.

2) Ad ogni pressione, il livello aumenta di **+1** e contemporaneamente la 
   temperatura viene aggiornata. Lâ€™intervallo di **Level** Ã¨ da **1 a 4**.

3) Quando il ventilatore Ã¨ in funzione (livello diverso da **0**), la temperatura 
   viene monitorata. Una variazione di **Â±2â„ƒ** causa un aumento o diminuzione del 
   livello.

4) Il motore cambia velocitÃ  di rotazione in base al **Level**.

