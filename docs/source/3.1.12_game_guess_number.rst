.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ğŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

3.1.12 SPIEL â€“ Nummer Vermutung
=================================

EinfÃ¼hrung
------------------

Nummer Vermutung ist ein lustiges Partyspiel, 
bei dem Sie und Ihre Freunde abwechselnd eine Nummer eingeben (0~99). 
Die Reichweite wird mit der Eingabe der Nummer kleiner, bis ein Spieler das RÃ¤tsel richtig beantwortet. 
Dann wird der Spieler besiegt und bestraft. Wenn zum Beispiel die GlÃ¼cksnummer 51 ist, 
die die Spieler nicht sehen kÃ¶nnen, und der Spieler â‘  50 eingibt, 
Ã¤ndert sich die Eingabeaufforderung des Nummernbereichs auf 50~99; 
Wenn der Spieler â‘¡ 70 eingibt, kann der Nummerbereich zwischen 50 und 70 liegen. 
Wenn der Spieler â‘¢ 51 eingibt, ist dieser Spieler der UnglÃ¼ckliche. 
Hier verwenden wir die Tastatur zur Eingabe von Nummer und das LCD zur Ausgabe der Ergebnisse.

Komponenten
-----------------

.. image:: media/list_GAME_Guess_Number.png
    :align: center

Schematische Darstellung
-----------------------------------------

============ ======== ======== =======
T-Karte Name physisch wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: media/Schematic_three_one12.png
   :align: center

Experimentelle Verfahren
-----------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: media/image273.png
   :alt: Guess Number_bb
   :width: 800

Schritt 2: I2C einrichten (siehe Anhang. Wenn Sie :ref:`i2c_config`  eingestellt haben, Ã¼berspringen Sie diesen Schritt.)

FÃ¼r Benutzer in C-Sprache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 3: Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.12/

Schritt 4: Kompilieren.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.12_GAME_GuessNumber.c -lwiringPi

Schritt 5: AusfÃ¼hren.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Nachdem das Programm ausgefÃ¼hrt wurde, wird die erste Seite auf dem LCD angezeigt:

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

DrÃ¼cken Sie â€šAâ€˜ und das Spiel startet und die Spieleseite erscheint auf dem LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Zu Beginn des Spiels wird eine Zufallsnummer â€šPunktâ€˜ erzeugt, die jedoch nicht auf dem LCD angezeigt wird. Sie mÃ¼ssen sie nur erraten. Die eingegebene Nummer wird am Ende der ersten Zeile angezeigt, bis die endgÃ¼ltige Berechnung abgeschlossen ist. (DrÃ¼cken Sie â€šDâ€˜, um den Vergleich zu starten. Wenn die Eingangsnummer grÃ¶ÃŸer als 10 ist, wird der automatische Vergleich gestartet.)

Der Nummernkreis von â€šPunktâ€˜ wird in der zweiten Zeile angezeigt. Und Sie mÃ¼ssen die Nummer innerhalb des Bereichs eingeben. Wenn Sie eine Nummer eingeben, wird der Bereich enger. Wenn Sie die GlÃ¼cksnummer glÃ¼cklicherweise oder unglÃ¼cklicherweise erhalten haben, wird â€You'veÂ gotÂ it!â€œ angezeigt.

**Code ErklÃ¤rung**

Am Anfang des Codes stehen die Funktionsfunktionen der Tastatur und des I2C LCD1602. 
Weitere Informationen hierzu finden Sie in den Tasten :ref:`py_lcd` und :ref:`py_keypad` .

Hier mÃ¼ssen wir Folgendes wissen:

.. code-block:: c

    /****************************************/
    //StartÂ fromÂ here
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
    Â Â Â Â lcd_init();
    Â Â Â Â lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
    Â Â Â Â }
    Â Â Â Â lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }
    

Diese Funktion wird verwendet, um zunÃ¤chst I2C LCD1602 und Tastatur 
zu definieren und â€Welcome!â€œ und â€PressÂ AÂ toÂ go!â€œ anzuzeigen.

.. code-block:: c

    voidÂ init_new_value(void){
    Â Â Â Â srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }

Die Funktion erzeugt die Zufallsnummer ``pointValue`` und setzt den Bereichshinweis des Punktes zurÃ¼ck.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

``detect_point()`` vergleicht die Eingabenummer mit dem erzeugten â€pointâ€œ. 
Wenn das Ergebnis des Vergleichs ist, dass sie nicht gleich sind, weist ``count`` ``upper`` und ``lower`` Werte zu und gibt â€0â€œ zurÃ¼ck; andernfalls, wenn das Ergebnis anzeigt, dass sie gleich sind, wird â€1â€œ zurÃ¼ckgegeben.

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
    Â Â Â Â lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
    Â Â Â Â Â Â Â Â delay(5000);
    Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â return;
    Â Â Â Â }
    Â Â Â Â write(0,0,"EnterÂ number:");
    Â Â Â Â Int2Str(str,count);
    Â Â Â Â write(13,0,str);
    Â Â Â Â Int2Str(str,lower);
    Â Â Â Â write(0,1,str);
    Â Â Â Â write(3,1,"<Point<");
    Â Â Â Â Int2Str(str,upper);
    Â Â Â Â write(12,1,str);
    }


Diese Funktion dient zum Anzeigen der Spieleseite. 
Beachten Sie die Funktion ``Int2Str(str,count)`` , 
die diese Variablen ``count`` , ``lower`` und ``upper`` von Integer in Character String konvertiert, 
um die korrekte Anzeige von lcd zu gewÃ¤hrleisten.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){Â //whenÂ initializeÂ wiringÂ failed,printÂ messagetoÂ screen
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
    Â Â Â Â }
    Â Â Â Â init();
    Â Â Â Â init_new_value();
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;Â Â Â 
    }

``main()`` enthÃ¤lt den gesamten Prozess des Programms, wie unten gezeigt:

1. Initialisieren Sie I2C LCD1602 und Tastatur.

#. Verwenden Sie ``init_new_value()`` , um eine Zufallsnummer 0-99 zu erstellen.

#. Beurteilen Sie, ob die Taste gedrÃ¼ckt wurde, und lassen Sie die Taste ablesen.

#. Wenn die Taste â€Aâ€œ gedrÃ¼ckt wird, erscheint eine Zufallsnummer 0-99 und das Spiel beginnt.

#. Wenn festgestellt wird, dass die Taste â€Dâ€œ gedrÃ¼ckt wurde, geht das Programm in die Ergebnisbeurteilung ein und zeigt das Ergebnis auf dem LCD an. Dieser Schritt hilft Ihnen, das Ergebnis auch zu beurteilen, wenn Sie nur eine Nummer und dann die Taste â€Dâ€œ drÃ¼cken.

#. Wenn die Taste 0-9 gedrÃ¼ckt wird, wird der ZÃ¤hlwert geÃ¤ndert. Wenn die Anzahl grÃ¶ÃŸer als 10 ist, beginnt das Urteil.

#. Die Ã„nderungen des Spiels und seiner Werte werden auf dem LCD1602 angezeigt.

FÃ¼r Python-Sprachbenutzer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 3: Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

Schritt 4: AusfÃ¼hren.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.12_GAME_GuessNumber.py

Nachdem das Programm ausgefÃ¼hrt wurde, wird die erste Seite auf dem LCD angezeigt:

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

DrÃ¼cken Sie â€šAâ€˜ und das Spiel startet und die Spieleseite erscheint auf dem LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Zu Beginn des Spiels wird eine Zufallsnummer â€šPunktâ€˜ erzeugt, 
die jedoch nicht auf dem LCD angezeigt wird. Sie mÃ¼ssen sie nur erraten. 
Die eingegebene Nummer wird am Ende der ersten Zeile angezeigt, 
bis die endgÃ¼ltige Berechnung abgeschlossen ist. (DrÃ¼cken Sie â€šDâ€˜, um den Vergleich zu starten. 
Wenn die Eingangsnummer grÃ¶ÃŸer als 10 ist, wird der automatische Vergleich gestartet.)

Der Nummernkreis von â€šPunktâ€˜ wird in der zweiten Zeile angezeigt. 
Und Sie mÃ¼ssen die Nummer innerhalb des Bereichs eingeben. Wenn Sie eine Nummer eingeben, 
wird der Bereich enger. Wenn Sie die GlÃ¼cksnummer glÃ¼cklicherweise oder unglÃ¼cklicherweise erhalten haben, 
wird â€You'veÂ gotÂ it!â€œ angezeigt. 

**Code**

.. note::

    Sie kÃ¶nnen den folgenden Code **Ã„ndern/ZurÃ¼cksetzen/Kopieren/AusfÃ¼hren/Stoppen** . Zuvor mÃ¼ssen Sie jedoch zu einem Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python`` gehen.
      
.. raw:: html

    <run></run>

.. code-block:: python

   import RPi.GPIO as GPIO
   import time
   import LCD1602
   import random

   ##################### HERE IS THE KEYPAD LIBRARY TRANSPLANTED FROM Arduino ############
   #class Key:Define some of the properties of Key
   class Keypad():

      def __init__(self, rowsPins, colsPins, keys):
         self.rowsPins = rowsPins
         self.colsPins = colsPins
         self.keys = keys
         GPIO.setwarnings(False)
         GPIO.setmode(GPIO.BCM)
         GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
         GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

      def read(self):
         pressed_keys = []
         for i, row in enumerate(self.rowsPins):
               GPIO.output(row, GPIO.HIGH)
               for j, col in enumerate(self.colsPins):
                  index = i * len(self.colsPins) + j
                  if (GPIO.input(col) == 1):
                     pressed_keys.append(self.keys[index])
               GPIO.output(row, GPIO.LOW)
         return pressed_keys

   ################ EXAMPLE CODE START HERE ################  

   count = 0
   pointValue = 0
   upper=99
   lower=0

   def setup():
      global keypad, last_key_pressed,keys
      rowsPins = [18,23,24,25]
      colsPins = [10,22,27,17]
      keys = ["1","2","3","A",
               "4","5","6","B",
               "7","8","9","C",
               "*","0","#","D"]
      keypad = Keypad(rowsPins, colsPins, keys)
      last_key_pressed = []
      LCD1602.init(0x27, 1)    # init(slave address, background light)
      LCD1602.clear()
      LCD1602.write(0, 0, 'Welcome!')
      LCD1602.write(0, 1, 'Press A to Start!')

   def init_new_value():
      global pointValue,upper,count,lower
      pointValue = random.randint(0,99)
      upper = 99
      lower = 0
      count = 0
      print('point is %d' %(pointValue))
      

   def detect_point():
      global count,upper,lower
      if count > pointValue:
         if count < upper:
               upper = count 
      elif count < pointValue:
         if count > lower:
               lower = count
      elif count == pointValue:
         count = 0
         return 1
      count = 0
      return 0

   def lcd_show_input(result):
      LCD1602.clear()
      if result == 1:
         LCD1602.write(0,1,'You have got it!')
         time.sleep(5)
         init_new_value()
         lcd_show_input(0)
         return
      LCD1602.write(0,0,'Enter number:')
      LCD1602.write(13,0,str(count))
      LCD1602.write(0,1,str(lower))
      LCD1602.write(3,1,' < Point < ')
      LCD1602.write(13,1,str(upper))

   def loop():
      global keypad, last_key_pressed,count
      while(True):
         result = 0
         pressed_keys = keypad.read()
         if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
               if pressed_keys == ["A"]:
                  init_new_value()
                  lcd_show_input(0)
               elif pressed_keys == ["D"]:
                  result = detect_point()
                  lcd_show_input(result)
               elif pressed_keys[0] in keys:
                  if pressed_keys[0] in list(["A","B","C","D","#","*"]):
                     continue
                  count = count * 10
                  count += int(pressed_keys[0])
                  if count >= 10:
                     result = detect_point()
                  lcd_show_input(result)
               print(pressed_keys)
         last_key_pressed = pressed_keys
         time.sleep(0.1)

   # Define a destroy function for clean up everything after the script finished
   def destroy():
      # Release resource
      GPIO.cleanup()
      LCD1602.clear() 

   if __name__ == '__main__':     # Program start from here
      try:
         setup()
         while True:
               loop()
      except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
         destroy()

**Code ErklÃ¤rung**

Am Anfang des Codes stehen die Funktionsfunktionen der Tastatur und des I2C LCD1602. 
Weitere Informationen hierzu finden Sie in den Tasten :ref:`py_lcd` LCD1602 und :ref:`py_keypad` .

Hier mÃ¼ssen wir Folgendes wissen:

.. code-block:: python

    defÂ init_new_value():
    Â Â Â Â globalÂ pointValue,upper,count,lower
    Â Â Â Â pointValueÂ =Â random.randint(0,99)
    Â Â Â Â upperÂ =Â 99
    Â Â Â Â lowerÂ =Â 0
    Â Â Â Â countÂ =Â 0
    Â Â Â Â print('pointÂ isÂ %d'Â %(pointValue))

Die Funktion erzeugt die ZufallsnummerÂ ``pointValue``Â und setzt den Bereichshinweis des Punktes zurÃ¼ck.

.. code-block:: python

    defÂ detect_point():
    Â Â Â Â globalÂ count,upper,lower
    Â Â Â Â ifÂ countÂ >Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ <Â upper:
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â countÂ 
    Â Â Â Â elifÂ countÂ <Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ >Â lower:
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count
    Â Â Â Â elifÂ countÂ ==Â pointValue:
    Â Â Â Â Â Â Â Â countÂ =Â 0
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â countÂ =Â 0
    Â Â Â Â returnÂ 0

``detect_point()`` vergleicht die eingegebene Zahl (count) mit dem erzeugten â€pointâ€œ. 
Wenn das Ergebnis des Vergleichs ist, 
dass sie nicht gleich sind, weist ``count`` ``upper`` und ``lower`` Werte zu und gibt â€š0â€˜ zurÃ¼ck; 
andernfalls, wenn das Ergebnis anzeigt, dass sie gleich sind, wird â€š1â€˜ zurÃ¼ckgegeben.

.. code-block:: python

    defÂ lcd_show_input(result):
    Â Â Â Â LCD1602.clear()
    Â Â Â Â ifÂ resultÂ ==Â 1:
    Â Â Â Â Â Â Â Â LCD1602.write(0,1,'YouÂ haveÂ gotÂ it!')
    Â Â Â Â Â Â Â Â time.sleep(5)
    Â Â Â Â Â Â Â Â init_new_value()
    Â Â Â Â Â Â Â Â lcd_show_input(0)
    Â Â Â Â Â Â Â Â return
    Â Â Â Â LCD1602.write(0,0,'EnterÂ number:')
    Â Â Â Â LCD1602.write(13,0,str(count))
    Â Â Â Â LCD1602.write(0,1,str(lower))
    Â Â Â Â LCD1602.write(3,1,'Â <Â PointÂ <Â ')
    Â Â Â Â LCD1602.write(13,1,str(upper))

Diese Funktion dient zum Anzeigen der Spieleseite.

``str(count)`` : Da ``write()`` nur den Datentyp - Zeichenfolge - unterstÃ¼tzen kann, wird ``str()`` benÃ¶tigt, um die Nummer in eine Zeichenfolge umzuwandeln.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ keypad,Â last_key_pressed,count
    Â Â Â Â while(True):
    Â Â Â Â Â Â Â Â resultÂ =Â 0
    Â Â Â Â Â Â Â Â pressed_keysÂ =Â keypad.read()
    Â Â Â Â Â Â Â Â ifÂ len(pressed_keys)Â !=Â 0Â andÂ last_key_pressedÂ !=Â pressed_keys:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keysÂ ==Â ["A"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keysÂ ==Â ["D"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keys[0]Â inÂ keys:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keys[0]Â inÂ list(["A","B","C","D","#","*"]):
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ +=Â int(pressed_keys[0])
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ countÂ >=Â 10:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â print(pressed_keys)
    Â Â Â Â Â Â Â Â last_key_pressedÂ =Â pressed_keys
    Â Â Â Â Â Â Â Â time.sleep(0.1)
Â Â Â 

``main()`` enthÃ¤lt den gesamten Prozess des Programms, wie unten gezeigt:

1. Initialisieren Sie I2C LCD1602 und Tastatur.

#. Beurteilen Sie, ob die Taste gedrÃ¼ckt wurde, und lassen Sie die Taste ablesen.

#. Wenn die Taste â€Aâ€œ gedrÃ¼ckt wird, erscheint eine Zufallsnummer 0-99 und das Spiel beginnt.

#. Wenn festgestellt wird, dass die Taste â€šDâ€˜ gedrÃ¼ckt wurde, geht das Programm in die Ergebnisbeurteilung ein.

#. Wenn die Taste 0-9 gedrÃ¼ckt wird, wird der ZÃ¤hlwert geÃ¤ndert. Wenn die Anzahl grÃ¶ÃŸer als 10 ist, beginnt das Urteil.

#. Die Ã„nderungen des Spiels und seiner Werte werden auf dem LCD1602 angezeigt.

PhÃ¤nomen Bild
------------------------

.. image:: media/image274.jpeg
   :align: center