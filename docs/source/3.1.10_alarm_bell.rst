.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Approfondissez vos connaissances en mati√®re de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Assistance d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Profitez d'un acc√®s anticip√© aux annonces de nouveaux produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

3.1.10 Alarme Sonore
=====================

Introduction
-----------------

Dans ce cours, nous allons cr√©er un dispositif d'alarme manuel. Vous pouvez 
remplacer l'interrupteur √† bascule par un thermistor ou un capteur photosensible 
pour en faire une alarme de temp√©rature ou une alarme de lumi√®re.

Composants
-----------------

.. image:: img/list_Alarm_Bell.png
    :align: center

Sch√©ma de c√¢blage
---------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
============ ======== ======== ===

.. image:: img/Schematic_three_one10.png
   :align: center

Proc√©dures exp√©rimentales
--------------------------------

**√âtape 1** : Construisez le circuit.

.. image:: img/image266.png
   :alt: Alarm Bell_bb
   :width: 800

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2** : Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.10/

**√âtape 3** : Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.10_AlarmBell.c -lwiringPi -lpthread

**√âtape 4** : Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s le d√©marrage du programme, l'interrupteur √† bascule sera bascul√© vers la 
droite, et le buzzer √©mettra des sons d'alarme. En m√™me temps, les LEDs rouge 
et verte clignoteront √† une certaine fr√©quence.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur appara√Æt : \"wiringPi.h: No such file or directory\", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.


**Explication du code**

.. code-block:: c

    #include¬†<pthread.h>

Dans ce code, vous utiliserez une nouvelle biblioth√®que, pthread.h, qui est un 
ensemble de biblioth√®ques de threads courantes permettant de r√©aliser le 
multithreading. Nous ajoutons le param√®tre **-lpthread** lors de la compilation 
pour que les LED et le buzzer puissent fonctionner ind√©pendamment.

.. code-block:: c

    void¬†*ledWork(void¬†*arg){¬†¬†¬†¬†¬†¬†¬†
    ¬†¬†¬†¬†while(1)¬†¬†¬†¬†
    ¬†¬†¬†¬†{¬†¬†¬†
    ¬†¬†¬†¬†¬†¬†¬†¬†if(flag==0){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pthread_exit(NULL);
    ¬†¬†¬†¬†¬†¬†¬†¬†}
    ¬†¬†¬†¬†¬†¬†¬†¬†digitalWrite(ALedPin,HIGH);
    ¬†¬†¬†¬†¬†¬†¬†¬†delay(500);
    ¬†¬†¬†¬†¬†¬†¬†¬†digitalWrite(ALedPin,LOW);
    ¬†¬†¬†¬†¬†¬†¬†¬†digitalWrite(BLedPin,HIGH);
    ¬†¬†¬†¬†¬†¬†¬†¬†delay(500);
    ¬†¬†¬†¬†¬†¬†¬†¬†digitalWrite(BLedPin,LOW);
    ¬†¬†¬†¬†}
    }

La fonction ledWork() permet de d√©finir l'√©tat de fonctionnement des 2 LEDs : la 
LED verte reste allum√©e pendant 0,5s puis s'√©teint ; de m√™me, la LED rouge s'allume 
pendant 0,5s puis s'√©teint.

.. code-block:: c

    void¬†*buzzWork(void¬†*arg){
    ¬†¬†¬†¬†while(1)
    ¬†¬†¬†¬†{
    ¬†¬†¬†¬†¬†¬†¬†¬†if(flag==0){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pthread_exit(NULL);
    ¬†¬†¬†¬†¬†¬†¬†¬†}
    ¬†¬†¬†¬†¬†¬†¬†¬†if((note>=800)||(note<=130)){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pitch¬†=¬†-pitch;
    ¬†¬†¬†¬†¬†¬†¬†¬†}
    ¬†¬†¬†¬†¬†¬†¬†¬†note=note+pitch;
    ¬†¬†¬†¬†¬†¬†¬†¬†softToneWrite(BeepPin,note);
    ¬†¬†¬†¬†¬†¬†¬†¬†delay(10);
    ¬†¬†¬†¬†}
    }

La fonction buzzWork() sert √† configurer l'√©tat de fonctionnement du buzzer. 
Ici, nous d√©finissons la fr√©quence entre 130 et 800, en l'augmentant ou la 
diminuant par intervalles de 20.

.. code-block:: c

    void¬†on(){
    ¬†¬†¬†¬†flag¬†=¬†1;
    ¬†¬†¬†¬†if(softToneCreate(BeepPin)¬†==¬†-1){
    ¬†¬†¬†¬†¬†¬†¬†¬†printf("setup¬†softTone¬†failed¬†!");
    ¬†¬†¬†¬†¬†¬†¬†¬†return;¬†
    ¬†¬†¬†¬†}¬†¬†¬†¬†
    ¬†¬†¬†¬†pthread_t¬†tLed;¬†¬†¬†¬†¬†
    ¬†¬†¬†¬†pthread_create(&tLed,NULL,ledWork,NULL);¬†¬†¬†¬†
    ¬†¬†¬†¬†pthread_t¬†tBuzz;¬†¬†
    ¬†¬†¬†¬†pthread_create(&tBuzz,NULL,buzzWork,NULL);¬†¬†¬†¬†¬†¬†
    }

Dans la fonction on() :

1) D√©finir le marqueur \"flag=1\", indiquant la fin du contr√¥le du thread.

2) Cr√©er un pin de tonalit√© contr√¥l√© par logiciel **BeepPin**.

3) Cr√©er deux threads s√©par√©s pour que les LEDs et le buzzer puissent fonctionner simultan√©ment.

**pthread_t tLed:** D√©clare un thread **tLed**.

**pthread_create(&tLed,NULL,ledWork,NULL) :** Cr√©ez le thread avec le prototype suivant :

int pthread_create(pthread_t \*restrict tidp, const pthread_attr_t \*restrict_attr, void*Ôºà*start_rtn)(void*), void \*restrict arg);

**Valeur de retour**

Si la cr√©ation est r√©ussie, retourne \"**0**\" ; sinon, retourne le **num√©ro d'erreur** \"**-1**\".

**Param√®tres**

| Le premier param√®tre est un pointeur vers l'identifiant du thread.
| Le deuxi√®me param√®tre est utilis√© pour d√©finir l'attribut du thread.
| Le troisi√®me param√®tre est l'adresse de d√©part de la fonction de thread.
| Le dernier param√®tre est l'argument pass√© √† la fonction.

.. code-block:: c

    void¬†off(){
    ¬†¬†¬†¬†flag¬†=¬†0;
    ¬†¬†¬†¬†softToneStop(BeepPin);
    ¬†¬†¬†¬†digitalWrite(ALedPin,LOW);
    ¬†¬†¬†¬†digitalWrite(BLedPin,LOW);
    }

La fonction off() d√©finit \"flag=0\" pour arr√™ter les threads **ledWork** et 
**buzzWork**, puis d√©sactive le buzzer et les LEDs.

.. code-block:: c

    int¬†main(){¬†¬†¬†¬†¬†¬†¬†
    ¬†¬†¬†¬†setup();¬†
    ¬†¬†¬†¬†int¬†lastState¬†=¬†0;
    ¬†¬†¬†¬†while(1){
    ¬†¬†¬†¬†¬†¬†¬†¬†int¬†currentState¬†=¬†digitalRead(switchPin);
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†((currentState¬†==¬†1)&&(lastState==0)){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†on();
    ¬†¬†¬†¬†¬†¬†¬†¬†}
    ¬†¬†¬†¬†¬†¬†¬†¬†else¬†if((currentState¬†==¬†0)&&(lastState==1)){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†off();
    ¬†¬†¬†¬†¬†¬†¬†¬†}
    ¬†¬†¬†¬†¬†¬†¬†¬†lastState=currentState;
    ¬†¬†¬†¬†}
    ¬†¬†¬†¬†return¬†0;
    }

La fonction main() contient l'ensemble du processus du programme : elle lit 
d'abord la valeur de l'interrupteur √† bascule ; si celui-ci est bascul√© vers 
la droite (lecture √† 1), la fonction on() est appel√©e, le buzzer √©met des sons 
et les LEDs rouge et verte clignotent. Sinon, le buzzer et les LEDs restent √©teints.

**Pour les utilisateurs de Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.10_AlarmBell.py

Apr√®s le d√©marrage du programme, l'interrupteur √† bascule sera positionn√© √† 
droite, et le buzzer √©mettra des sons d'alarme. En m√™me temps, les LEDs rouge 
et verte clignoteront √† une certaine fr√©quence.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin source du code comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    BeepPin=22
    ALedPin=17
    BLedPin=27
    switchPin=18

    Buzz=0
    flag =0
    note=150
    pitch=20

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(BeepPin, GPIO.OUT)
        GPIO.setup(ALedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(BLedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(switchPin,GPIO.IN)
        global Buzz
        Buzz=GPIO.PWM(BeepPin,note)

    def ledWork():
        while flag:
            GPIO.output(ALedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(ALedPin,GPIO.LOW)
            GPIO.output(BLedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(BLedPin,GPIO.LOW)

    def buzzerWork():
        global pitch
        global note
        while flag:
            if note >= 800 or note <=130:
                pitch = -pitch
            note = note + pitch 
            Buzz.ChangeFrequency(note)
            time.sleep(0.01)


    def on():
        global flag
        flag = 1
        Buzz.start(50)
        tBuzz = threading.Thread(target=buzzerWork) 
        tBuzz.start()
        tLed = threading.Thread(target=ledWork) 
        tLed.start()    

    def off():
        global flag
        flag = 0
        Buzz.stop()
        GPIO.output(ALedPin,GPIO.LOW)
        GPIO.output(BLedPin,GPIO.LOW)      


    def main():
        lastState=0
        while True:
            currentState =GPIO.input(switchPin)
            if currentState == 1 and lastState == 0:
                on()
            elif currentState == 0 and lastState == 1:
                off()
            lastState=currentState


    def destroy():
        off()
        GPIO.cleanup()


    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    import¬†threading

Ici, nous importons le module **Threading** qui permet d'ex√©cuter plusieurs 
t√¢ches simultan√©ment, tandis que les programmes normaux ne peuvent ex√©cuter 
le code que de haut en bas. Avec les modules **Threading**, les LED et le 
buzzer peuvent fonctionner ind√©pendamment.

.. code-block:: python

    def¬†ledWork():
    ¬†¬†¬†¬†while¬†flag:
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.HIGH)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.5)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.LOW)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.HIGH)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.5)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.LOW)

La fonction ledWork() permet de r√©gler l'√©tat de fonctionnement des 2 LEDs : 
elle maintient la LED verte allum√©e pendant 0,5s puis l'√©teint ; de m√™me, la LED 
rouge s'allume pendant 0,5s puis s'√©teint.

.. code-block:: python

    def¬†buzzerWork():
    ¬†¬†¬†¬†global¬†pitch
    ¬†¬†¬†¬†global¬†note
    ¬†¬†¬†¬†while¬†flag:
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†note¬†>=¬†800¬†or¬†note¬†<=130:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pitch¬†=¬†-pitch
    ¬†¬†¬†¬†¬†¬†¬†¬†note¬†=¬†note¬†+¬†pitch¬†
    ¬†¬†¬†¬†¬†¬†¬†¬†Buzz.ChangeFrequency(note)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.01)

La fonction buzzWork() sert √† r√©gler l'√©tat de fonctionnement du buzzer. Ici, 
la fr√©quence est r√©gl√©e entre 130 et 800, augmentant ou diminuant par intervalles de 20.

.. code-block:: python

    def¬†on():
    ¬†¬†¬†¬†global¬†flag
    ¬†¬†¬†¬†flag¬†=¬†1
    ¬†¬†¬†¬†Buzz.start(50)
    ¬†¬†¬†¬†tBuzz¬†=¬†threading.Thread(target=buzzerWork)¬†
    ¬†¬†¬†¬†tBuzz.start()
    ¬†¬†¬†¬†tLed¬†=¬†threading.Thread(target=ledWork)¬†
    ¬†¬†¬†¬†tLed.start()¬†¬†

Dans la fonction on() :

1) D√©finissez le marqueur \"flag=1\", indiquant le d√©marrage du thread de contr√¥le.

2) Lancez Buzz et d√©finissez le cycle de service √† 50 %.

3) Cr√©ez **2** threads s√©par√©s pour que la LED et le buzzer puissent fonctionner 
   en m√™me temps.

   tBuzz = threading.Thread(target=buzzerWork) **:** Cr√©ez le thread avec le 
   prototype suivant :


class¬†threading.Thread(group=None,¬†target=None,¬†name=None,¬†args=(),¬†kwargs={},¬†\*,¬†daemon=None)

Parmi les m√©thodes de construction, le principal param√®tre est **target**, auquel 
nous devons assigner un objet ex√©cutable (ici, les fonctions **ledWork** et **BuzzWork**).

Ensuite, on appelle **start()** pour lancer l'objet thread, ex., tBuzz.start() est 
utilis√© pour d√©marrer le thread tBuzz nouvellement cr√©√©.

.. code-block:: python

    def¬†off():
    ¬†¬†¬†¬†global¬†flag
    ¬†¬†¬†¬†flag¬†=¬†0
    ¬†¬†¬†¬†Buzz.stop()
    ¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.LOW)
    ¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.LOW)

La fonction off() d√©finit \"flag=0\" pour arr√™ter les threads **ledWork** et
 **BuzzWork**, puis d√©sactive le buzzer et les LEDs.

.. code-block:: python

    def¬†main():
    ¬†¬†¬†¬†lastState=0
    ¬†¬†¬†¬†while¬†True:
    ¬†¬†¬†¬†¬†¬†¬†¬†currentState¬†=GPIO.input(switchPin)
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†currentState¬†==¬†1¬†and¬†lastState¬†==¬†0:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†on()
    ¬†¬†¬†¬†¬†¬†¬†¬†elif¬†currentState¬†==¬†0¬†and¬†lastState¬†==¬†1:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†off()
    ¬†¬†¬†¬†¬†¬†¬†¬†lastState=currentState

La fonction main() contient tout le processus du programme : elle lit d'abord la 
valeur de l'interrupteur √† bascule ; si celui-ci est bascul√© vers la droite 
(lecture √† 1), la fonction on() est appel√©e, entra√Ænant l'activation du buzzer 
et le clignotement des LEDs rouge et verte. Sinon, le buzzer et les LEDs restent 
inactifs.

Image illustrant le ph√©nom√®ne
--------------------------------

.. image:: img/image267.jpeg
   :align: center