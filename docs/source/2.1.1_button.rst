.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Explorez plus en profondeur Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Obtenez un acc√®s anticip√© aux annonces de nouveaux produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _2.1.1_button:

2.1.1 Bouton
===============

Introduction
--------------

Dans cette le√ßon, nous apprendrons √† allumer ou √©teindre une LED √† l'aide d'un bouton.

Composants
------------

.. image:: img/list_2.1.1_Button.png


Principe
----------

**Bouton**

Le bouton est un composant commun utilis√© pour contr√¥ler les appareils √©lectroniques. 
Il sert g√©n√©ralement de commutateur pour connecter ou couper les circuits. Bien que 
les boutons existent dans diff√©rentes tailles et formes, celui utilis√© ici est un 
mini-bouton de 6 mm comme illustr√© dans les images ci-dessous.

Les deux broches de gauche sont connect√©es, et celles de droite sont similaires √† 
celles de gauche, comme montr√© ci-dessous :

.. image:: img/image148.png
    :width: 400
    :align: center

Le symbole suivant est souvent utilis√© pour repr√©senter un bouton dans les circuits.

.. image:: img/image301.png
    :width: 400
    :align: center

Lorsque le bouton est press√©, les 4 broches sont connect√©es, fermant ainsi le circuit.

Sch√©ma √©lectrique
---------------------

Utilisez un bouton normalement ouvert comme entr√©e pour le Raspberry Pi. Le sch√©ma de 
connexion est illustr√© ci-dessous. Lorsque le bouton est press√©, le GPIO18 passe √† un 
niveau bas (0V). Nous pouvons d√©tecter l'√©tat du GPIO18 via un programme. Si le GPIO18 
passe √† un niveau bas, cela signifie que le bouton est press√©. Vous pouvez ex√©cuter le 
code correspondant lorsque le bouton est press√©, et la LED s'allumera.

.. note::
    La broche la plus longue de la LED est l'anode et la plus courte est la cathode.

.. image:: img/image302.png
    :width: 600
    :align: center

.. image:: img/image303.png
    :width: 400
    :align: center


Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1** : Construisez le circuit.

.. image:: img/image152.png
    :width: 800



Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2** : Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.1/

.. note::
    Changez de r√©pertoire pour acc√©der au chemin du code de cette exp√©rience via **cd**.

**√âtape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.1_Button.c -lwiringPi

**√âtape 4** : Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le code ex√©cut√©, appuyez sur le bouton, la LED s'allume ; sinon, elle s'√©teint.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur s'affiche : ¬´ wiringPi.h: Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define LedPin      0
    #define ButtonPin   1

    int main(void){
        // Lorsque l'initialisation de wiringPi √©choue, afficher un message √† l'√©cran
        if(wiringPiSetup() == -1){
            printf("setup wiringPi failed !");
            return 1;
        }
        
        pinMode(LedPin, OUTPUT);
        pinMode(ButtonPin, INPUT);
        digitalWrite(LedPin, HIGH);
        
        while(1){
            // Indiquer que le bouton a √©t√© press√©
            if(digitalRead(ButtonPin) == 0){
                // LED allum√©e
                digitalWrite(LedPin, LOW);
            //  printf("...LED allum√©e\n");
            }
            else{
                // LED √©teinte
                digitalWrite(LedPin, HIGH);
            //  printf("LED √©teinte...\n");
            }
        }
        return 0;
    }

**Explication du code**

.. code-block:: 

    #define LedPin      0

Le GPIO17 sur la carte T_Extension est √©quivalent √† GPIO0 dans wiringPi.

.. code-block:: 

    #define ButtonPin   1

Le bouton est connect√© √† GPIO1.

.. code-block:: 

    pinMode(LedPin, OUTPUT);

D√©finit LedPin comme sortie pour pouvoir lui attribuer une valeur.

.. code-block:: 

    pinMode(ButtonPin, INPUT);

D√©finit ButtonPin comme entr√©e pour lire sa valeur.

.. code-block:: C

    while(1){
            // Indiquer que le bouton a √©t√© press√©
            if(digitalRead(ButtonPin) == 0){
                // LED allum√©e
                digitalWrite(LedPin, LOW);
            //  printf("...LED allum√©e\n");
            }
            else{
                // LED √©teinte
                digitalWrite(LedPin, HIGH);
            //  printf("LED √©teinte...\n");
            }
        }


if (digitalRead(ButtonPin) == 0) : v√©rifie si le bouton a √©t√© press√©. Ex√©cute 
digitalWrite(LedPin, LOW) pour allumer la LED lorsque le bouton est press√©.


Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2** : Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python

**√âtape 3** : Ex√©cutez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.1_Button.py

Appuyez maintenant sur le bouton et la LED s'allumera ; appuyez √† nouveau sur le 
bouton et la LED s'√©teindra. En m√™me temps, l'√©tat de la LED sera affich√© √† l'√©cran.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    LedPin = 17 # D√©finir GPIO17 comme broche LED
    BtnPin = 18 # D√©finir GPIO18 comme broche du bouton

    Led_status = True # Initialiser l'√©tat de la LED √† True (√âTEINT)

    # D√©finir une fonction d'initialisation
    def setup():
        # Configurer les GPIO en mode Num√©rotation BCM
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)  # Configurer LedPin en sortie, avec un niveau initial √©lev√© (3,3V)
        GPIO.setup(BtnPin, GPIO.IN) # Configurer BtnPin en entr√©e.

    # D√©finir une fonction de rappel pour le bouton
    def swLed(ev=None):
        global Led_status
        # Basculer l'√©tat de la LED (allum√©-->√©teint; √©teint-->allum√©)
        Led_status = not Led_status
        GPIO.output(LedPin, Led_status)
        if Led_status:
            print ('LED OFF...')
        else:
            print ('...LED ON')

    # D√©finir la fonction principale
    def main():
        # D√©tecter un front descendant sur BtnPin
        # et appeler la fonction de rappel swLed
        GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)
        while True:
            # Ne rien faire.
            time.sleep(1)

    # D√©finir une fonction destroy pour nettoyer apr√®s l'ex√©cution
    def destroy():
        # √âteindre la LED
        GPIO.output(LedPin, GPIO.HIGH)
        # Lib√©rer les ressources
        GPIO.cleanup()

    # Si ce script est ex√©cut√© directement :
    if __name__ == '__main__':
        setup()
        try:
            main()
        # Lorsque 'Ctrl+C' est press√©, la fonction
        # destroy() sera ex√©cut√©e.
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    LedPin = 17

D√©finir GPIO17 comme broche LED.

.. code-block:: python

    BtnPin = 18

D√©finir GPIO18 comme broche du bouton.

.. code-block:: python

    GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)

Configurer une d√©tection de front descendant sur BtnPin. Lorsque la valeur de 
BtnPin passe d‚Äôun niveau √©lev√© √† un niveau bas, cela signifie que le bouton 
a √©t√© press√©. La fonction swLed est alors appel√©e.

.. code-block:: python

    def swLed(ev=None):
    global Led_status
    # Basculer l'√©tat de la LED (allum√©-->√©teint; √©teint-->allum√©)
    Led_status = not Led_status
    GPIO.output(LedPin, Led_status)

D√©finir une fonction de rappel pour le bouton. Lors de la premi√®re pression 
sur le bouton, si la condition not Led_status est fausse, la fonction GPIO.output() 
est appel√©e pour allumer la LED. En appuyant √† nouveau sur le bouton, l'√©tat de la 
LED passe de faux √† vrai, √©teignant ainsi la LED.

Image du R√©sultat
------------------------

.. image:: img/image153.jpeg

