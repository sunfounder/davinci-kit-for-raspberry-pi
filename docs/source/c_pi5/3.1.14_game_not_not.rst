.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!


3.1.14 SPIEL - Nicht nicht
===============================

EinfÃ¼hrung
--------------------

In dieser Lektion werden wir ein interessantes SpielgerÃ¤t herstellen und es â€žNicht nichtâ€œ nennen.

WÃ¤hrend des Spiels aktualisiert die Punktmatrix einen Pfeil nach dem Zufallsprinzip. Sie mÃ¼ssen die Taste innerhalb einer begrenzten Zeit in die entgegengesetzte Richtung des Pfeils drÃ¼cken. Wenn die Zeit abgelaufen ist oder wenn die Taste in die gleiche Richtung wie der Pfeil gedrÃ¼ckt wird, sind Sie raus.

Dieses Spiel kann wirklich Ihr umgekehrtes Denken Ã¼ben, und jetzt sollen wir es versuchen?

Komponenten
---------------

.. image:: ../img/list_GAME_Not_Not.png
    :align: center

Schematische Darstellung
----------------------------------

============ ======== ======== ===
T-Karte Name physisch wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../img/Schematic_three_one14.png
   :align: center

Experimentelle Verfahren
-----------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: ../img/image280.png
    :width: 800


Schritt 2: Gehen Sie zum Code-Ordner.

.. raw:: html

   <run></run>

.. code-block::

    cd /home/pi/davinci-kit-for-raspberry-pi/c/3.1.14/

Schritt 3: Kompilieren.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

Schritt 4: AusfÃ¼hren.

.. raw:: html

   <run></run>

.. code-block::

     sudo ./a.out

Nach dem Start des Programms wird ein Pfeil nach links oder rechts in der Punktmatrix nach dem Zufallsprinzip aktualisiert. Sie mÃ¼ssen die Taste innerhalb einer begrenzten Zeit in die entgegengesetzte Richtung des Pfeils drÃ¼cken. Dann erscheint â€žâˆšâ€œ auf der Punktmatrix. Wenn die Zeit abgelaufen ist oder wenn die Taste in die gleiche Richtung wie der Pfeil gedrÃ¼ckt wird, sind Sie ausgeschaltet und die Punktmatrix zeigt â€žxâ€œ an. Sie kÃ¶nnen auch 2 neue SchaltflÃ¤chen hinzufÃ¼gen oder durch Joystick-Tasten fÃ¼r Auf, Ab, Links und Rechts ersetzen - 4 Richtungen, 
um die Schwierigkeit des Spiels zu erhÃ¶hen.

**Code ErklÃ¤rung**

Basierend auf 1.1.6 LED Dot Matrix fÃ¼gt diese Lektion 2 Tasten hinzu, um ein amÃ¼santes SpielgerÃ¤t zu erstellen. Wenn Sie mit der Punktmatrix nicht sehr vertraut sind, lesen Sie bitte :ref:`py_matrix`.

Der gesamte Programmprozess ist wie folgt:

1. WÃ¤hlen Sie zufÃ¤llig eine Pfeilrichtung und generieren Sie Timer 1.

#. Zeigen Sie das Pfeilbild auf der Punktmatrix an.

#. Beurteilen Sie die Tasteneingabe. Wenn die Taste gedrÃ¼ckt wird oder Timer 1 daran erinnert, dass die Zeit abgelaufen ist, beginnt die Beurteilung.

#. Zeigen Sie das Bild anhand eines Bewertungsergebnisses an. In der Zwischenzeit Timer 2 generieren.

#. FÃ¼hren Sie Schritt 1 erneut aus, wenn Timer 2 daran erinnert, dass die Zeit abgelaufen ist.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
    Â Â Â Â {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
    Â Â Â Â //Â {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
    Â Â Â Â //Â {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},Â Â Â Â 
    Â Â Â Â {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
    Â Â Â Â {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
    Â Â Â Â {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

Die GLYPH-Struktur funktioniert wie ein WÃ¶rterbuch: Das Wort Attribut entspricht dem SchlÃ¼ssel im WÃ¶rterbuch. Das Kode-Attribut entspricht dem Wert.

Hier wird Kode verwendet, um ein Array fÃ¼r die Punktmatrix zum Anzeigen von Bildern zu speichern (ein 8x8-Bit-Array).

Hier kann der Array-Pfeil verwendet werden, um das Pfeilmuster in AufwÃ¤rts-, AbwÃ¤rts-, Links- und Rechtsrichtung auf der LED-Punktmatrix anzuzeigen.

Jetzt werden unten und oben kommentiert und bei Bedarf auskommentiert.

Die Array-PrÃ¼fung wird verwendet, um diese beiden Bilder anzuzeigen: â€žÃ—â€œ und â€žâˆšâ€œ.

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }Â Â Â Â 
    }


Die Funktion ``lookup()`` funktioniert durch â€žÃœberprÃ¼fen des WÃ¶rterbuchsâ€œ. Definieren Sie einen ``key`` , 
suchen Sie die gleichen WÃ¶rter wie der ``key`` in der Struktur ``GLYPH * glyph`` und geben Sie die entsprechenden Informationen zurÃ¼ck - â€žkodeâ€œ des bestimmten Wortes.

Die Funktion ``strcmp()`` wird verwendet, 
um die IdentitÃ¤t von zwei Zeichenfolgen ``glyph[i].word`` und ``key`` zu vergleichen; 
Wenn die IdentitÃ¤t beurteilt wird, geben Sie den ``glyph[i].code`` zurÃ¼ck (wie gezeigt).

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
    Â Â Â Â Â Â Â Â hc595_in(glyphCode[i]);
    Â Â Â Â Â Â Â Â hc595_in(0x80>>i);
    Â Â Â Â Â Â Â Â hc595_out();
    Â Â Â Â }
    }

Zeigen Sie das angegebene Muster in der Punktmatrix an.

.. code-block:: c

    voidÂ createGlyph(){
    Â Â Â Â srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â waypoint=arrow[i].word;
    Â Â Â Â stage="PLAY";
    Â Â Â Â alarm(2);
    }


Mit der Funktion ``createGlyph()`` wird zufÃ¤llig eine Richtung ausgewÃ¤hlt (das Wortattribut eines Elements im array arrow[]: â€žleftâ€œ, â€žrightâ€œâ€¦). Stellen Sie die BÃ¼hne auf â€žPLAYâ€œ und starten Sie eine 2-Sekunden-Weckerfunktion.

``srand(time(NULL))`` : Initialisiert zufÃ¤llige Seeds, die von der Systemuhr stammen.

``(sizeof(arrow)/sizeof(arrow[0]))`` : Ermittelt die LÃ¤nge des Arrays, das Ergebnis ist 2.

``rand()%2`` : Der Rest ist 0 oder 1, erhalten durch Teilen einer generierten Zufallsnummer durch 2.

``waypoint=arrow[i].word`` : Das Ergebnis sollte ``right`` oder ``left`` sein.

.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
    Â Â Â Â alarm(0)==0;
    Â Â Â Â if(inputKey==waypoint||inputKey=="empty")
    Â Â Â Â {
    Â Â Â Â Â Â Â Â waypoint="wrong";
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â waypoint="right";
    Â Â Â Â }
    Â Â Â Â stage="CHECK";
    Â Â Â Â alarm(1);
    }


Mit ``checkPoint()`` wird die Tasteneingabe Ã¼berprÃ¼ft. 
Wenn die Taste nicht gedrÃ¼ckt wird oder die Taste in die gleiche Richtung wie der Pfeil gedrÃ¼ckt wird, 
ist das Ergebnis des Wegpunkts falsch und auf der Punktmatrix wird â€žxâ€œ angezeigt. 
Andernfalls ist der Wegpunkt richtig und die Punktmatrix zeigt â€žâˆšâ€œ an. 
Hier ist die Stufe CHECK und es kann eine 1-Sekunden-Weckerfunktion eingestellt werden.

``alarm()`` wird auch als â€žWeckerâ€œ bezeichnet, bei dem ein Timer eingestellt werden kann, 
und sendet SIGALRM-Signale an den Fortschritt, wenn die definierte Zeit abgelaufen ist.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
    Â Â Â Â {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
    Â Â Â Â {checkPoint("left");}
    }


``getKey()`` liest die ZustÃ¤nde dieser beiden SchaltflÃ¤chen; 
Wenn die rechte Taste gedrÃ¼ckt wird, ist der Parameter der Funktion ``checkPoint()``
rechts und wenn die linke Taste gedrÃ¼ckt wird, bleibt der Parameter links.

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
    Â Â Â Â Â Â Â Â checkPoint("empty");
    Â Â Â Â }
    Â Â Â Â elseÂ if(stage=="CHECK"){
    Â Â Â Â Â Â Â Â createGlyph();
    Â Â Â Â }
    }

Previously, timer() was called when set as the alarm() timeâ€™s up. Then
under the \"PLAY\" mode, checkPoint() is to be called to judge the
outcome. If the program is set to \"CHECK\" mode, the function
createGlyph() should be called to select new patterns.


Zuvor wurde ``timer()`` aufgerufen, 
wenn die Alarmzeit abgelaufen ist. 
Im Modus â€žPLAYâ€œ soll dann ``checkPoint()`` aufgerufen werden, 
um das Ergebnis zu beurteilen. 
Wenn das Programm auf den Modus â€žCHECKâ€œ eingestellt ist, sollte die Funktion ``createGlyph()`` aufgerufen werden, 
um neue Muster auszuwÃ¤hlen.


.. code-block:: c

    voidÂ main(){
    Â Â Â Â setup();
    Â Â Â Â signal(SIGALRM,timer);
    Â Â Â Â createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â Â Â Â Â getKey();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    }


Die Funktionsweise des Funktions ``signal(SIGALRM,timer)`` : Aufruf der Funktion ``timer()``, 
wenn ein ``SIGALRM`` -Signal (vom Weckerfunktions ``alarm()`` erzeugt) empfangen wird.

Wenn das Programm startet, rufen Sie zunÃ¤chst einmal ``createGlyph()`` auf und starten Sie dann die Schleife.

In der Schleife: Im PLAY-Modus zeigt die Punktmatrix Pfeilmuster an und Ã¼berprÃ¼ft den SchaltflÃ¤chenstatus. Im CHECK-Modus wird â€žxâ€œ oder â€žâˆšâ€œ angezeigt.
