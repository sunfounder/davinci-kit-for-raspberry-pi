.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum√©rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances Exclusivos**: Accede anticipadamente a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Aprovecha descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo.

.. _2.1.4_py_pi5:

2.1.4 Potenci√≥metro
=====================

Introducci√≥n
---------------

La funci√≥n ADC puede usarse para convertir se√±ales anal√≥gicas en se√±ales 
digitales, y en este experimento se utiliza el ADC0834 para lograr esta 
conversi√≥n. Aqu√≠ implementamos este proceso utilizando un potenci√≥metro. 
El potenci√≥metro cambia la cantidad f√≠sica ‚Äî voltaje, que es luego convertida 
mediante la funci√≥n ADC.

Componentes Necesarios
--------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../python_pi5/img/2.1.7_potentiometer_list.png

.. Es conveniente comprar un kit completo; aqu√≠ est√° el enlace:

.. .. list-table::
..     :widths: 20 20 20
..     :header-rows: 1

..     *   - Nombre	
..         - ELEMENTOS EN ESTE KIT
..         - ENLACE
..     *   - Kit Raphael
..         - 337
..         - |link_Raphael_kit|

.. Tambi√©n puedes comprarlos individualmente desde los enlaces a continuaci√≥n.

.. .. list-table::
..     :widths: 30 20
..     :header-rows: 1

..     *   - INTRODUCCI√ìN A LOS COMPONENTES
..         - ENLACE DE COMPRA

..     *   - :ref:`gpio_extension_board`
..         - |link_gpio_board_buy|
..     *   - :ref:`breadboard`
..         - |link_breadboard_buy|
..     *   - :ref:`wires`
..         - |link_wires_buy|
..     *   - :ref:`resistor`
..         - |link_resistor_buy|
..     *   - :ref:`led`
..         - |link_led_buy|
..     *   - :ref:`potentiometer`
..         - |link_potentiometer_buy|
..     *   - :ref:`adc0834`
..         - \-

Diagrama de Conexi√≥n
------------------------

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_1.png

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_2.png

Procedimientos del Experimento
---------------------------------

**Paso 1:** Monta el circuito.

.. image:: ../python_pi5/img/2.1.7_Potentiometer_circuit.png


.. note::
    Coloca el chip de acuerdo a la posici√≥n mostrada en la imagen. Observa que 
    las ranuras en el chip deben estar hacia la izquierda cuando est√© colocado.

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**Paso 3:** Ejecuta el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.4_Potentiometer_zero.py

Una vez que el c√≥digo est√© en ejecuci√≥n, gira la perilla del potenci√≥metro 
y ver√°s c√≥mo cambia la intensidad del LED en consecuencia.

.. warning::

    Si aparece el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulta :ref:`faq_soc` 

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Antes de eso, aseg√∫rate de estar en la ruta del c√≥digo fuente, como ``raphael-kit/python-pi5``. Despu√©s de modificar el c√≥digo, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import PWMLED
   import ADC0834
   import time

   # Inicializa un LED PWM en el pin GPIO 22
   led = PWMLED(22)

   # Configura el m√≥dulo ADC0834
   ADC0834.setup()

   def MAP(x, in_min, in_max, out_min, out_max):
       """
       Map a value from one range to another.
       :param x: The value to be mapped.
       :param in_min: The lower bound of the value's current range.
       :param in_max: The upper bound of the value's current range.
       :param out_min: The lower bound of the value's target range.
       :param out_max: The upper bound of the value's target range.
       :return: The mapped value.
       """
       return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

   try:
       while True:
           # Obtiene la lectura actual del m√≥dulo ADC0834
           res = ADC0834.getResult()
           print('res = %d' % res)

           # Mapea el valor del ADC a un rango adecuado para la intensidad del LED
           R_val = MAP(res, 0, 255, 0, 100)

           # Ajusta la intensidad del LED
           led.value = float(R_val / 100)

           # Espera 0.2 segundos antes de leer nuevamente
           time.sleep(0.2)

   # Salida segura cuando se presiona 'Ctrl+C'
   except KeyboardInterrupt: 
       led.value = 0  # Apaga el LED


**Explicaci√≥n del C√≥digo**

#. ``gpiozero`` para el control del LED PWM, ``ADC0834`` para la conversi√≥n anal√≥gica a digital, y ``time`` para implementar pausas.

   .. code-block:: python

       #!/usr/bin/env python3

       from gpiozero import PWMLED
       import ADC0834
       import time

#. Inicializa un objeto PWMLED conectado al pin GPIO 22 y configura el convertidor ADC0834.

   .. code-block:: python

       # Inicializa un LED PWM en el pin GPIO 22
       led = PWMLED(22)

       # Configura el m√≥dulo ADC0834
       ADC0834.setup()

#. Define una funci√≥n llamada ``MAP`` para convertir un rango de valores a otro, √∫til para ajustar los niveles de brillo del LED.

   .. code-block:: python

       def MAP(x, in_min, in_max, out_min, out_max):
           return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

#. Lee continuamente el valor del ADC en un bucle, mapeando la lectura (0-255) a un nivel de brillo (0-100) para el LED. Ajusta la intensidad del LED basado en este valor mapeado. Implementa una pausa de 0.2 segundos para una mayor legibilidad y estabilidad.

   .. code-block:: python

       try:
           while True:
               # Obtiene la lectura actual del m√≥dulo ADC0834
               res = ADC0834.getResult()
               print('res = %d' % res)

               # Mapea el valor del ADC a un rango adecuado para la intensidad del LED
               R_val = MAP(res, 0, 255, 0, 100)

               # Ajusta la intensidad del LED
               led.value = float(R_val / 100)

               # Espera 0.2 segundos antes de leer nuevamente
               time.sleep(0.2)

       # Salida segura cuando se presiona 'Ctrl+C'
       except KeyboardInterrupt: 
           led.value = 0  # Apaga el LED
