.. note::

    隆Hola! Bienvenido a la comunidad de entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. nete para profundizar en Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **驴Por qu茅 unirse?**

    - **Soporte de expertos**: Resuelve problemas postventa y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Acceso exclusivo**: Obt茅n primicias sobre nuevos productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy mismo.

2.1.4 Potenci贸metro
======================

Introducci贸n
----------------

La funci贸n de ADC permite convertir se帽ales anal贸gicas en digitales, 
y en este experimento se usa el ADC0834 para realizar esta conversi贸n 
mediante un potenci贸metro. El potenci贸metro modifica la cantidad f铆sica 
de voltaje, que luego es convertida por la funci贸n ADC.

Componentes
---------------

.. image:: img/list_2.1.4_potentiometer.png

Principio
-------------

**ADC0834**

El ADC0834 es un convertidor anal贸gico-digital de 8 bits `successive
approximation <https://cn.bing.com/dict/search?q=successive approximations&FORM=BDVSP6&mkt=zh-cn>`__con aproximaci贸n 
sucesiva, equipado con un multiplexor multicanal configurable de entrada y 
salida en serie. La entrada y salida en serie est谩n configuradas para interactuar 
con registros de desplazamiento est谩ndar o microprocesadores.

.. image:: img/image309.png


**Secuencia de Operaci贸n**

La conversi贸n se inicia colocando CS en bajo, lo que habilita todos los 
circuitos l贸gicos. CS debe mantenerse en bajo durante todo el proceso de 
conversi贸n. El procesador proporciona una entrada de reloj, y con cada 
transici贸n de bajo a alto de la entrada de reloj, los datos en DI se desplazan 
al registro de direcci贸n del multiplexor. El primer valor alto en la entrada 
es el bit de inicio, seguido de una palabra de asignaci贸n de 3 a 4 bits. 
Con cada transici贸n de reloj, el bit de inicio y la palabra de asignaci贸n se 
desplazan a trav茅s del registro de desplazamiento.

Cuando el bit de inicio alcanza la posici贸n de inicio en el registro del 
multiplexor, se selecciona el canal de entrada y comienza la conversi贸n. 
La salida de estado de SAR (SARS) pasa a alto indicando que la conversi贸n 
est谩 en progreso, y DI en el registro de desplazamiento del multiplexor se 
desactiva durante la conversi贸n.

Se inserta autom谩ticamente un per铆odo de reloj para permitir que el canal 
seleccionado se estabilice. La salida de datos DO sale del estado de alta 
impedancia y proporciona un nivel bajo inicial durante este per铆odo de 
estabilizaci贸n del multiplexor. El comparador SAR compara salidas sucesivas 
de la escalera resistiva con la se帽al anal贸gica entrante. A medida que avanza 
la conversi贸n, los datos de conversi贸n se env铆an en serie desde el pin de salida 
DO, comenzando por el bit m谩s significativo (MSB).

Despu茅s de ocho per铆odos de reloj, la conversi贸n se completa y la salida SARS 
pasa a bajo. Finalmente, se emite el bit menos significativo despu茅s de la 
secuencia de datos comenzando por el MSB.

.. image:: img/image175.png
    :width: 800
    :align: center

**Tabla de L贸gica de Control de Direcci贸n del MUX ADC0834**

.. image:: img/image176.png
    :width: 800
    :align: center


**Potenci贸metro**

El potenci贸metro es un componente de resistencia con tres terminales, y su 
valor de resistencia puede ajustarse seg煤n ciertas variaciones. Consiste en 
una resistencia y un cepillo m贸vil. Cuando el cepillo se desplaza a lo largo 
de la resistencia, se obtiene una salida de resistencia o voltaje que var铆a 
seg煤n el desplazamiento.

.. image:: img/image310.png
    :width: 300
    :align: center

Las funciones del potenci贸metro en el circuito son las siguientes:

1. Actuar como divisor de voltaje

El potenci贸metro es una resistencia ajustable de forma continua. Cuando ajustas 
el eje o la manija deslizante del potenci贸metro, el contacto m贸vil se desplaza 
sobre la resistencia. En este punto, se puede obtener un voltaje de salida 
dependiendo del voltaje aplicado al potenci贸metro y del 谩ngulo de rotaci贸n del 
brazo m贸vil o de la distancia que se mueva.

Diagrama Esquem谩tico
------------------------

.. image:: img/image311.png

.. image:: img/image312.png


Procedimientos Experimentales
-------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image180.png
    :width: 800

.. note::
    Coloca el chip siguiendo la posici贸n correspondiente en la imagen. Ten en 
    cuenta que las ranuras en el chip deben estar hacia la izquierda al colocarlo.

Para Usuarios de Lenguaje C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Abre el archivo de c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.4/

**Paso 3:** Compila el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.4_Potentiometer.c -lwiringPi

**Paso 4:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu茅s de ejecutar el c贸digo, gira el mando del potenci贸metro y la intensidad 
del LED cambiar谩 en consecuencia.

.. note::

    Si no funciona despu茅s de ejecutarlo, o aparece un mensaje de error: \"wiringPi.h: No such file or directory", consulta :ref:`C code is not working?`.
**C贸digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de entrada 煤nica
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // IMPAR
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci贸n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        uchar analogVal;
        if(wiringPiSetup() == -1){ // Si la inicializaci贸n de wiring falla, imprime mensaje en pantalla
            printf("setup wiringPi failed !");
            return 1;
        }
        softPwmCreate(LedPin,  0, 100);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            delay(100);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }
        return 0;
    }

**Explicaci贸n del C贸digo**

.. code-block:: c

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

Define CS, CLK, DIO del ADC0834 y con茅ctalos a GPIO0, GPIO1 y GPIO2, 
respectivamente. Luego, conecta el LED al GPIO3.

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de entrada 煤nica
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // IMPAR
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci贸n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

Esta es una funci贸n del ADC0834 para obtener la conversi贸n de anal贸gico a 
digital. El flujo de trabajo espec铆fico es el siguiente:

.. code-block:: c

    digitalWrite(ADC_CS, 0);
Establece CS en nivel bajo y comienza a habilitar la conversi贸n AD.

.. code-block:: c

    // Bit de inicio
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Cuando ocurre la primera transici贸n de bajo a alto en la entrada de reloj, 
establece DIO en 1 como bit de inicio. En los tres pasos siguientes, se env铆an 
3 palabras de asignaci贸n.

.. code-block:: c

    // Modo de entrada 煤nica
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Cuando ocurre la segunda transici贸n de bajo a alto en la entrada de reloj, 
configura DIO en 1 y selecciona el modo SGL.

.. code-block:: c

    // IMPAR
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Al ocurrir la tercera transici贸n, el valor de DIO es controlado por la 
variable **odd**.

.. code-block:: c

    // Selecci贸n
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);

Con la cuarta transici贸n de bajo a alto de CLK, el valor de DIO es controlado 
por la variable **sel**.

Bajo la condici贸n de que channel=0, sel=0, odd=0, las f贸rmulas de operaci贸n 
para **sel** y **odd** son las siguientes:

.. code-block:: c

    int sel = channel > 1 & 1;
    int odd = channel & 1;

Cuando se cumple la condici贸n channel=1, sel=0, odd=1, consulta la siguiente 
tabla de l贸gica de control de direcciones. Aqu铆 se elige CH1, y el bit de 
inicio se desplaza a la ubicaci贸n inicial del registro del multiplexor, 
comenzando la conversi贸n.

.. image:: img/image313.png


.. code-block:: c

    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

Aqu铆, se establece DIO en 1 dos veces; puedes ignorarlo.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

En la primera declaraci贸n for(), tan pronto como el quinto pulso de CLK pasa 
de alto a bajo, establece DIO en modo de entrada. Luego comienza la conversi贸n 
y el valor convertido se almacena en la variable dat1. Despu茅s de ocho per铆odos 
de reloj, la conversi贸n se completa.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

En la segunda declaraci贸n for(), se env铆an los valores convertidos a trav茅s de 
DO despu茅s de otros ocho per铆odos de reloj y se almacenan en la variable dat2.

.. code-block:: c

    digitalWrite(ADC_CS,1);
    pinMode(ADC_DIO, OUTPUT);
    return(dat1==dat2) ? dat1 : 0;

return(dat1==dat2) ? dat1 : 0 se usa para comparar el valor obtenido durante 
la conversi贸n con el valor de salida. Si son iguales, se devuelve el valor de 
conversi贸n dat1; de lo contrario, se devuelve 0. Aqu铆, el flujo de trabajo del 
ADC0834 se completa.

.. code-block:: c

    softPwmCreate(LedPin,  0, 100);

La funci贸n crea un pin PWM en software, LedPin, luego establece el ancho de pulso 
inicial en 0, y el per铆odo de PWM es 100 x 100us.

.. code-block:: c

    while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }

En el programa principal, lee el valor del canal 0, que est谩 conectado a un 
potenci贸metro. Almacena el valor en la variable analogVal y luego escr铆belo 
en LedPin. Ahora puedes ver c贸mo la intensidad del LED cambia con el valor 
del potenci贸metro.

Para Usuarios de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Abre el archivo de c贸digo

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.4_Potentiometer.py

Despu茅s de ejecutar el c贸digo, gira el mando del potenci贸metro y la 
intensidad del LED cambiar谩 en consecuencia.

**C贸digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c贸digo a continuaci贸n. Pero antes, debes ir a la ruta de origen del c贸digo, como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import ADC0834
    import time

    LedPin = 22

    def setup():
        global led_val
        # Configura los modos de GPIO en numeraci贸n BCM
        GPIO.setmode(GPIO.BCM)
        # Configura el modo de LedPin como salida y el nivel inicial en alto (3.3v)
        GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
        ADC0834.setup()
        # Configura el LED como canal PWM con frecuencia de 2KHz
        led_val = GPIO.PWM(LedPin, 2000)
        # Inicia con valor 0
        led_val.start(0)

    def destroy():
        # Detiene todos los canales PWM
        led_val.stop()
        # Libera recursos
        GPIO.cleanup()
    def loop():
        while True:
            analogVal = ADC0834.getResult()
            print ('analog value = %d' % analogVal)
            led_val.ChangeDutyCycle(analogVal*100/255)
            time.sleep(0.2)
    if __name__ == '__main__':
        setup()
        try:
            loop()
        except KeyboardInterrupt: # Cuando se presiona 'Ctrl+C', se ejecutar谩 el programa destroy().
            destroy()

**Explicaci贸n del C贸digo**

.. code-block:: python

    import ADC0834

Importa la biblioteca ADC0834. Puedes revisar el contenido de la biblioteca usando el comando nano ADC0834.py.

.. code-block:: python

    def setup():
        global led_val
        # Configura los modos de GPIO en numeraci贸n BCM
        GPIO.setmode(GPIO.BCM)
        # Configura el modo de LedPin como salida y el nivel inicial en alto (3.3v)
        GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
        ADC0834.setup()
        # Configura el LED como canal PWM con frecuencia de 2KHz
        led_val = GPIO.PWM(LedPin, 2000)

        # Inicia con valor 0
        led_val.start(0)

En setup(), define el modo de nombramiento como BCM, configura LedPin como 
canal PWM y establece una frecuencia de 2Khz.

**ADC0834.setup():** Inicializa ADC0834 y conecta los pines definidos CS, CLK, DIO del ADC0834 a GPIO17, GPIO18 y GPIO27, respectivamente.

.. code-block:: python

    def loop():
        while True:
            res = ADC0834.getResult()
            print ('res = %d' % res)
            R_val = MAP(res, 0, 255, 0, 100)
            led_val.ChangeDutyCycle(R_val)
            time.sleep(0.2)

La funci贸n getResult() se usa para leer los valores anal贸gicos de los cuatro 
canales de ADC0834. Por defecto, la funci贸n lee el valor de CH0, y si deseas 
leer otros canales, ingresa el n煤mero de canal en **( )**, por ejemplo, getResult(1).

La funci贸n loop() primero lee el valor de CH0 y luego lo asigna a la variable 
res. Despu茅s, llama a la funci贸n MAP para asignar el valor le铆do del potenci贸metro 
al rango de 0~100. Este paso se utiliza para controlar el ciclo de trabajo de 
LedPin. Ahora, puedes observar que el brillo del LED cambia con el valor del 
potenci贸metro.


Imagen del Fen贸meno
----------------------

.. image:: img/image181.jpeg


