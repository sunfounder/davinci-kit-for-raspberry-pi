.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Explorez en profondeur Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et tirages au sort** : Participez √† des tirages au sort et √† des promotions sp√©ciales pour les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.3 DHT-11
===============

Introduction
---------------

Le capteur num√©rique de temp√©rature et d'humidit√© DHT11 est un capteur composite 
qui contient un signal num√©rique calibr√© de temp√©rature et d'humidit√©. La technologie 
de collecte de modules num√©riques d√©di√©s ainsi que la technologie de d√©tection de la 
temp√©rature et de l'humidit√© sont appliqu√©es pour assurer une haute fiabilit√© et une 
excellente stabilit√©.

Les capteurs comprennent un capteur de r√©sistance √† l'humidit√© et un capteur de 
temp√©rature NTC, tous deux connect√©s √† un microcontr√¥leur haute performance 8 bits.

Composants
-------------

.. image:: img/list_2.2.3_dht-11.png


Principe
-------------

Le DHT11 est un capteur num√©rique basique, tr√®s √©conomique, qui mesure la temp√©rature 
et l'humidit√©. Il utilise un capteur d'humidit√© capacitif et une thermistance pour 
mesurer l'air ambiant, puis transmet un signal num√©rique via la broche de donn√©es 
(aucune entr√©e analogique n'est requise).

.. image:: img/image205.png
    :width: 200


Seules trois broches sont disponibles : VCC, GND et DATA. Le processus de communication 
commence par l'envoi de signaux de d√©marrage au DHT11 via la ligne DATA, et le DHT11 
r√©pond par un signal de confirmation. Ensuite, l'h√¥te re√ßoit ce signal de r√©ponse et 
commence √† recevoir 40 bits de donn√©es d'humidit√© et de temp√©rature (8 bits pour l'humidit√© 
enti√®re, 8 bits pour la d√©cimale de l'humidit√©, 8 bits pour la temp√©rature enti√®re, 8 bits 
pour la d√©cimale de la temp√©rature et 8 bits pour le checksum). Pour plus d'informations, 
veuillez consulter la fiche technique du DHT11.

Sch√©ma de principe
----------------------

.. image:: img/image326.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image207.png
    :width: 800



Pour les utilisateurs C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.3/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.3_DHT.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, le programme affichera la temp√©rature et 
l'humidit√© d√©tect√©es par le DHT11 sur l'√©cran de l'ordinateur.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur : "wiringPi.h : Aucun fichier ou r√©pertoire de ce type", veuillez 
    vous r√©f√©rer √† :ref:`C code is not working?`.
    **Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>

    #define maxTim 85
    #define dhtPin 0

    int dht11_dat[5] = {0,0,0,0,0};

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // tirer la broche vers le bas pendant 18 millisecondes
        pinMode(dhtPin, OUTPUT);
        digitalWrite(dhtPin, LOW);
        delay(18);
        // puis la tirer vers le haut pendant 40 microsecondes
        digitalWrite(dhtPin, HIGH);
        delayMicroseconds(40); 
        // pr√©parer la lecture de la broche
        pinMode(dhtPin, INPUT);

        // d√©tecter le changement et lire les donn√©es
        for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);

            if (counter == 255) break;
            // ignorer les 3 premi√®res transitions
            if ((i >= 4) && (i%2 == 0)) {
                // ins√©rer chaque bit dans les octets de stockage
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }
        // v√©rifier que nous avons bien lu 40 bits (8 bits x 5) + v√©rifier le checksum dans le dernier octet
        // afficher les donn√©es si elles sont correctes
        if ((j >= 40) && 
                (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
            Fah = dht11_dat[2] * 9. / 5. + 32;
            printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                    dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
        }
    }

    int main (void) {
        if(wiringPiSetup() == -1){ // en cas d'√©chec de l'initialisation de wiringPi, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1; 
        }
        while (1) {
            readDht11();
            delay(500); // attendre 1 seconde pour rafra√Æchir
        }
        return 0 ;
    }

**Explication du code**

.. code-block:: c

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // ...
    }

Cette fonction permet de r√©aliser la lecture du DHT11.

Elle peut √™tre divis√©e en 3 parties principales :

1. Pr√©paration de la lecture de la broche :

.. code-block:: c

    // tirer la broche vers le bas pendant 18 millisecondes
    pinMode(dhtPin, OUTPUT);
    digitalWrite(dhtPin, LOW);
    delay(18);
    // puis la tirer vers le haut pendant 40 microsecondes
    digitalWrite(dhtPin, HIGH);
    delayMicroseconds(40); 
    // pr√©parer la lecture de la broche
    pinMode(dhtPin, INPUT);

Le flux de communication est d√©termin√© par le timing de fonctionnement.

.. image:: img/image208.png
    :width: 800



Lorsque le DHT11 d√©marre, le MCU envoie un signal bas, puis maintient le signal 
√† un niveau haut pendant 40 ¬µs. Apr√®s cela, la d√©tection de l'√©tat de l'environnement 
ext√©rieur commence.

2. Lecture des donn√©es :

.. code-block:: c

    // d√©tecter le changement et lire les donn√©es
    for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);
            if (counter == 255) break;
            // ignorer les 3 premi√®res transitions
            if ((i >= 4) && (i%2 == 0)) {
                // ins√©rer chaque bit dans les octets de stockage
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }

La boucle stocke les donn√©es d√©tect√©es dans le tableau dht11_dat[]. Le DHT11 
transmet des donn√©es de 40 bits √† la fois. Les 16 premiers bits concernent 
l'humidit√©, les 16 bits suivants concernent la temp√©rature et les 8 derniers 
bits sont utilis√©s pour la v√©rification. Le format des donn√©es est :

**8 bits de donn√©es d'humidit√© enti√®re** + **8 bits de donn√©es d'humidit√© d√©cimale** +
 **8 bits de donn√©es de temp√©rature enti√®re** + **8 bits de donn√©es de temp√©rature d√©cimale** + **8 bits de bit de v√©rification**.

3. Affichage de l'humidit√© et de la temp√©rature :

.. code-block:: c

    // v√©rifier que nous avons bien lu 40 bits (8 bits x 5) + v√©rifier le checksum dans le dernier octet
    // afficher les donn√©es si elles sont correctes
    if ((j >= 40) && 
            (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
        Fah = dht11_dat[2] * 9. / 5. + 32;
        printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
    }

Lorsque les donn√©es stock√©es atteignent 40 bits, la validit√© des donn√©es est v√©rifi√©e 
via le **bit de contr√¥le (dht11_dat[4])**, puis la temp√©rature et l'humidit√© sont affich√©es.

Par exemple, si les donn√©es re√ßues sont 00101011 (valeur de l'humidit√© sur 8 bits) 
00000000 (valeur d√©cimale de l'humidit√© sur 8 bits) 00111100 (valeur de la temp√©rature 
sur 8 bits) 00000000 (valeur d√©cimale de la temp√©rature sur 8 bits) 01100111 (bit de v√©rification)

**Calcul :**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Si le r√©sultat final est √©gal au bit de v√©rification, alors les donn√©es sont correctes :

Humidit√© = 43%, Temp√©rature = 60¬∞C.

Si ce n'est pas √©gal au bit de v√©rification, la transmission des donn√©es est incorrecte et les donn√©es doivent √™tre lues √† nouveau.


Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2:** Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3:** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Une fois le code ex√©cut√©, le programme affichera la temp√©rature et l'humidit√© 
d√©tect√©es par le DHT11 √† l'√©cran de l'ordinateur.


**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source du code comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    dhtPin = 17

    GPIO.setmode(GPIO.BCM)

    MAX_UNCHANGE_COUNT = 100

    STATE_INIT_PULL_DOWN = 1
    STATE_INIT_PULL_UP = 2
    STATE_DATA_FIRST_PULL_DOWN = 3
    STATE_DATA_PULL_UP = 4
    STATE_DATA_PULL_DOWN = 5

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)

        unchanged_count = 0
        last = -1
        data = []
        while True:
            current = GPIO.input(dhtPin)
            data.append(current)
            if last != current:
                unchanged_count = 0
                last = current
            else:
                unchanged_count += 1
                if unchanged_count > MAX_UNCHANGE_COUNT:
                    break

        state = STATE_INIT_PULL_DOWN

        lengths = []
        current_length = 0

        for current in data:
            current_length += 1

            if state == STATE_INIT_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_INIT_PULL_UP
                else:
                    continue
            if state == STATE_INIT_PULL_UP:
                if current == GPIO.HIGH:
                    state = STATE_DATA_FIRST_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_FIRST_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_DATA_PULL_UP
                else:
                    continue
            if state == STATE_DATA_PULL_UP:
                if current == GPIO.HIGH:
                    current_length = 0
                    state = STATE_DATA_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_PULL_DOWN:
                if current == GPIO.LOW:
                    lengths.append(current_length)
                    state = STATE_DATA_PULL_UP
                else:
                    continue
        if len(lengths) != 40:
            #print ("Donn√©es incorrectes, ignorer")
            return False

        shortest_pull_up = min(lengths)
        longest_pull_up = max(lengths)
        halfway = (longest_pull_up + shortest_pull_up) / 2
        bits = []
        the_bytes = []
        byte = 0

        for length in lengths:
            bit = 0
            if length > halfway:
                bit = 1
            bits.append(bit)
        #print ("bits: %s, longueur: %d" % (bits, len(bits)))
        for i in range(0, len(bits)):
            byte = byte << 1
            if (bits[i]):
                byte = byte | 1
            else:
                byte = byte | 0
            if ((i + 1) % 8 == 0):
                the_bytes.append(byte)
                byte = 0
        #print (the_bytes)
        checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
        if the_bytes[4] != checksum:
            #print ("Donn√©es incorrectes, ignorer")
            return False

        return the_bytes[0], the_bytes[2]

    def main():

        while True:
            result = readDht11()
            if result:
                humidity, temperature = result
                print ("humidity: %s %%,  Temperature: %s C`" % (humidity, temperature))
            time.sleep(1)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy() 

**Explication du code**

.. code-block:: python

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)
        unchanged_count = 0
        last = -1
        data = []
        #...

Cette fonction impl√©mente les fonctionnalit√©s du DHT11. Elle stocke les 
donn√©es d√©tect√©es dans le tableau the_bytes[]. Le DHT11 transmet 40 bits 
de donn√©es √† la fois. Les 16 premiers bits sont li√©s √† l'humidit√©, les 
16 bits suivants sont li√©s √† la temp√©rature et les 8 derniers bits servent 
√† la v√©rification. Le format des donn√©es est :

**8 bits de donn√©es d'humidit√© enti√®re** + **8 bits de donn√©es d'humidit√© d√©cimale** 
+ **8 bits de donn√©es de temp√©rature enti√®re** + **8 bits de donn√©es de temp√©rature d√©cimale** + **8 bits de bit de v√©rification**.

Lorsque la validit√© est v√©rifi√©e via le bit de contr√¥le, la fonction renvoie deux 
r√©sultats : 1. erreur ; 2. humidit√© et temp√©rature.

.. code-block:: python

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        #print ("Donn√©es incorrectes, ignorer")
        return False

    return the_bytes[0], the_bytes[2]

Par exemple, si les donn√©es re√ßues sont 00101011 (valeur sur 8 bits de l'humidit√© 
enti√®re) 00000000 (valeur sur 8 bits de l'humidit√© d√©cimale) 00111100 (valeur sur 
8 bits de la temp√©rature enti√®re) 00000000 (valeur sur 8 bits de la temp√©rature 
d√©cimale) 01100111 (bit de v√©rification)

**Calcul :**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Si le r√©sultat final est √©gal au bit de contr√¥le, la transmission des donn√©es 
est correcte. Sinon, la transmission est incorrecte et la fonction renverra False.

Si le r√©sultat est correct, la fonction renverra the_bytes[0] et the_bytes[2] et 
affichera "Humidit√© = 43%, Temp√©rature = 60¬∞C".


Photo du ph√©nom√®ne
-----------------------

.. image:: img/image209.jpeg