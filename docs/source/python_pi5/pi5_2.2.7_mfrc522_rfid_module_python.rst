 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _2.2.10_py:

2.2.7 Module RFID MFRC522
=============================

Introduction
---------------

L'identification par radiofr√©quence (RFID) d√©signe les technologies utilisant la 
communication sans fil entre un objet (ou √©tiquette) et un dispositif d'interrogation 
(ou lecteur) pour suivre et identifier automatiquement ces objets.

Parmi les applications les plus courantes de cette technologie, on trouve les cha√Ænes 
d'approvisionnement au d√©tail, les cha√Ænes d'approvisionnement militaires, les m√©thodes 
de paiement automatis√©es, le suivi et la gestion des bagages, le suivi des documents et la 
gestion pharmaceutique, pour n'en citer que quelques-unes.

Dans ce projet, nous allons utiliser la RFID pour la lecture et l'√©criture.

Composants N√©cessaires
------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/list_2.2.7.png

Sch√©ma √âlectrique
--------------------

.. image:: ../img/image331.png

Proc√©dures Exp√©rimentales
----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: ../img/image232.png

**√âtape 2 :** Activez le SPI avant de commencer l'exp√©rience, voir :ref:`spi_configuration` pour les d√©tails. 

**√âtape 3 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 4 :** Ex√©cutez ``2.2.10_write.py``.

.. raw:: html

    <run></run>

.. code-block::

    sudo python3 2.2.10_write.py

**√âtape 5 :** Apr√®s avoir ex√©cut√© le programme, entrez le texte que vous souhaitez √©crire (jusqu'√† 16 caract√®res), par exemple "welcome", puis appuyez sur Entr√©e pour confirmer. Ensuite, le message "Les donn√©es ont √©t√© √©crites sur la carte" s'affichera. Enfin, appuyez sur ``Ctrl+C`` pour arr√™ter l'ex√©cution du code.

.. code-block::

    Veuillez placer votre carte RFID sur le lecteur...
    Appuyez sur Ctrl-C pour arr√™ter.
    Carte RFID d√©tect√©e!
    UID de la carte: 9BF6210B
    Veuillez entrer les donn√©es √† √©crire sur la carte (jusqu'√† 16 caract√®res): welcome
    Authentification du bloc 8 r√©ussie
    4 backdata &0x0F == 0x0A 10
    Donn√©es √©crites
    Les donn√©es ont √©t√© √©crites sur la carte
    Lecture des donn√©es du bloc 8:
    Secteur 8 [119, 101, 108, 99, 111, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0]

**√âtape 6 :** Ex√©cutez maintenant ``2.2.10_read.py`` pour lire les informations du tag ou de la carte que vous avez √©crites.

.. raw:: html

    <run></run>

.. code-block::

    sudo python3 2.2.10_read.py

**√âtape 7 :** Apr√®s l'ex√©cution, vous obtiendrez les informations suivantes.

.. code-block::

    Veuillez placer votre carte RFID sur le lecteur...
    Appuyez sur Ctrl-C pour arr√™ter.
    Carte RFID d√©tect√©e!
    UID de la carte: 9BF6210B
    Authentification du bloc 8 r√©ussie
    Secteur 8 [119, 101, 108, 99, 111, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    MFRC522_Read type de retour: <class 'int'>, Donn√©es: [119, 101, 108, 99, 111, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    Secteur 8 [119, 101, 108, 99, 111, 109, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    Donn√©es lues: welcome

Analyse du code pour ``2.2.10_write.py``
---------------------------------------------

Ce script Python √©crit des donn√©es fournies par l'utilisateur sur une carte RFID en utilisant le lecteur RFID MFRC522. Le script v√©rifie continuellement la pr√©sence d'une carte, invite l'utilisateur √† entrer des donn√©es √† √©crire, et confirme le succ√®s des op√©rations d'√©criture et de lecture.

#. Importations

   * ``MFRC522`` : Importe les fonctions et classes n√©cessaires aux op√©rations du lecteur RFID.
   * ``signal`` et ``time`` : ``signal`` est utilis√© pour g√©rer la terminaison contr√¥l√©e via SIGINT (Ctrl+C), et ``time`` est utilis√© pour ajouter des d√©lais dans la boucle principale.

#. Variable Globale

   * ``continue_reading`` : Contr√¥le la boucle principale, permettant au script de se terminer proprement lorsque d√©fini sur ``False``.

   .. code-block:: python

        continue_reading = True

#. Gestion des Signaux :

   * Fonction ``end_read`` : Cette fonction est d√©clench√©e lorsque ``Ctrl+C`` (SIGINT) est d√©tect√©. Elle d√©finit ``continue_reading`` sur ``False``, permettant ainsi au script de se terminer proprement.
   * ``signal.signal(signal.SIGINT, end_read)`` : Lie le signal SIGINT (Ctrl+C) √† ``end_read``, de sorte qu‚Äôen cas d'interruption, le script affiche un message et se termine proprement.

   .. code-block:: python

        signal.signal(signal.SIGINT, end_read)

#. Configuration du Lecteur RFID :

   * ``rfid_reader`` : Une instance de la classe ``MFRC522``, utilis√©e pour contr√¥ler les op√©rations du lecteur RFID.
   * ``default_key`` : Une liste de 6 octets, typiquement ``0xFF`` pour chaque octet. C'est la cl√© d'authentification par d√©faut pour la plupart des cartes RFID.

   .. code-block:: python

        # Cr√©er une instance de la classe MFRC522
        rfid_reader = MFRC522.MFRC522()

        # D√©finir la cl√© par d√©faut (6 octets, par d√©faut tous √† 0xFF)
        default_key = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]

#. Instructions pour l'Utilisateur

   Le script affiche des instructions dans la console, informant l'utilisateur de placer sa carte RFID sur le lecteur et d'utiliser ``Ctrl+C`` pour quitter.

   .. code-block:: python

        print("Veuillez placer votre carte RFID sur le lecteur...")
        print("Appuyez sur Ctrl-C pour arr√™ter.")

#. Boucle Principale : D√©tection, √âcriture et Lecture de Donn√©es

   * **D√©tection de Carte** : Le script appelle continuellement ``MFRC522_Request`` pour d√©tecter les cartes RFID. Si une carte est d√©tect√©e (``status == rfid_reader.MI_OK``), il passe √† l‚Äô√©tape suivante.
   
   .. code-block:: python

        (status, TagType) = rfid_reader.MFRC522_Request(rfid_reader.PICC_REQIDL)

        # Si une carte est d√©tect√©e
        if status == rfid_reader.MI_OK:
            print("Carte RFID d√©tect√©e!")
            ...
        else:
            # Attendre un peu avant de r√©essayer
            time.sleep(0.5)

   * **R√©cup√©ration de l‚ÄôUID de la Carte** : Appelle ``MFRC522_SelectTagSN`` pour r√©cup√©rer l'identifiant unique (UID) de la carte. Si elle r√©ussit, l'UID est converti en une cha√Æne hexad√©cimale et imprim√©. L‚ÄôUID est n√©cessaire pour l'authentification.
   
   .. code-block:: python

        (status, uid) = rfid_reader.MFRC522_SelectTagSN()

        # Si nous avons l'UID, continuer
        if status == rfid_reader.MI_OK:
            # Afficher l'UID
            uid_str = ''.join(['%02X' % i for i in uid])
            print("UID de la carte: %s" % uid_str)
            ...       
        else:
            print("Impossible d'obtenir l'UID de la carte")

   * **Pr√©paration des Donn√©es** :

     * **Demande de Saisie** : L'utilisateur est invit√© √† entrer les donn√©es √† √©crire sur la carte (jusqu'√† 16 caract√®res).
     * **Troncature des Donn√©es** : Les donn√©es sont tronqu√©es √† 16 caract√®res si l'utilisateur en entre plus.
     * **Conversion de Cha√Æne en Octets** : Les donn√©es saisies par l'utilisateur sont converties en une liste d'octets remplie √† 16 octets, comme requis par le format de stockage de la carte RFID.

   .. code-block:: python

        write_data = input("Veuillez entrer les donn√©es √† √©crire sur la carte (jusqu'√† 16 caract√®res) : ")
        # S'assurer que les donn√©es ne d√©passent pas 16 caract√®res
        write_data = write_data[:16]
        # Convertir la cha√Æne en liste d'octets, remplir jusqu'√† 16 octets
        data_to_write = [0x00]*16
        string_bytes = write_data.encode('utf-8')
        for i in range(len(string_bytes)):
            data_to_write[i] = string_bytes[i]

   * **Sp√©cification du Num√©ro de Bloc** : Le script sp√©cifie le bloc 8 pour √©crire les donn√©es. Remarque : Les num√©ros de bloc doivent √©viter les blocs de remorque de secteur, g√©n√©ralement le dernier bloc de chaque secteur, car ils sont utilis√©s pour les informations de contr√¥le.

   .. code-block:: python

        block_num = 8  # Par exemple, choisir le bloc 8

   * **Authentification de la Carte** : ``MFRC522_Auth`` authentifie le bloc sp√©cifi√© en utilisant la cl√© par d√©faut et l'UID. Si l'authentification est r√©ussie, le script proc√®de √† l'√©criture des donn√©es. Sinon, un message d'erreur est affich√©, et l'encryptage est arr√™t√©.
   
   .. code-block:: python

        status = rfid_reader.MFRC522_Auth(rfid_reader.PICC_AUTHENT1A, block_num, default_key, uid)

        if status == rfid_reader.MI_OK:
            print("Authentification du bloc %d r√©ussie" % block_num)
            ...
        else:
            print("√âchec de l'authentification")
            rfid_reader.MFRC522_StopCrypto1()

   * **√âcriture des Donn√©es sur la Carte** : ``MFRC522_Write`` √©crit les donn√©es pr√©par√©es sur le bloc sp√©cifi√© de la carte RFID. Apr√®s l'√©criture, un message confirme que les donn√©es ont √©t√© correctement √©crites sur la carte.

   .. code-block:: python
                
        rfid_reader.MFRC522_Write(block_num, data_to_write)
        print("Les donn√©es ont √©t√© √©crites sur la carte")

   * **V√©rification des Donn√©es √âcrites** : Pour v√©rifier l'op√©ration d'√©criture, le script relit les donn√©es du m√™me bloc en utilisant ``MFRC522_Read``. Les donn√©es r√©cup√©r√©es sont imprim√©es pour permettre √† l'utilisateur de v√©rifier les donn√©es.

   .. code-block:: python

        print("Lecture des donn√©es du bloc %d:" % block_num)
        rfid_reader.MFRC522_Read(block_num)

   * **Arr√™t de l'Encryptage** : ``MFRC522_StopCrypto1`` arr√™te le processus d'encryptage apr√®s les op√©rations. Cette √©tape est n√©cessaire pour r√©initialiser l'√©tat de communication de la carte.
   
   .. code-block:: python

        # Arr√™ter l'encryptage
        rfid_reader.MFRC522_StopCrypto1()

   * **Sortie de la Boucle** : Apr√®s l'√©criture et la v√©rification des donn√©es, ``continue_reading`` est d√©fini sur ``False`` pour sortir de la boucle et terminer le script.

                continue_reading = False

**Points Cl√©s**

   * **Terminaison Contr√¥l√©e** : Le script capture SIGINT (Ctrl+C) pour se terminer en toute s√©curit√© et afficher un message, permettant √† toute op√©ration en cours de se terminer avant de quitter.
   * **Interaction Utilisateur** : Invite l'utilisateur √† saisir des donn√©es, permettant ainsi de personnaliser les donn√©es √† chaque fois que la carte est √©crite.
   * **Authentification** : S'assure que l'acc√®s au bloc sp√©cifi√© est s√©curis√©, g√©rant les √©checs d'authentification de mani√®re contr√¥l√©e.
   * **Formatage des Donn√©es** : Convertit les donn√©es en cha√Æne de caract√®res en un format de liste d'octets compatible avec la structure de stockage de la carte, avec remplissage si n√©cessaire.
   * **V√©rification** : Relit les donn√©es de la carte pour confirmer une √©criture r√©ussie, am√©liorant la fiabilit√©.
   * **Modularit√©** : Le script est bien structur√© avec des fonctionnalit√©s claires pour la d√©tection, l'√©criture et la lecture, ce qui le rend plus facile √† suivre et √† maintenir.

Ce script est adapt√© aux applications n√©cessitant √† la fois des capacit√©s de lecture et d'√©criture avec des cartes RFID, telles que le contr√¥le d'acc√®s ou l'identification d'utilisateur.


Explication du code pour ``2.2.10_read.py``
-----------------------------------------------

Ce script Python utilise un **lecteur RFID (MFRC522)** pour lire les donn√©es des cartes RFID. Le script est structur√© pour v√©rifier en continu la pr√©sence de cartes, r√©cup√©rer leurs donn√©es, et g√©rer proprement les demandes de sortie gr√¢ce √† la gestion des signaux.

#. Importations :

   * ``MFRC522`` : Ce module fournit les m√©thodes pour interagir avec le lecteur RFID MFRC522.
   * ``signal`` et ``time`` : Utilis√©s pour g√©rer la terminaison du script (par exemple, avec ``Ctrl+C``) et contr√¥ler le d√©lai de certaines op√©rations.

#. Variables globales :

   * ``continue_reading`` : Un indicateur bool√©en qui contr√¥le la boucle principale de lecture, permettant au script de s'arr√™ter proprement lorsque ``Ctrl+C`` est press√©.

   .. code-block:: python

        continue_reading = True

#. Gestion des signaux :

   * Fonction ``end_read`` : Cette fonction est d√©clench√©e lorsque ``Ctrl+C`` (SIGINT) est d√©tect√©. Elle d√©finit ``continue_reading`` sur ``False``, permettant ainsi au script de se terminer proprement.
   * ``signal.signal(signal.SIGINT, end_read)`` : Associe le signal SIGINT (Ctrl+C) √† ``end_read``, de sorte qu‚Äôen cas d‚Äôinterruption, le script affiche un message et se termine proprement.

   .. code-block:: python

        signal.signal(signal.SIGINT, end_read)

#. Configuration du lecteur RFID :

   * ``rfid_reader`` : Une instance de la classe ``MFRC522``, utilis√©e pour contr√¥ler les op√©rations du lecteur RFID.
   * ``default_key`` : Une liste de 6 octets, g√©n√©ralement ``0xFF`` pour chaque octet. C'est la cl√© d'authentification par d√©faut pour la plupart des cartes RFID.
   * ``block_num`` : Sp√©cifie le num√©ro de bloc √† lire sur la carte RFID, ici d√©fini sur le bloc ``8``. Le num√©ro de bloc doit correspondre √† celui utilis√© lors de l'√©criture des donn√©es sur la carte.

   .. code-block:: python

        # Cr√©er une instance de la classe MFRC522
        rfid_reader = MFRC522.MFRC522()

        # D√©finir la cl√© par d√©faut (6 octets, par d√©faut tous √† 0xFF)
        default_key = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]

        # D√©finir le num√©ro de bloc √† lire (doit correspondre au bloc utilis√© lors de l'√©criture)
        block_num = 8  # Par exemple, bloc 8

#. Instructions pour l'utilisateur

   Le script affiche des instructions dans la console, informant l'utilisateur de placer sa carte RFID sur le lecteur et d'utiliser ``Ctrl+C`` pour quitter.

   .. code-block:: python

        print("Veuillez placer votre carte RFID sur le lecteur...")
        print("Appuyez sur Ctrl-C pour arr√™ter.")

#. Boucle principale : D√©tection de carte RFID et lecture des donn√©es.

   * **Recherche de cartes** : La boucle principale appelle continuellement ``MFRC522_Request`` pour rechercher des cartes RFID. Si une carte est d√©tect√©e, elle passe aux √©tapes suivantes.
   
     .. code-block:: python

        (status, TagType) = rfid_reader.MFRC522_Request(rfid_reader.PICC_REQIDL)

        if status == rfid_reader.MI_OK:
            print("Carte RFID d√©tect√©e!")
            ...
        else:
            # Si aucune carte n'est d√©tect√©e, attendre un court moment avant de r√©essayer
            time.sleep(0.5)

   * **R√©cup√©ration de l'UID de la carte** : Utilise ``MFRC522_SelectTagSN`` pour r√©cup√©rer l'identifiant unique (UID) de la carte. Si r√©ussi, il convertit l'UID en une cha√Æne hexad√©cimale et l'affiche. Cet UID est n√©cessaire pour authentifier la carte.

     .. code-block:: python
        
        (status, uid) = rfid_reader.MFRC522_SelectTagSN()

        # Si l'UID a √©t√© r√©cup√©r√© avec succ√®s, continuer
        if status == rfid_reader.MI_OK:
            # Convertir la liste UID en cha√Æne hexad√©cimale
            uid_str = ''.join(['%02X' % i for i in uid])
            print("UID de la carte : %s" % uid_str)
            ...
        else:
            print("Impossible d'obtenir l'UID de la carte")

   * **Authentification de la carte** : ``MFRC522_Auth`` authentifie l'acc√®s au bloc sp√©cifi√© en utilisant la cl√© par d√©faut et l'UID de la carte. Si l'authentification r√©ussit, le script passe √† la lecture des donn√©es du bloc.

     .. code-block:: python

        status = rfid_reader.MFRC522_Auth(rfid_reader.PICC_AUTHENT1A, block_num, default_key, uid)

        if status == rfid_reader.MI_OK:
            print("Authentification du bloc %d r√©ussie" % block_num)
            ...
        else:
            print("√âchec de l'authentification, code de statut : %s" % status)
            rfid_reader.MFRC522_StopCrypto1()
    
   * **Lecture des donn√©es** :
     
     * ``MFRC522_Read`` lit les donn√©es du bloc sp√©cifi√©.
     * ``data`` : Cette variable contient les donn√©es brutes du bloc si l'op√©ration de lecture r√©ussit.
     * Le script convertit chaque octet de ``data`` en caract√®res et supprime tout octet nul de remplissage (``\x00``). Les donn√©es trait√©es sont ensuite affich√©es.
     
     .. code-block:: python

        read_status, data = rfid_reader.MFRC522_Read(block_num)
        print(f"Type de retour de MFRC522_Read : {type(read_status)}, Donn√©es : {data}")

        if read_status == rfid_reader.MI_OK and data:
            print(f"Secteur {block_num} {data}")
            # Convertir les donn√©es en cha√Æne et supprimer tout octet nul de remplissage
            read_data = ''.join([chr(byte) for byte in data]).rstrip('\x00')
            print("Donn√©es lues : %s" % read_data)
        else:
            print("√âchec de la lecture des donn√©es, code de statut : %s" % read_status)

   * ``MFRC522_StopCrypto1`` est appel√© pour arr√™ter l'encryptage et r√©initialiser la communication avec la carte.

     .. code-block:: python

        # Arr√™ter l'encryptage sur la carte
        rfid_reader.MFRC522_StopCrypto1()

   * **Attente entre les lectures** : Si aucune carte n'est d√©tect√©e, la boucle se met en pause pendant 0,5 seconde avant de r√©essayer.

     .. code-block:: python

        else:
            # Si aucune carte n'est d√©tect√©e, attendre un court moment avant de r√©essayer
            time.sleep(0.5)

**Points cl√©s**

* **Sortie propre** : Le script capture le signal ``SIGINT`` pour une terminaison contr√¥l√©e, permettant au lecteur RFID de terminer les op√©rations en cours.
* **Gestion du bloc et de l'UID** : Utilise le bloc et l'UID comme composants cl√©s pour lire les donn√©es d'une carte RFID, avec une gestion appropri√©e des erreurs d'authentification et de lecture.
* **Conception modulaire** : L'utilisation de fonctions d√©di√©es du module ``MFRC522`` rend le script lisible et modulaire, simplifiant les op√©rations RFID telles que l'authentification et la lecture de donn√©es.

Image du Ph√©nom√®ne
----------------------

.. image:: ../img/image233.jpeg