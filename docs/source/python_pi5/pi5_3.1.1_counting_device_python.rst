.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder d√©di√©e aux passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez au c≈ìur de l'univers Raspberry Pi, Arduino et ESP32 avec d'autres amateurs.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Profitez d'un acc√®s anticip√© aux annonces de nouveaux produits et √† des avant-premi√®res.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de remises exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et promotions pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _py_pi5_counting_device:

3.1.1 Dispositif de Comptage
===============================

Introduction
-----------------

Dans ce projet, nous allons cr√©er un syst√®me de comptage avec affichage num√©rique, 
compos√© d'un capteur PIR et d'un afficheur √† 4 segments. Lorsque le capteur PIR d√©tecte 
qu'une personne passe √† proximit√©, le num√©ro sur l'afficheur augmentera de 1. Ce 
dispositif peut √™tre utilis√© pour compter le nombre de personnes traversant un passage.


Composants n√©cessaires
--------------------------

Dans ce projet, nous aurons besoin des composants suivants :

.. image:: ../python_pi5/img/4.1.7_counting_device_list_1.png
   :align: center

.. image:: ../python_pi5/img/4.1.7_counting_device_list_2.png
   :align: center

.. Il est bien plus pratique d'acheter un kit complet, voici le lien : 

.. .. list-table::
..     :widths: 20 20 20
..     :header-rows: 1

..     *   - Nom	
..         - √âL√âMENTS DANS CE KIT
..         - LIEN
..     *   - Kit Raphael
..         - 337
..         - |link_Raphael_kit|

.. Vous pouvez √©galement les acheter s√©par√©ment avec les liens ci-dessous.

.. .. list-table::
..     :widths: 30 20
..     :header-rows: 1

..     *   - INTRODUCTION AUX COMPOSANTS
..         - LIEN D'ACHAT

..     *   - :ref:`gpio_extension_board`
..         - |link_gpio_board_buy|
..     *   - :ref:`breadboard`
..         - |link_breadboard_buy|
..     *   - :ref:`wires`
..         - |link_wires_buy|
..     *   - :ref:`resistor`
..         - |link_resistor_buy|
..     *   - :ref:`4_digit`
..         - \-
..     *   - :ref:`74hc595`
..         - |link_74hc595_buy|
..     *   - :ref:`pir`
..         - \-


Sch√©ma de c√¢blage
---------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.7_counting_device_schematic.png
   :align: center

Proc√©dure exp√©rimentale
---------------------------

**√âtape 1** : Construisez le circuit.

.. image:: ../python_pi5/img/4.1.7_counting_device_circuit.png

**√âtape 2** : Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3** : Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.1_CountingDevice.py

Une fois le code ex√©cut√©, lorsque le capteur PIR d√©tecte le passage de quelqu'un, 
le num√©ro sur l'afficheur √† 4 segments s'incr√©mente de 1.

Il y a deux potentiom√®tres sur le module PIR : l'un pour ajuster la sensibilit√© et l'autre pour r√©gler la distance de d√©tection. Pour un fonctionnement optimal, tournez-les tous deux compl√®tement dans le sens antihoraire.

.. image:: ../python_pi5/img/4.1.7_PIR_TTE.png
   :width: 400
   :align: center

.. warning::

    En cas de message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`.
.. note::

    **Code**

.. note::
    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source du code, tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir le r√©sultat.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice, MotionSensor

   # Initialiser le capteur de mouvement PIR sur GPIO 26
   pir = MotionSensor(26)

   # Initialiser les broches du registre √† d√©calage
   SDI = OutputDevice(24)    # Entr√©e de Donn√©es S√©ries
   RCLK = OutputDevice(23)   # Entr√©e de l'Horloge du Registre
   SRCLK = OutputDevice(18)  # Entr√©e de l'Horloge du Registre √† D√©calage

   # Initialiser les broches de l'afficheur √† 7 segments
   placePin = [OutputDevice(pin) for pin in (10, 22, 27, 17)]

   # D√©finir les codes binaires pour chaque chiffre (0-9) sur l'afficheur 7 segments
   number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

   # Compteur pour le nombre affich√©
   compteur = 0

   def clearDisplay():
       # Efface l'affichage en d√©sactivant tous les segments
       for _ in range(8):
           SDI.on()
           SRCLK.on()
           SRCLK.off()
       RCLK.on()
       RCLK.off()

   def hc595_shift(data):
       # Envoie les donn√©es vers le registre √† d√©calage 74HC595
       for i in range(8):
           SDI.value = 0x80 & (data << i)
           SRCLK.on()
           SRCLK.off()
       RCLK.on()
       RCLK.off()

   def pickDigit(digit):
       # Active un chiffre sp√©cifique de l'afficheur √† 7 segments
       for pin in placePin:
           pin.off()
       placePin[digit].on()

   def display():
       # Met √† jour l'affichage avec la valeur actuelle du compteur
       global compteur
       clearDisplay()
       pickDigit(0)
       hc595_shift(number[counter % 10])

       clearDisplay()
       pickDigit(1)
       hc595_shift(number[counter % 100//10])

       clearDisplay()
       pickDigit(2)
       hc595_shift(number[counter % 1000//100])

       clearDisplay()
       pickDigit(3)
       hc595_shift(number[counter % 10000//1000])

   def loop():
       # Boucle principale pour mettre √† jour l'affichage et v√©rifier la d√©tection de mouvement
       global counter
       currentState = 0
       lastState = 0
       while True:
           display()
           currentState = 1 if pir.motion_detected else 0
           if currentState == 1 and lastState == 0:
               counter += 1
           lastState = currentState

   try:
       loop()
   except KeyboardInterrupt:
       # √âteint toutes les broches lorsque le script est interrompu
       SDI.off()
       SRCLK.off()
       RCLK.off()
       pass


**Explication du Code**

#. Cette ligne importe les classes ``OutputDevice`` et ``MotionSensor`` de la biblioth√®que ``gpiozero``. ``OutputDevice`` peut repr√©senter une LED, un moteur, ou tout appareil que vous souhaitez contr√¥ler en tant que sortie. Le ``MotionSensor`` est g√©n√©ralement un capteur PIR (infrarouge passif) utilis√© pour d√©tecter les mouvements.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice, MotionSensor

#. Initialise le capteur de mouvement PIR connect√© √† la broche GPIO 26.

   .. code-block:: python

       # Initialiser le capteur de mouvement PIR sur GPIO 26
       pir = MotionSensor(26)

#. Initialise les broches GPIO connect√©es √† l'Entr√©e de Donn√©es S√©ries (SDI), √† l'Entr√©e de l'Horloge du Registre (RCLK), et √† l'Entr√©e de l'Horloge du Registre √† D√©calage (SRCLK).

   .. code-block:: python

       # Initialiser les broches du registre √† d√©calage
       SDI = OutputDevice(24)    # Entr√©e de Donn√©es S√©ries
       RCLK = OutputDevice(23)   # Entr√©e de l'Horloge du Registre
       SRCLK = OutputDevice(18)  # Entr√©e de l'Horloge du Registre √† D√©calage

#. Initialise les broches de chaque chiffre de l'afficheur 7 segments et d√©finit les codes binaires correspondants aux chiffres 0 √† 9.

   .. code-block:: python

       # Initialiser les broches de l'afficheur √† 7 segments
       placePin = [OutputDevice(pin) for pin in (10, 22, 27, 17)]

       # D√©finir les codes binaires pour chaque chiffre (0-9)
       number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

#. Efface l'affichage 7 segments en d√©sactivant tous les segments avant d'afficher le prochain chiffre.

   .. code-block:: python

       def clearDisplay():
           # Efface l'affichage en d√©sactivant tous les segments
           for _ in range(8):
               SDI.on()
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

#. Envoie un octet de donn√©es au registre √† d√©calage 74HC595 pour contr√¥ler les segments de l'afficheur.

   .. code-block:: python

       def hc595_shift(data):
           # Envoie les donn√©es vers le registre √† d√©calage 74HC595
           for i in range(8):
               SDI.value = 0x80 & (data << i)
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

#. S√©lectionne le chiffre √† activer sur l'afficheur 7 segments. Chaque chiffre est contr√¥l√© par une broche GPIO distincte.

   .. code-block:: python

       def pickDigit(digit):
           # Active un chiffre sp√©cifique de l'afficheur 7 segments
           for pin in placePin:
               pin.off()
           placePin[digit].on()

#. Initialise l'affichage en commen√ßant par le chiffre des unit√©s, puis active successivement les chiffres des dizaines, des centaines et des milliers. Cette activation rapide des diff√©rents chiffres donne l'illusion d'un affichage continu sur quatre digits.

   .. code-block:: python

       def display():
           # Met √† jour l'afficheur avec la valeur actuelle du compteur
           global counter
           clearDisplay()
           pickDigit(0)
           hc595_shift(number[counter % 10])

           clearDisplay()
           pickDigit(1)
           hc595_shift(number[counter % 100//10])

           clearDisplay()
           pickDigit(2)
           hc595_shift(number[counter % 1000//100])

           clearDisplay()
           pickDigit(3)
           hc595_shift(number[counter % 10000//1000])

#. D√©finit la boucle principale o√π l'affichage est continuellement mis √† jour et l'√©tat du capteur PIR est v√©rifi√©. Si un mouvement est d√©tect√©, le compteur est incr√©ment√©.

   .. code-block:: python

       def loop():
           # Boucle principale pour mettre √† jour l'affichage et v√©rifier la d√©tection de mouvement
           global counter
           currentState = 0
           lastState = 0
           while True:
               display()
               currentState = 1 if pir.motion_detected else 0
               if currentState == 1 and lastState == 0:
                   counter += 1
               lastState = currentState

#. Ex√©cute la boucle principale et assure une interruption du script proprement avec la commande clavier (Ctrl+C), en √©teignant toutes les broches avant de quitter.

   .. code-block:: python

       try:
           loop()
       except KeyboardInterrupt:
           # √âteint toutes les broches lorsque le script est interrompu
           SDI.off()
           SRCLK.off()
           RCLK.off()
           pass



