.. note::

    Ciao, benvenuto nella Community SunFounder per appassionati di Raspberry Pi, Arduino e ESP32 su Facebook! Approfondisci l'uso di Raspberry Pi, Arduino e ESP32 insieme ad altri entusiasti.

    **PerchÃ© Unirsi?**

    - **Supporto Esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e Condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni Festive e Omaggi**: Partecipa a promozioni e omaggi durante le festivitÃ .

    ðŸ‘‰ Pronto per esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

3.1.14 GIOCO â€“ Not Not
=======================

Introduzione
--------------------

In questa lezione realizzeremo un dispositivo per un gioco interessante, che chiamiamo "Not Not".

Durante il gioco, la matrice di punti genererÃ  casualmente una freccia. Il tuo obiettivo Ã¨ premere il pulsante nella direzione opposta alla freccia entro un tempo limitato. Se il tempo scade, o se premi il pulsante nella stessa direzione della freccia, perdi la partita.

Questo gioco Ã¨ un ottimo esercizio per allenare il pensiero inverso. Sei pronto a provare?

Componenti
---------------

.. image:: img/list_GAME_Not_Not.png
    :align: center

Schema Circuitale
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one14.png
   :align: center

Procedura Sperimentale
-----------------------------

**Step 1:** Costruisci il circuito.

.. image:: img/image280.png
    :width: 800

**Step 2:** Vai nella cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.14/

**Step 3**: Compila.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

**Step 4**: Esegui.

.. raw:: html

   <run></run>

.. code-block::

     sudo ./a.out

All'avvio del programma, una freccia a sinistra o a destra apparirÃ  
casualmente sulla matrice di punti. Devi premere il pulsante nella 
direzione opposta alla freccia entro il tempo stabilito. Se ci riesci, 
apparirÃ  un \"**âˆš**\" sulla matrice di punti. Se invece il tempo scade 
o premi il pulsante nella stessa direzione della freccia, perdi e sulla 
matrice di punti verrÃ  visualizzato \"x\". Puoi aggiungere due nuovi 
pulsanti o sostituirli con i tasti del Joystick per le direzioni su, 
giÃ¹, sinistra e destra â€“ aumentando cosÃ¬ la difficoltÃ  del gioco.

.. note::

    Se il programma non funziona dopo l'avvio o compare un messaggio di errore come \"wiringPi.h: File o directory inesistente\", consulta :ref:`Il codice C non funziona?`.


**Spiegazione del Codice**

Basandosi su **1.1.6 Matrice LED**, questa lezione aggiunge **2** 
pulsanti per creare un dispositivo di gioco divertente. Se non hai 
familiaritÃ  con la matrice a punti, consulta :ref:`1.1.6 Matrice di LED`.

Lâ€™intero processo del programma Ã¨ il seguente:

1. Seleziona casualmente la direzione di una freccia e genera il **timer 1**.

2. Visualizza lâ€™immagine della freccia sulla matrice di punti.

3. Verifica l'input del pulsante. Se viene premuto un pulsante o **timer 1** 
   segnala lo scadere del tempo, inizia la valutazione.

4. Visualizza lâ€™immagine in base al risultato della valutazione; nel frattempo, 
   genera **timer 2**.

5. Ripeti **passo 1** quando **timer 2** segnala lo scadere del tempo.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
    Â Â Â Â {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
    Â Â Â Â //Â {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
    Â Â Â Â //Â {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},Â Â Â Â 
    Â Â Â Â {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
    Â Â Â Â {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
    Â Â Â Â {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

La struttura **GLYPH** funziona come un dizionario: lâ€™attributo **word** 
corrisponde alla **chiave** del dizionario, mentre lâ€™attributo **code** 
corrisponde al **valore**.

Qui, **code** viene utilizzato per memorizzare un array per la matrice LED 
al fine di visualizzare immagini (un array a 8 bit x 8 bit).

Lâ€™array **arrow** puÃ² essere utilizzato per visualizzare le frecce in direzioni 
verso lâ€™alto, il basso, sinistra e destra sulla matrice LED.

Attualmente, le frecce per **down** e **up** sono commentate; rimuovi i 
commenti se necessario.

L'array **check** viene utilizzato per visualizzare le seguenti immagini: 
\"**Ã—**\" e \"**âˆš**\".

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }Â Â Â Â 
    }

La funzione **lookup()** cerca una chiave **key** nella struttura 
**GLYPH \*glyph** e restituisce lâ€™array **code** corrispondente.

La funzione **Strcmp()** confronta due stringhe di caratteri 
**glyph[i].word** e **key**; se sono identiche, restituisce **glyph[i].code**.

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
    Â Â Â Â Â Â Â Â hc595_in(glyphCode[i]);
    Â Â Â Â Â Â Â Â hc595_in(0x80>>i);
    Â Â Â Â Â Â Â Â hc595_out();
    Â Â Â Â }
    }

Visualizza il pattern specificato sulla matrice di punti.

.. code-block:: c

    voidÂ createGlyph(){
    Â Â Â Â srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â waypoint=arrow[i].word;
    Â Â Â Â stage="PLAY";
    Â Â Â Â alarm(2);
    }

La funzione **createGlyph()** viene utilizzata per selezionare casualmente 
una direzione (l'attributo "word" di un elemento nell'array **arrow[]:** 
\"**left**\", \"**right**\"...). Imposta lo stato su \"PLAY\" e avvia una 
funzione di allarme di 2 secondi.

**srand(time(NULL))ï¼š** Inizializza i semi casuali derivanti dall'orologio di sistema.

**(sizeof(arrow)/sizeof(arrow[0]))ï¼š** Ottiene la lunghezza dell'array, il risultato Ã¨ 2.

**rand()%2:** Calcola il resto, che sarÃ  **0** o **1**, ottenuto dividendo un numero casuale generato per 2.

**waypoint=arrow[i].word:** Il risultato dovrebbe essere \"right\" o \"left\".


.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
    Â Â Â Â alarm(0)==0;
    Â Â Â Â if(inputKey==waypoint||inputKey=="empty")
    Â Â Â Â {
    Â Â Â Â Â Â Â Â waypoint="wrong";
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â waypoint="right";
    Â Â Â Â }
    Â Â Â Â stage="CHECK";
    Â Â Â Â alarm(1);
    }

La funzione checkPoint() viene utilizzata per verificare l'input del pulsante; 
se il pulsante non viene premuto o viene premuto nella stessa direzione della 
freccia, il risultato del waypoint sarÃ  "sbagliato" e apparirÃ  una \"**x**\" 
sulla matrice a punti. Al contrario, se il waypoint Ã¨ corretto, la matrice 
mostrerÃ  il simbolo \"**âˆš**\". In questo caso, lo **stato** Ã¨ impostato su 
**CHECK**, e puÃ² essere impostata una funzione di allarme di 1 secondo.

La funzione alarm(), chiamata anche \"allarme\", consente di impostare un 
timer che invia segnali **SIGALRM** al processo una volta scaduto il tempo 
definito.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
    Â Â Â Â {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
    Â Â Â Â {checkPoint("left");}
    }

getKey() legge gli stati dei due pulsanti; se Ã¨ premuto il pulsante destro, 
il parametro per checkPoint() Ã¨ "destra"; se Ã¨ premuto quello sinistro, il 
parametro Ã¨ "sinistra".

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
    Â Â Â Â Â Â Â Â checkPoint("empty");
    Â Â Â Â }
    Â Â Â Â elseÂ if(stage=="CHECK"){
    Â Â Â Â Â Â Â Â createGlyph();
    Â Â Â Â }
    }

Quando il **timer()** scade, sotto lo stato "GIOCO", viene chiamato 
checkPoint() per la verifica. Se il programma Ã¨ impostato su "VERIFICA", 
chiama **createGlyph()** per una nuova freccia.

.. code-block:: c

    voidÂ main(){
    Â Â Â Â setup();
    Â Â Â Â signal(SIGALRM,timer);
    Â Â Â Â createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â Â Â Â Â getKey();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    }

**signal(SIGALRM, timer)**: Chiama **timer()** quando riceve un segnale 
**SIGALRM** generato dal timer **alarm()**.

All'avvio del programma, **createGlyph()** viene chiamato una volta, quindi 
inizia il loop.

Nel loop: in modalitÃ  **GIOCO**, la matrice di punti mostra le frecce e 
controlla lo stato dei pulsanti; in modalitÃ  **VERIFICA**, mostra "x" o "âˆš".

