.. note::

    Bonjour et bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† des tirages au sort et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.3.2 Servo
===============

Introduction
----------------

Dans cette le√ßon, nous allons apprendre √† faire tourner un servomoteur.


Composants
--------------
.. image:: img/list_1.3.2.png


Principe
----------

**Servomoteur**

Un servomoteur est g√©n√©ralement compos√© des √©l√©ments suivants : bo√Ætier, arbre, 
syst√®me d'engrenage, potentiom√®tre, moteur √† courant continu, et carte embarqu√©e.

.. image:: img/image121.png


Voici comment cela fonctionne : le microcontr√¥leur envoie des signaux PWM au servomoteur, 
puis la carte embarqu√©e dans le servo re√ßoit ces signaux via la broche de signal et 
contr√¥le le moteur interne pour tourner. En cons√©quence, le moteur actionne le syst√®me 
d'engrenage qui entra√Æne ensuite l'arbre apr√®s r√©duction. L'arbre et le potentiom√®tre 
du servo sont reli√©s ensemble. Lorsque l'arbre tourne, il entra√Æne le potentiom√®tre, 
qui envoie alors un signal de tension √† la carte embarqu√©e. Ensuite, la carte d√©termine 
la direction et la vitesse de rotation en fonction de la position actuelle, ce qui permet 
de s'arr√™ter pr√©cis√©ment √† la position d√©finie et de s'y maintenir.

.. image:: img/image122.png


L'angle est d√©termin√© par la dur√©e de l'impulsion appliqu√©e au fil de contr√¥le. 
Cela s'appelle la modulation de largeur d'impulsion (PWM). Le servo s'attend √† 
recevoir une impulsion toutes les 20 ms. La longueur de l'impulsion d√©termine 
l'angle de rotation du moteur. Par exemple, une impulsion de 1,5 ms positionnera 
le moteur √† 90 degr√©s (position neutre).

Lorsque l'impulsion envoy√©e est inf√©rieure √† 1,5 ms, le servo tourne √† une position 
situ√©e √† quelques degr√©s dans le sens antihoraire par rapport au point neutre. 
Si l'impulsion est sup√©rieure √† 1,5 ms, le ph√©nom√®ne inverse se produit. La largeur 
minimale et maximale de l'impulsion qui commande la rotation du servo d√©pendent de 
chaque servo. En g√©n√©ral, l'impulsion minimale est d'environ 0,5 ms et l'impulsion 
maximale est de 2,5 ms.

.. image:: img/image123.jpeg


Sch√©ma de c√¢blage
--------------------

.. image:: img/image337.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: img/image125.png
    :width: 800



Pour les utilisateurs de langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.2

**√âtape 3 :** Compiler le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.2_Servo.c -lwiringPi

**√âtape 4 :** Ex√©cuter le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du programme, le servomoteur tournera de 0 degr√©s √† 
180 degr√©s, puis de 180 degr√©s √† 0 degr√©s, en boucle.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si vous recevez un message d'erreur : \"wiringPi.h : Fichier ou r√©pertoire introuvable\", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softPwm.h>
    #include <stdio.h>

    #define ServoPin    1       // d√©finir le servo sur GPIO1
    long Map(long value,long fromLow,long fromHigh,long toLow,long toHigh){
        return (toHigh-toLow)*(value-fromLow) / (fromHigh-fromLow) + toLow;
    }
    void setAngle(int pin, int angle){    // Cr√©er une fonction pour contr√¥ler l'angle du servo.
        if(angle < 0)
            angle = 0;
        if(angle > 180)
            angle = 180;
        softPwmWrite(pin,Map(angle, 0, 180, 5, 25));   
    } 

    int main(void)
    {
        int i;
        if(wiringPiSetup() == -1){ // lorsque l'initialisation de wiring √©choue, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1; 
        }
        softPwmCreate(ServoPin, 0, 200);       // initialiser la broche PMW du servo
        while(1){
            for(i=0;i<181;i++){     // Faire tourner le servo de 0 √† 180.            	setAngle(ServoPin,i);
                delay(2);
            }
            delay(1000);
            for(i=181;i>-1;i--){        // Faire tourner le servo de 180 √† 0.            	setAngle(ServoPin,i);
                delay(2);
            }
            delay(1000);
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    long Map(long value,long fromLow,long fromHigh,long toLow,long toHigh){
        return (toHigh-toLow)*(value-fromLow) / (fromHigh-fromLow) + toLow;
    }

Cr√©ation d'une fonction Map() pour mapper une valeur dans le code suivant.

.. code-block:: c

    void setAngle(int pin, int angle){    // Cr√©er une fonction pour contr√¥ler l'angle du servo.
        if(angle < 0)
            angle = 0;
        if(angle > 180)
            angle = 180;
        softPwmWrite(pin,Map(angle, 0, 180, 5, 25));   
    } 

Cr√©ation de la fonction setAngle() pour √©crire un angle sur le servo.

.. code-block:: c

    softPwmWrite(pin,Map(angle,0,180,5,25));  

Cette fonction permet de modifier le cycle de service du PWM.

Pour faire tourner le servo de 0 √† 180¬∞, la largeur d'impulsion doit varier 
dans une plage de 0,5 ms √† 2,5 ms avec une p√©riode de 20 ms ; dans la fonction 
softPwmCreate(), nous avons d√©fini que la p√©riode est de 200x100us=20ms, donc 
nous devons mapper 0~180 √† 5x100us ~ 25x100us.

Le prototype de cette fonction est pr√©sent√© ci-dessous.

.. code-block:: 

    int softPwmCreateÔºàint pinÔºåint initialValueÔºåint pwmRangeÔºâ;


**Param√®tre pin :** N'importe quelle broche GPIO du Raspberry Pi peut √™tre d√©finie comme broche PWM.

**Param√®tre initialValue :** La largeur d'impulsion initiale est initialValue multipli√© par 100us.

**Param√®tre pwmRange :** La p√©riode du PWM est pwmRange multipli√© par 100us.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.2_Servo.py

Apr√®s l'ex√©cution du programme, le servomoteur tournera de 0 √† 180 degr√©s, 
puis de 180 √† 0 degr√©s, en boucle.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    SERVO_MIN_PULSE = 500
    SERVO_MAX_PULSE = 2500

    ServoPin = 18

    def map(value, inMin, inMax, outMin, outMax):
        return (outMax - outMin) * (value - inMin) / (inMax - inMin) + outMin

    def setup():
        global p
        GPIO.setmode(GPIO.BCM)       # Num√©rotation des GPIO par BCM
        GPIO.setup(ServoPin, GPIO.OUT)   # Configurer le mode de ServoPin en sortie
        GPIO.output(ServoPin, GPIO.LOW)  # Mettre ServoPin √† bas
        p = GPIO.PWM(ServoPin, 50)     # Configurer la fr√©quence √† 50Hz
        p.start(0)                     # Cycle de service = 0
        
    def setAngle(angle):      # Faire tourner le servo √† un angle sp√©cifique (0-180 degr√©s) 
        angle = max(0, min(180, angle))
        pulse_width = map(angle, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE)
        pwm = map(pulse_width, 0, 20000, 0, 100)
        p.ChangeDutyCycle(pwm)  # Mapper l'angle au cycle de service et le sortir
        
    def loop():
        while True:
            for i in range(0, 181, 5):   # Faire tourner le servo de 0 √† 180 degr√©s
                setAngle(i)     # √âcrire l'angle dans le servo
                time.sleep(0.002)
            time.sleep(1)
            for i in range(180, -1, -5): # Faire tourner le servo de 180 √† 0 degr√©s
                setAngle(i)
                time.sleep(0.001)
            time.sleep(1)

    def destroy():
        p.stop()
        GPIO.cleanup()

    if __name__ == '__main__':     # Programme commence ici
        setup()
        try:
            loop()
        except KeyboardInterrupt:  # Lorsque 'Ctrl+C' est press√©, la fonction destroy() sera ex√©cut√©e.
            destroy()
        

**Explication du code**

.. code-block:: python

    p = GPIO.PWM(ServoPin, 50)     # Configurer la fr√©quence √† 50Hz
    p.start(0)                     # Cycle de service = 0

Configurer le ServoPin en tant que broche PWM, puis la fr√©quence √† 50hz, avec une p√©riode de 20ms.

p.start(0) : Lancer la fonction PWM et d√©finir la valeur initiale √† 0.

.. code-block:: python

    def setAngle(angle):      # Faire tourner le servo √† un angle sp√©cifique (0-180 degr√©s)
        angle = max(0, min(180, angle))
        pulse_width = map(angle, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE)
        pwm = map(pulse_width, 0, 20000, 0, 100)
        p.ChangeDutyCycle(pwm)  # Mapper l'angle au cycle de service et le sortir

Cr√©er une fonction setAngle() pour √©crire un angle allant de 0 √† 180 degr√©s dans le servo.

.. code-block:: python

    angle = max(0, min(180, angle))

Ce code limite l'angle dans la plage de 0 √† 180¬∞.

La fonction min() retourne la plus petite des valeurs d'entr√©e.
Si angle > 180, la fonction retourne 180, sinon elle retourne angle.

La m√©thode max() retourne le maximum entre plusieurs param√®tres. 
Si angle < 0, la fonction retourne 0, sinon elle retourne angle.

.. code-block:: python

    pulse_width = map(angle, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE)
    pwm = map(pulse_width, 0, 20000, 0, 100)
    p.ChangeDutyCycle(pwm)

Pour rendre la plage de 0 √† 180¬∞ au servo, la largeur d'impulsion du servo est 
configur√©e entre 0,5ms (500us) et 2,5ms (2500us).

La p√©riode du PWM est de 20ms (20000us), donc le cycle de service du PWM est de 
(500/20000)% √† (2500/20000)%, et la plage de 0 √† 180 est mapp√©e de 2,5 √† 12,5.


Image du ph√©nom√®ne
---------------------

.. image:: img/image126.jpeg
