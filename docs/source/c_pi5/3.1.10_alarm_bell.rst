.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, d'Arduino et d'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et surmontez les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

3.1.10 Alarme Manuelle
=========================

Introduction
--------------

Dans ce projet, nous allons cr√©er un dispositif d'alarme manuel. 
Vous pouvez remplacer l'interrupteur √† bascule par une thermistance 
ou un capteur photosensible pour en faire une alarme de temp√©rature ou de luminosit√©.

Composants
------------

.. image:: img/list_Alarm_Bell.png
    :align: center

Sch√©ma de C√¢blage
-------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
============ ======== ======== ===

.. image:: img/Schematic_three_one10.png
   :align: center

Proc√©dures Exp√©rimentales
----------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/image266.png
   :alt: Alarm Bell_bb
   :width: 800

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.10/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.10_AlarmBell.c -lwiringPi -lpthread

**√âtape 4 :** Ex√©cutez le fichier compil√©.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le programme d√©marre, basculez l'interrupteur vers la droite et le 
buzzer √©mettra un son d'alarme. En m√™me temps, les LED rouge et verte clignoteront 
√† une certaine fr√©quence.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur indiquant ¬´ wiringPi.h : Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez consulter :ref:`C code is not working?`.
**Explication du Code**

.. code-block:: c

    #include¬†<pthread.h>

Dans ce code, nous utilisons la nouvelle biblioth√®que `pthread.h`, qui est un 
ensemble de biblioth√®ques de threads permettant de r√©aliser le multithreading. 
Nous ajoutons le param√®tre **-lpthread** lors de la compilation pour permettre 
le fonctionnement ind√©pendant de la LED et du buzzer.

.. code-block:: c

    void¬†*ledWork(void¬†*arg){¬†¬†¬†¬†¬†¬†¬†
        while(1)    
        {   
            if(flag==0){
                pthread_exit(NULL);
            }
            digitalWrite(ALedPin,HIGH);
            delay(500);
            digitalWrite(ALedPin,LOW);
            digitalWrite(BLedPin,HIGH);
            delay(500);
            digitalWrite(BLedPin,LOW);
        }
    }

La fonction `ledWork()` configure l'√©tat de fonctionnement des deux LEDs : 
elle allume la LED verte pendant 0,5 seconde, puis l'√©teint, et fait de m√™me 
pour la LED rouge.

.. code-block:: c

    void¬†*buzzWork(void¬†*arg){
        while(1)
        {
            if(flag==0){
                pthread_exit(NULL);
            }
            if((note>=800)||(note<=130)){
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pitch¬†=¬†-pitch;
            }
            note=note+pitch;
            softToneWrite(BeepPin,note);
            delay(10);
        }
    }

La fonction `buzzWork()` configure l'√©tat de fonctionnement du buzzer. Ici, 
nous d√©finissons une fr√©quence entre 130 et 800, qui augmente ou diminue avec 
un intervalle de 10 millisecondes.

.. code-block:: c

    void¬†on(){
    ¬†¬†¬†¬†flag¬†=¬†1;
    ¬†¬†¬†¬†if(softToneCreate(BeepPin)¬†==¬†-1){
    ¬†¬†¬†¬†¬†¬†¬†¬†printf("setup¬†softTone¬†failed¬†!");
            return; 
        }    
    ¬†¬†¬†¬†pthread_t¬†tLed;¬†¬†¬†¬†¬†
        pthread_create(&tLed,NULL,ledWork,NULL);    
    ¬†¬†¬†¬†pthread_t¬†tBuzz;¬†¬†
        pthread_create(&tBuzz,NULL,buzzWork,NULL);      
    }

Dans la fonction `on()` :

1) D√©finition de la variable `flag=1` pour indiquer que le thread de contr√¥le est actif.

2) Cr√©ation d'une broche de tonalit√© contr√¥l√©e par logiciel **BeepPin**.
3) Cr√©ation de deux threads distincts pour que la LED et le buzzer puissent fonctionner en m√™me temps.

**pthread_t tLed :** D√©claration d'un thread nomm√© **tLed**.

**pthread_create(&tLed, NULL, ledWork, NULL) :** Cr√©ation du thread avec le prototype suivant :

int pthread_create(pthread_t \*restrict tidp, const pthread_attr_t \*restrict_attr, void*Ôºà*start_rtn)(void*), void \*restrict arg);

**Valeur de retour**

Si la cr√©ation est r√©ussie, retourne \"**0**\" ; sinon, retourne le code d'erreur \"**-1**\".

**Param√®tres**

- Le premier param√®tre est un pointeur vers l'identifiant du thread.
- Le second param√®tre est utilis√© pour d√©finir les attributs du thread.
- Le troisi√®me param√®tre est l'adresse de d√©marrage de la fonction du thread.
- Le dernier param√®tre est celui qui ex√©cute la fonction.

.. code-block:: c

    void¬†off(){
    ¬†¬†¬†¬†flag¬†=¬†0;
        softToneStop(BeepPin);
        digitalWrite(ALedPin,LOW);
        digitalWrite(BLedPin,LOW);
    }

La fonction `off()` d√©finit `flag=0` afin de sortir des threads `ledWork` et `buzzWork`, puis arr√™te le buzzer et les LEDs.

.. code-block:: c

    int¬†main(){¬†¬†¬†¬†¬†¬†¬†
        setup(); 
    ¬†¬†¬†¬†int¬†lastState¬†=¬†0;
        while(1){
    ¬†¬†¬†¬†¬†¬†¬†¬†int¬†currentState¬†=¬†digitalRead(switchPin);
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†((currentState¬†==¬†1)&&(lastState==0)){
                on();
            }
    ¬†¬†¬†¬†¬†¬†¬†¬†else¬†if((currentState¬†==¬†0)&&(lastState==1)){
                off();
            }
            lastState=currentState;
        }
    ¬†¬†¬†¬†return¬†0;
    }

La fonction `main()` contient l'ensemble du processus du programme : elle lit 
d'abord la valeur de l'interrupteur coulissant ; si celui-ci est bascul√© vers 
la droite (la lecture est 1), la fonction `on()` est appel√©e, le buzzer est 
activ√© et les LEDs rouge et verte clignotent. Sinon, le buzzer et les LEDs s'√©teignent.

