.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez au c≈ìur de Raspberry Pi, Arduino et ESP32 avec d‚Äôautres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l‚Äôaide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des promotions sp√©ciales et des concours pour gagner des cadeaux.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.2.2 Buzzer Passif
=====================

Introduction
------------

Dans cette le√ßon, nous allons apprendre √† faire jouer de la musique √† un buzzer passif.

Composants
-------------

.. image:: img/list_1.2.2.png

Sch√©ma de circuit
--------------------

Dans cette exp√©rience, nous utilisons un buzzer passif, un transistor PNP et une 
r√©sistance de 1kŒ© plac√©e entre la base du transistor et le GPIO pour prot√©ger le transistor.

Lorsque le GPIO17 re√ßoit diff√©rentes fr√©quences, le buzzer passif √©met des sons vari√©s ; 
ainsi, le buzzer peut jouer de la musique.

.. image:: img/image333.png


Proc√©dures Exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image106.png
    :width: 800

Pour les utilisateurs de langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.2.2/

**√âtape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**√âtape 4 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le code ex√©cut√©, le buzzer joue un morceau de musique.

.. note::

    Si cela ne fonctionne pas apr√®s ex√©cution, ou si un message d'erreur comme ¬´ wiringPi.h : Aucun fichier ou r√©pertoire de ce type ¬ª s'affiche, veuillez consulter :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");
            delay(100);
            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }
**Explication du code**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294

Ces d√©finitions correspondent aux fr√©quences de chaque note. CL fait r√©f√©rence aux 
notes basses, CM aux notes moyennes, CH aux notes aigu√´s, et 1 √† 7 correspondent aux 
notes Do, R√©, Mi, Fa, Sol, La, Si.

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

Le tableau `song_1[]` contient les fr√©quences musicales d‚Äôune chanson, tandis que 
`beat_1[]` correspond au rythme de chaque note de la chanson (chaque battement 
repr√©sente 0,5 seconde).

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;

Cette fonction cr√©e une tonalit√© contr√¥l√©e par logiciel sur la broche sp√©cifi√©e. 
Vous pouvez utiliser n'importe quelle broche GPIO, et le num√©ro de broche sera 
celui utilis√© dans la fonction `wiringPiSetup()`. La valeur de retour est 0 en 
cas de succ√®s. Sinon, vous devez v√©rifier la variable globale `errno` pour voir 
ce qui a √©chou√©.

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

Utilisez une boucle `for` pour jouer la m√©lodie `song_1`.

Dans la condition de jugement **i < sizeof(song_1)/4**, la division par 4 est utilis√©e 
car le tableau `song_1[]` est un tableau de type `int` et chaque √©l√©ment occupe quatre octets.

Le nombre d‚Äô√©l√©ments dans `song_1` (le nombre de notes) est obtenu en divisant `sizeof(song_1)` par 4.

Pour permettre √† chaque note de jouer pendant `beat * 500` ms, la fonction `delay(beat_1[i] * 500)` est appel√©e.

Le prototype de la fonction `softToneWrite(BuzPin, song_1[i])` est :

.. code-block:: c

    void softToneWrite (int pin, int freq);

Cette fonction met √† jour la fr√©quence de la tonalit√© sur la broche sp√©cifi√©e. 
La tonalit√© continue √† jouer jusqu'√† ce que vous d√©finissiez la fr√©quence √† 0.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 : Changez de r√©pertoire.**

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 : Ex√©cutez.**

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.2.2_PassiveBuzzer.py

Le code s'ex√©cute et le buzzer joue un morceau de musique.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source tel que ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    Buzzer = 11

    CL = [0, 131, 147, 165, 175, 196, 211, 248]		# Fr√©quences des notes basses en C majeur

    CM = [0, 262, 294, 330, 350, 393, 441, 495]		# Fr√©quences des notes moyennes en C majeur

    CH = [0, 525, 589, 661, 700, 786, 882, 990]		# Fr√©quences des notes aigu√´s en C majeur

    song_1 = [	CM[3], CM[5], CM[6], CM[3], CM[2], CM[3], CM[5], CM[6], # Notes de la chanson 1
                CH[1], CM[6], CM[5], CM[1], CM[3], CM[2], CM[2], CM[3], 
                CM[5], CM[2], CM[3], CM[3], CL[6], CL[6], CL[6], CM[1],
                CM[2], CM[3], CM[2], CL[7], CL[6], CM[1], CL[5]	]

    beat_1 = [	1, 1, 3, 1, 1, 3, 1, 1, 			# Dur√©es des notes de la chanson 1, 1 repr√©sente 1/8 de temps                
                1, 1, 1, 1, 1, 1, 3, 1,                 
                1, 3, 1, 1, 1, 1, 1, 1,                 
                1, 2, 1, 1, 1, 1, 1, 1,                 
                1, 1, 3	]

    song_2 = [	CM[1], CM[1], CM[1], CL[5], CM[3], CM[3], CM[3], CM[1], # Notes de la chanson 2
                CM[1], CM[3], CM[5], CM[5], CM[4], CM[3], CM[2], CM[2], 
                CM[3], CM[4], CM[4], CM[3], CM[2], CM[3], CM[1], CM[1], 
                CM[3], CM[2], CL[5], CL[7], CM[2], CM[1]	]

    beat_2 = [	1, 1, 2, 2, 1, 1, 2, 2, 			# Dur√©es des notes de la chanson 2, 1 repr√©sente 1/8 de temps                
    1, 1, 2, 2, 1, 1, 3, 1,                 
    1, 2, 2, 1, 1, 2, 2, 1,                 
    1, 2, 2, 1, 1, 3 ]

    def setup():

        GPIO.setmode(GPIO.BOARD)		# Num√©rotation des GPIO par leur emplacement physique
        GPIO.setup(Buzzer, GPIO.OUT)	# Configurer le mode des broches en sortie
        global Buzz						# Assigner une variable globale pour remplacer GPIO.PWM 
        Buzz = GPIO.PWM(Buzzer, 440)	# 440 est la fr√©quence initiale.
        Buzz.start(50)					# D√©marrer la broche du buzzer avec un cycle de travail de 50%

    def loop():
        while True:
            print ('\n    Playing song 1...')
            for i in range(1, len(song_1)):		# Jouer la chanson 1
                Buzz.ChangeFrequency(song_1[i])	# Changer la fr√©quence en fonction de la note de la chanson
                time.sleep(beat_1[i] * 0.5)		# Temporiser la note pour beat * 0.5s
            time.sleep(1)						# Attendre une seconde avant la prochaine chanson.

            print ('\n\n    Playing song 2...')
            for i in range(1, len(song_2)):     # Jouer la chanson 2
                Buzz.ChangeFrequency(song_2[i]) # Changer la fr√©quence en fonction de la note de la chanson
                time.sleep(beat_2[i] * 0.5)     # Temporiser la note pour beat * 0.5s

    def destory():
        Buzz.stop()                 # Arr√™ter le buzzer
        GPIO.output(Buzzer, 1)      # Mettre la broche du buzzer √† High
        GPIO.cleanup()				# Lib√©rer les ressources

    if __name__ == '__main__':		# Le programme commence ici
        setup()
        try:
            loop()
        except KeyboardInterrupt:  	# Lorsque 'Ctrl+C' est press√©, le programme destory() sera ex√©cut√©.
            destory()

**Explication du code**

.. code-block:: python

    CL = [0, 131, 147, 165, 175, 196, 211, 248]     # Fr√©quence des notes basses en C majeur
    CM = [0, 262, 294, 330, 350, 393, 441, 495]     # Fr√©quence des notes moyennes en C majeur
    CH = [0, 525, 589, 661, 700, 786, 882, 990]     # Fr√©quence des notes aigu√´s en C majeur     

Ce sont les fr√©quences de chaque note. Le premier 0 permet de 
sauter CL[0] de sorte que les num√©ros 1 √† 7 correspondent aux notes CDEFGAB.

.. code-block:: python

    song_1 = [  CM[3], CM[5], CM[6], CM[3], CM[2], CM[3], CM[5], CM[6], 
                CH[1], CM[6], CM[5], CM[1], CM[3], CM[2], CM[2], CM[3],
                CM[5], CM[2], CM[3], CM[3], CL[6], CL[6], CL[6], CM[1],
                CM[2], CM[3], CM[2], CL[7], CL[6], CM[1], CL[5] ]

Ces tableaux contiennent les notes d'une chanson.

.. code-block:: python

    beat_1 = [  1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,                
                1, 3, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,                
                1, 1, 3 ]

Chaque battement repr√©sente une dur√©e de ‚Öõ de temps, soit 0,5 seconde.

.. code-block:: python

    Buzz = GPIO.PWM(Buzzer, 440)
    Buzz.start(50)  

D√©finir la broche Buzzer comme broche PWM, puis fixer sa fr√©quence √† 440. 
Buzz.start(50) est utilis√© pour d√©marrer le PWM avec un cycle de travail de 50%.

.. code-block:: python

    for i in range(1, len(song_1)): 
                Buzz.ChangeFrequency(song_1[i]) 
                time.sleep(beat_1[i] * 0.5)  

Ex√©cuter une boucle for, puis le buzzer jouera les notes dans le tableau song_1[]
avec les dur√©es dans le tableau beat_1[].

Maintenant, vous pouvez entendre le buzzer passif jouer de la musique.

Image du ph√©nom√®ne
-----------------------

.. image:: img/image107.jpeg