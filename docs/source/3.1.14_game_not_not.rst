.. note::

    Bonjour, bienvenue dans la communautÃ© des passionnÃ©s de SunFounder Raspberry Pi & Arduino & ESP32 sur Facebook ! Plongez plus profondÃ©ment dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : Obtenez un accÃ¨s anticipÃ© aux annonces de nouveaux produits et aux avant-premiÃ¨res.
    - **RÃ©ductions spÃ©ciales** : Profitez de remises exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez Ã  des tirages au sort et Ã  des promotions spÃ©ciales pendant les fÃªtes.

    ğŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.14 JEU - Not Not
=======================

Introduction
--------------------

Dans cette leÃ§on, nous allons fabriquer un dispositif de jeu intÃ©ressant que nous appelons "Not Not".

Pendant le jeu, la matrice Ã  points rafraÃ®chira une flÃ¨che alÃ©atoire. Votre tÃ¢che est d'appuyer sur le bouton dans la direction opposÃ©e Ã  la flÃ¨che dans un dÃ©lai imparti. Si le temps est Ã©coulÃ© ou si vous appuyez sur le bouton dans la mÃªme direction que la flÃ¨che, vous perdez.

Ce jeu vous permet de pratiquer votre pensÃ©e inversÃ©e. Alors, Ãªtes-vous prÃªt Ã  essayer ?

Composants
---------------

.. image:: img/list_GAME_Not_Not.png
    :align: center

SchÃ©ma de cÃ¢blage
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one14.png
   :align: center

ProcÃ©dures expÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: img/image280.png
    :width: 800


**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.14/

**Ã‰tape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

**Ã‰tape 4 :** ExÃ©cutez le fichier.

.. raw:: html

   <run></run>

.. code-block::

     sudo ./a.out

AprÃ¨s le dÃ©marrage du programme, une flÃ¨che gauche ou droite s'affiche 
alÃ©atoirement sur la matrice de points. Vous devez appuyer sur le bouton 
dans la direction opposÃ©e Ã  la flÃ¨che dans un temps imparti. Ensuite, un 
\"**âˆš**\" apparaÃ®tra sur la matrice de points. Si le temps est Ã©coulÃ© ou 
si vous appuyez sur le bouton dans la mÃªme direction que la flÃ¨che, vous 
perdez et la matrice affiche \"x\". Vous pouvez Ã©galement ajouter 2 nouveaux 
boutons ou les remplacer par des touches de joystick pour avoir 4 directions 
(haut, bas, gauche, droite) et augmenter la difficultÃ© du jeu.

.. note::

    Si le programme ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur apparaÃ®t : \"wiringPi.h: Aucun fichier ou rÃ©pertoire de ce type", veuillez consulter :ref:`C code is not working?`.

**Explication du code**

BasÃ© sur **1.1.6 Matrice LED**, cette leÃ§on ajoute **2** boutons pour crÃ©er un 
dispositif de jeu amusant. Donc, si vous n'Ãªtes pas trÃ¨s familier avec la matrice 
Ã  points, veuillez consulter:ref:`1.1.6 LED Dot Matrix`.

Le processus du programme complet est le suivant :

1. SÃ©lectionnez alÃ©atoirement une direction de flÃ¨che et gÃ©nÃ©rez **timer 1**.

2. Affichez l'image de la flÃ¨che sur la matrice de points.

3. VÃ©rifiez l'entrÃ©e du bouton. Si le bouton est pressÃ© ou si **timer 1** signale la fin du dÃ©lai, commencez la vÃ©rification.

4. Affichez l'image selon le rÃ©sultat de la vÃ©rification ; en parallÃ¨le, gÃ©nÃ©rez **timer 2**.
5. Reprenez **Ã©tape 1** lorsque **timer 2** indique la fin du dÃ©lai.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
        {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
        // {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
        // {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},     
        {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
        {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
        {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

La structure GLYPH fonctionne comme un dictionnaire : l'attribut **word** 
correspond Ã  la **clÃ©** du dictionnaire ; l'attribut **code** correspond Ã  la **valeur**.

Ici, le code est utilisÃ© pour stocker un tableau permettant d'afficher des 
images sur la matrice Ã  points (un tableau de 8x8 bits).

Le tableau **arrow** peut Ãªtre utilisÃ© pour afficher les motifs de flÃ¨ches 
dans les directions haut, bas, gauche et droite sur la matrice LED.

Maintenant, **down** et **up** sont commentÃ©s, vous pouvez les dÃ©commenter si 
nÃ©cessaire.

Le tableau **check** est utilisÃ© pour afficher ces deux images : \"**Ã—**\" et \"**âˆš**\".

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
        {
            if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
            }
        }     
    }

La fonction **lookup()** fonctionne comme une "consultation du dictionnaire". 
Elle dÃ©finit une **clÃ©**, recherche les mots correspondants dans la structure 
**GLYPH \*glyph** et renvoie l'information correspondante â€” le **code** du mot concernÃ©.

La fonction **Strcmp()** est utilisÃ©e pour comparer deux chaÃ®nes de caractÃ¨res 
**glyph[i].word** et **key** ; si elles sont identiques, renvoie **glyph[i].code** 
(comme illustrÃ©).

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
            hc595_in(glyphCode[i]);
            hc595_in(0x80>>i);
            hc595_out();
        }
    }

Affiche le motif spÃ©cifiÃ© sur la matrice Ã  points.

.. code-block:: c

    voidÂ createGlyph(){
        srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
        waypoint=arrow[i].word;
        stage="PLAY";
        alarm(2);
    }

La fonction **createGlyph()** sÃ©lectionne alÃ©atoirement une direction 
(l'attribut word d'un Ã©lÃ©ment du tableau **arrow[]:** \"**left**\", \"**right**\"... ). 
DÃ©finit le stage sur \"PLAY\" et dÃ©marre une alarme de 2 secondes.

**srand(time(NULL)) :** Initialise des graines alÃ©atoires Ã  partir de l'horloge du systÃ¨me.

**(sizeof(arrow)/sizeof(arrow[0]))ï¼š** Calcule la longueur du tableau, qui est 2.

**rand()%2 :** Le reste est **0** ou **1,** obtenu en divisant un nombre alÃ©atoire 
gÃ©nÃ©rÃ© par 2.

**waypoint=arrow[i].word :** Le rÃ©sultat doit Ãªtre \"right\" ou \"left\".

.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
        alarm(0)==0;
        if(inputKey==waypoint||inputKey=="empty")
        {
            waypoint="wrong";
        }
        else{
            waypoint="right";
        }
        stage="CHECK";
        alarm(1);
    }

**checkPoint()** vÃ©rifie l'entrÃ©e du bouton ; si le bouton n'est pas pressÃ© ou 
si le bouton appuyÃ© est dans la mÃªme direction que la flÃ¨che, le rÃ©sultat de 
**waypoint** est \"wrong\" et un \"**x**\" apparaÃ®t sur la matrice de points. 
Sinon, **waypoint** est \"right\" et la matrice affiche \"**âˆš**\". Ici, le 
**stage** est **CHECK**, et une alarme de 1 seconde peut Ãªtre dÃ©finie.

**alarm()** est aussi appelÃ© "rÃ©veil", dans lequel un minuteur peut Ãªtre dÃ©fini, 
envoyant des signaux **SIGALRM** lorsque le temps dÃ©fini est Ã©coulÃ©.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
        {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
        {checkPoint("left");}
    }

**getKey()** lit les Ã©tats de ces deux boutons ; si le bouton droit est pressÃ©, le 
paramÃ¨tre de **checkPoint()** est **right** et si le bouton gauche est pressÃ©, le 
paramÃ¨tre est **left**.

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
            checkPoint("empty");
        }
    Â Â Â Â elseÂ if(stage=="CHECK"){
            createGlyph();
        }
    }

PrÃ©cÃ©demment, **timer()** Ã©tait appelÃ© lorsque **alarm()** dÃ©clenchait la fin du 
temps imparti. En mode \"PLAY\", **checkPoint()** est appelÃ© pour juger le rÃ©sultat. 
Si le programme est en mode \"CHECK\", la fonction **createGlyph()** doit Ãªtre appelÃ©e 
pour sÃ©lectionner de nouveaux motifs.

.. code-block:: c

    voidÂ main(){
        setup();
        signal(SIGALRM,timer);
        createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
        while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
            {
                code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
                display(code);
                getKey();
            }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
            {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
                display(code);
            }
        }
    }

Le fonctionnement de **signal(SIGALRM,timer) :** appel de la fonction **timer()** 
lorsqu'un signal **SIGALRM** (gÃ©nÃ©rÃ© par la fonction rÃ©veil **alarm()**) est reÃ§u.

Lorsque le programme commence, appelez d'abord **createGlyph()**, puis dÃ©marrez 
la boucle.

Dans la boucle : en mode PLAY, la matrice de points affiche les motifs de flÃ¨ches 
et vÃ©rifie l'Ã©tat des boutons ; si en mode CHECK, ce qui est affichÃ© est \"**x**\" 
ou \"**âˆš**\".

**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2** : AccÃ©dez au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**Ã‰tape 3** : ExÃ©cutez le code.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.14_GAME_NotNot.py

AprÃ¨s avoir lancÃ© le programme, une flÃ¨che pointant vers la droite ou la 
gauche apparaÃ®tra sur la matrice de points. Votre tÃ¢che consiste Ã  appuyer 
sur le bouton dans la direction opposÃ©e Ã  la flÃ¨che dans un dÃ©lai imparti. 
Ensuite, un \"**âˆš**\" s'affichera sur la matrice de points. Si le temps est 
Ã©coulÃ© ou si vous appuyez sur le bouton dans la mÃªme direction que la flÃ¨che, 
vous perdez et la matrice affichera un \"x\". Vous pouvez Ã©galement ajouter 
2 nouveaux boutons ou les remplacer par des touches de joystick pour avoir 4 
directions (haut, bas, gauche et droite) et augmenter la difficultÃ© du jeu.

**Code**

.. note::

    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant cela, vous devez accÃ©der au chemin source du code comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading
    import random

    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    timerPlay = 0
    timerCheck = 0

    AButtonPin = 20
    BButtonPin = 26

    waypoint = "NULL"
    stage = "NULL"

    arrow={
        #"down" :[0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF],
        #"up":[0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF],
        "right" : [0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF],    
        "left":[0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF]
    }
    check={
        "wrong":[0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF],
        "right":[0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF]
    }

    def setup():
        GPIO.setmode(GPIO.BCM)    # NumÃ©rotation des GPIOs par leur emplacement BCM
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        GPIO.output(SDI, GPIO.LOW)
        GPIO.output(RCLK, GPIO.LOW)
        GPIO.output(SRCLK, GPIO.LOW)
        GPIO.setup(AButtonPin,GPIO.IN)
        GPIO.setup(BButtonPin,GPIO.IN)    
    
    # TransfÃ©rer les donnÃ©es vers le 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8): 
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)

    def display(glyphCode):
        for i in range(0, 8):
            hc595_shift(glyphCode[i])
            hc595_shift(0x80>>i)
            GPIO.output(RCLK, GPIO.HIGH)
            GPIO.output(RCLK, GPIO.LOW)

    def creatGlyph():
        global waypoint
        global stage
        global timerPlay    
        waypoint=random.choice(list(arrow.keys()))
        stage = "PLAY"
        timerPlay = threading.Timer(2.0, timeOut)  
        timerPlay.start()  

    def checkPoint(inputKey):
        global waypoint
        global stage
        global timerCheck    
        if inputKey == "empty" or inputKey == waypoint:
            waypoint = "wrong"
        else:
            waypoint = "right"
        timerPlay.cancel()
        stage = "CHECK"
        timerCheck = threading.Timer(1.0, creatGlyph)
        timerCheck.start()  

    def timeOut():  
        checkPoint("empty")

    def getKey():
        if GPIO.input(AButtonPin)==1 and GPIO.input(BButtonPin)==0:
            checkPoint("right")
        elif GPIO.input(AButtonPin)==0 and GPIO.input(BButtonPin)==1:
            checkPoint("left")
        
    def main():
        creatGlyph()
        while True:
            if stage == "PLAY":
                display(arrow[waypoint])
                getKey()
            elif stage == "CHECK":
                display(check[waypoint])

    def destroy():
        global timer1
        GPIO.cleanup()
        timerPlay.cancel()  # annuler le minuteur
        timerCheck.cancel()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

BasÃ© sur **1.1.6 Matrice de LED**, cette leÃ§on ajoute **2** boutons pour crÃ©er un 
dispositif de jeu amusant. Donc, si vous n'Ãªtes pas trÃ¨s familier avec la matrice 
de points, veuillez vous rÃ©fÃ©rer Ã  :ref:`1.1.6 LED Dot Matrix`.

Le dÃ©roulement complet du programme est le suivant :

.. image:: img/notnot3.png
    :width: 800

1. SÃ©lectionner alÃ©atoirement une direction de flÃ¨che et gÃ©nÃ©rer le **timer 1**.

2. Afficher l'image de la flÃ¨che correspondante sur la matrice de points.

3. Ã‰valuer l'entrÃ©e du bouton. Si un bouton est pressÃ© ou si le **timer 1** indique la fin du temps, le jugement commence.

4. Afficher l'image basÃ©e sur le rÃ©sultat du jugement ; simultanÃ©ment, gÃ©nÃ©rer le **timer 2**.

5. Reprendre Ã  l'**Ã©tape 1** lorsque le **timer 2** signale la fin du temps.

.. code-block:: python

    defÂ main():
        creatGlyph()
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â "PLAY":
                display(arrow[waypoint])
                getKey()
    Â Â Â Â Â Â Â Â elifÂ stageÂ ==Â "CHECK":
                display(check[waypoint])

Main() contient l'ensemble du processus de fonctionnement.

Lorsque le programme dÃ©marre, creatGlyph() est appelÃ© une fois au dÃ©but, 
puis la boucle dÃ©marre.

Dans la boucle : en mode PLAY, la matrice de points affiche des motifs de 
flÃ¨ches et vÃ©rifie l'Ã©tat des boutons ; en mode CHECK, ce qui est affichÃ© 
est soit \"**x**\" soit \"**âˆš**\".

.. code-block:: python

    arrow={
        #"down" :[0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF],
        #"up":[0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF],
    Â Â Â Â "right"Â :Â [0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF],Â Â Â Â 
        "left":[0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF]
    }
    check={
        "wrong":[0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF],
        "right":[0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF]
    }

Ici, le **dictionnaire** arrow permet d'afficher les motifs de flÃ¨ches dans 
les directions haut, bas, gauche et droite sur la matrice de LED.

Actuellement, les flÃ¨ches haut et bas sont commentÃ©es, et vous pouvez les 
dÃ©commenter si nÃ©cessaire.

Le **dictionnaire** check est utilisÃ© pour afficher les deux images : \"**Ã—**\" et \"**âˆš**\".

.. code-block:: python

    defÂ display(glyphCode):
    Â Â Â Â forÂ iÂ inÂ range(0,Â 8):
            hc595_shift(glyphCode[i])
            hc595_shift(0x80>>i)
    Â Â Â Â Â Â Â Â GPIO.output(RCLK,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(RCLK,Â GPIO.LOW)

Afficher le motif spÃ©cifiÃ© sur la matrice de points.

.. code-block:: python

    defÂ creatGlyph():
    Â Â Â Â globalÂ waypoint
    Â Â Â Â globalÂ stage
    Â Â Â Â globalÂ timerPlayÂ Â Â Â 
        waypoint=random.choice(list(arrow.keys()))
    Â Â Â Â stageÂ =Â "PLAY"
    Â Â Â Â timerPlayÂ =Â threading.Timer(2.0,Â timeOut)Â Â 
        timerPlay.start()

La fonction **createGlyph()** est utilisÃ©e pour sÃ©lectionner alÃ©atoirement 
une direction (l'attribut mot d'un Ã©lÃ©ment dans le tableau **arrow[] :** \"**left**\", \"**right**\"... ). 
DÃ©finir l'Ã©tape en \"PLAY\" et dÃ©marrer une fonction d'alarme de 2 secondes.

**arrow.keys():** SÃ©lectionne les clÃ©s \"right\" et \"left\" dans le tableau arrow.

**list(arrow.keys()):** Combine ces clÃ©s en un tableau.

**random.choice(list(arrow.keys())):** SÃ©lectionne alÃ©atoirement un Ã©lÃ©ment du tableau.

Ainsi, le rÃ©sultat de **waypoint=random.choice(list(arrow.keys()))** devrait Ãªtre \"right\" ou \"left\".

.. code-block:: python

    defÂ checkPoint(inputKey):
    Â Â Â Â globalÂ waypoint
    Â Â Â Â globalÂ stage
    Â Â Â Â globalÂ timerCheckÂ Â Â Â 
    Â Â Â Â ifÂ inputKeyÂ ==Â "empty"Â orÂ inputKeyÂ ==Â waypoint:
    Â Â Â Â Â Â Â Â waypointÂ =Â "wrong"
        else:
    Â Â Â Â Â Â Â Â waypointÂ =Â "right"
        timerPlay.cancel()
    Â Â Â Â stageÂ =Â "CHECK"
    Â Â Â Â timerCheckÂ =Â threading.Timer(1.0,Â creatGlyph)
        timerCheck.start()  

checkPoint() est utilisÃ© pour dÃ©tecter l'Ã©tat actuel de l'entrÃ©e du bouton :

Si aucun bouton n'est pressÃ© ou si le bouton dans la mÃªme direction que la flÃ¨che 
est pressÃ©, la valeur assignÃ©e au **``waypoint``** est **``wrong``** et un ``x`` 
s'affiche sur la matrice de points.

Sinon, le waypoint est correct et \"**âˆš**\" apparaÃ®t.

Maintenant, l'Ã©tape est **CHECK** et un minuteur de 1 seconde **timerCheck** est 
dÃ©marrÃ© pour appeler la fonction creatGlyph() dans une seconde.

.. code-block:: python

    defÂ timeOut():Â Â 
        checkPoint("empty")

Dans la fonction timeout(), le paramÃ¨tre de checkPoint() est dÃ©fini sur \"**empty**\".

.. code-block:: python

    defÂ getKey():
    Â Â Â Â ifÂ GPIO.input(AButtonPin)==1Â andÂ GPIO.input(BButtonPin)==0:
            checkPoint("right")
    Â Â Â Â elifÂ GPIO.input(AButtonPin)==0Â andÂ GPIO.input(BButtonPin)==1:
            checkPoint("left")

getKey() lit l'Ã©tat de ces deux boutons, et si le bouton droit est pressÃ©, le 
paramÃ¨tre de checkPoint() est **right** ; si le bouton gauche est pressÃ©, le 
paramÃ¨tre est **left**.

Image de DÃ©monstration
------------------------------

.. image:: img/image281.jpeg
   :align: center