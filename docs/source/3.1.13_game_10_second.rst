.. note::

    Â¡Hola! Bienvenido a la comunidad de entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Ãšnete para profundizar en Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **Â¿Por quÃ© unirte?**

    - **Soporte de Expertos**: Resuelve problemas post-venta y desafÃ­os tÃ©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances Exclusivos**: ObtÃ©n acceso anticipado a anuncios de nuevos productos y vistas previas.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

    ðŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy.

3.1.13 JUEGOâ€“ 10 Segundos
============================

IntroducciÃ³n
-------------------

Ahora, acompÃ¡Ã±ame a crear un dispositivo de juego para desafiar tu 
concentraciÃ³n. Ata el interruptor de inclinaciÃ³n a un palo para hacer 
una varita mÃ¡gica. Agita la varita, y el display de 4 dÃ­gitos comenzarÃ¡ 
a contar; agÃ­tala de nuevo para detener el conteo. Si logras mantener el 
conteo en pantalla en **10.00**, ganas. Puedes jugar con tus amigos para 
ver quiÃ©n es el maestro del tiempo.

Componentes
-----------------

.. image:: img/list_GAME_10_Second.png
    :align: center

Diagrama EsquemÃ¡tico
-------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one13.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1**: Construye el circuito.

.. image:: img/image277.png
   :alt: 10 second_bb
   :width: 800

**Para Usuarios de Lenguaje C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2**: Ve a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.13/

**Paso 3**: Compila el cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.13_GAME_10Second.c -lwiringPi

**Paso 4**: Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Agita la varita y el display de 4 dÃ­gitos comenzarÃ¡ a contar; agÃ­tala 
nuevamente para detener el conteo. Si logras que el conteo en pantalla 
llegue exactamente a **10.00**, habrÃ¡s ganado. AgÃ­tala una vez mÃ¡s para 
iniciar la siguiente ronda del juego.

.. note::

    Si no funciona despuÃ©s de ejecutarlo, o aparece un mensaje de error: \"wiringPi.h: No such file or directory", consulta :ref:`C code is not working?`.

**ExplicaciÃ³n del CÃ³digo**

.. code-block:: c

    voidÂ stateChange(){
    Â Â Â Â ifÂ (gameStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â counterÂ =Â 0;
            delay(1000);
    Â Â Â Â Â Â Â Â ualarm(10000,10000);Â 
    Â Â Â Â }else{
            alarm(0);
            delay(1000);
        }
    Â Â Â Â gameStateÂ =Â (gameStateÂ +Â 1)%2;
    }

El juego se divide en dos modos:

gameState=0 es el modo "inicio", en el cual el tiempo se mide y se muestra 
en el display de segmentos, y se agita el interruptor de inclinaciÃ³n para 
entrar al modo "mostrar".

GameState=1 es el modo "mostrar", en el cual se detiene el tiempo y se 
muestra en el display. Agitar el interruptor de inclinaciÃ³n de nuevo restablece 
el temporizador y reinicia el juego.

.. code-block:: c

    voidÂ loop(){
    Â Â Â Â intÂ currentStateÂ =0;
    Â Â Â Â intÂ lastState=0;
        while(1){
            display();
    Â Â Â Â Â Â Â Â currentState=digitalRead(sensorPin);
    Â Â Â Â Â Â Â Â if((currentState==0)&&(lastState==1)){
                stateChange();
            }
    Â Â Â Â Â Â Â Â lastState=currentState;
        }
    }

Loop() es la funciÃ³n principal. Primero, muestra el tiempo en el display de 
4 dÃ­gitos y lee el valor del interruptor de inclinaciÃ³n. Si el estado del 
interruptor ha cambiado, se llama a stateChange().

**Para Usuarios de Lenguaje Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2**: Ve a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**Paso 3**: Ejecuta el archivo.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.13_GAME_10Second.py

Agita la varita y el display de 4 dÃ­gitos comenzarÃ¡ a contar; agÃ­tala 
nuevamente para detener el conteo. Si logras que el conteo en pantalla 
llegue exactamente a **10.00**, habrÃ¡s ganado. AgÃ­tala una vez mÃ¡s para 
iniciar la siguiente ronda del juego.

**CÃ³digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el cÃ³digo a continuaciÃ³n. Pero antes, necesitas dirigirte a la ruta del cÃ³digo fuente, como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    sensorPin = 26

    SDI = 24
    RCLK = 23
    SRCLK = 18

    placePin = (10, 22, 27, 17)
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    counter = 0
    timer =0
    gameState =0

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)    

    def hc595_shift(data): 
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

    def display():
        global counter                    
        clearDisplay() 
        pickDigit(0)  
        hc595_shift(number[counter % 10])

        clearDisplay()
        pickDigit(1)
        hc595_shift(number[counter % 100//10])

        clearDisplay()
        pickDigit(2)
        hc595_shift(number[counter % 1000//100]-0x80)

        clearDisplay()
        pickDigit(3)
        hc595_shift(number[counter % 10000//1000])

    def stateChange():
        global gameState
        global counter
        global timer1
        if gameState == 0:
            counter = 0
            time.sleep(1)
            timer() 
        elif gameState ==1:
            timer1.cancel()
            time.sleep(1)
        gameState = (gameState+1)%2

    def loop():
        global counter
        currentState = 0
        lastState = 0
        while True:
            display()
            currentState=GPIO.input(sensorPin)
            if (currentState == 0) and (lastState == 1):
                stateChange()
            lastState=currentState

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for i in placePin:
            GPIO.setup(i, GPIO.OUT)
        GPIO.setup(sensorPin, GPIO.IN)

    def destroy():   # Cuando se presiona \"Ctrl+C\", se ejecuta esta funciÃ³n.
        GPIO.cleanup()
        global timer1
        timer1.cancel()

    if __name__ == '__main__':  # El programa comienza desde aquÃ­
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()

**ExplicaciÃ³n del CÃ³digo**

.. code-block:: python

    defÂ stateChange():
    Â Â Â Â globalÂ gameState
    Â Â Â Â globalÂ counter
    Â Â Â Â globalÂ timer1
    Â Â Â Â ifÂ gameStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â counterÂ =Â 0
            time.sleep(1)
            timer() 
    Â Â Â Â elifÂ gameStateÂ ==1:
            timer1.cancel()
            time.sleep(1)
    Â Â Â Â gameStateÂ =Â (gameState+1)%2

El juego se divide en dos modos:

gameState=0 es el modo "inicio", en el cual el tiempo se mide y se muestra en 
el display de segmentos, y se agita el interruptor de inclinaciÃ³n para entrar 
al modo "mostrar".

GameState=1 es el modo "mostrar", en el cual se detiene el tiempo y se muestra 
en el display. Agitar el interruptor de inclinaciÃ³n de nuevo restablece el 
temporizador y reinicia el juego.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ counter
    Â Â Â Â currentStateÂ =Â 0
    Â Â Â Â lastStateÂ =Â 0
    Â Â Â Â whileÂ True:
            display()
    Â Â Â Â Â Â Â Â currentState=GPIO.input(sensorPin)
    Â Â Â Â Â Â Â Â ifÂ (currentStateÂ ==Â 0)Â andÂ (lastStateÂ ==Â 1):
                stateChange()
    Â Â Â Â Â Â Â Â lastState=currentState

Loop() es la funciÃ³n principal. Primero, muestra el tiempo en el display 
de 4 dÃ­gitos y lee el valor del interruptor de inclinaciÃ³n. Si el estado 
del interruptor ha cambiado, se llama a stateChange().

.. code-block:: python

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

Cuando el intervalo alcanza 0.01s, se llama a la funciÃ³n timer; se aÃ±ade 1 a 
counter, y el temporizador se usa nuevamente para ejecutarse repetidamente 
cada 0.01s.

Imagen del FenÃ³meno
------------------------

.. image:: img/image278.jpeg
   :align: center



