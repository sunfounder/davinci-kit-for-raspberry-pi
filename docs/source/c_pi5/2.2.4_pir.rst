.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez vos d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et Partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et des promotions √† l'occasion des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.4 D√©tecteur PIR
======================

Introduction
---------------

Dans ce projet, nous allons cr√©er un dispositif en utilisant des capteurs 
pyro√©lectriques infrarouges pour d√©tecter le corps humain. Lorsque quelqu'un 
s'approche de la LED, celle-ci s'allume automatiquement. Si personne n'est d√©tect√©, 
la lumi√®re s'√©teint. Ce capteur de mouvement infrarouge est capable de d√©tecter 
le rayonnement infrarouge √©mis par les humains et les animaux.

Composants
-----------

.. image:: img/list_2.2.4_pir.png


Principe
---------

Le capteur PIR d√©tecte le rayonnement infrarouge thermique, ce qui permet de rep√©rer 
la pr√©sence d'organismes √©mettant ce type de rayonnement.

Le capteur PIR est divis√© en deux compartiments connect√©s √† un amplificateur diff√©rentiel. 
Lorsqu'un objet immobile se trouve devant le capteur, les deux compartiments re√ßoivent la 
m√™me quantit√© de rayonnement, et la sortie est nulle. Lorsqu'un objet en mouvement passe 
devant le capteur, un des compartiments re√ßoit plus de rayonnement que l'autre, ce qui fait 
fluctuer la sortie, en passant de haut √† bas ou inversement. Ce changement de tension est 
le r√©sultat de la d√©tection de mouvement.

.. image:: img/image211.png
    :width: 200


Une fois le module de d√©tection c√¢bl√©, il y a une phase d'initialisation d'une minute. 
Pendant cette p√©riode, le module peut √©mettre un signal de sortie de 0 √† 3 fois par 
intermittence. Ensuite, le module passe en mode veille. Veuillez √©viter toute interf√©rence 
de sources lumineuses ou d'autres perturbations pr√®s de la surface du module afin d'√©viter 
tout d√©clenchement erron√©. Il est pr√©f√©rable d'utiliser le module dans un environnement sans 
vent excessif, car le vent peut √©galement influencer le capteur.

.. image:: img/image212.png
    :width: 400


**R√©glage de la distance**

En tournant le potentiom√®tre de r√©glage de la distance dans le sens horaire, 
a port√©e de d√©tection augmente, avec une port√©e maximale d'environ 0 √† 7 m√®tres. 
Si vous le tournez dans le sens antihoraire, la port√©e de d√©tection diminue, avec 
une port√©e minimale d'environ 0 √† 3 m√®tres.

**R√©glage du d√©lai**

En tournant le potentiom√®tre de r√©glage du d√©lai dans le sens horaire, vous augmentez 
le temps de d√©tection, pouvant atteindre un maximum de 300 secondes. √Ä l'inverse, en 
le tournant dans le sens antihoraire, vous r√©duisez le d√©lai jusqu'√† un minimum de 5 secondes.

Deux modes de d√©clenchement : (choisir diff√©rents modes en utilisant le cavalier).

-  **H :** **Mode de d√©clenchement r√©p√©table**, apr√®s avoir d√©tect√© la pr√©sence d'un 
humain, le module maintient une sortie de niveau haut. Pendant la p√©riode de d√©lai, 
si une autre personne entre dans la zone de d√©tection, la sortie reste au niveau haut.

-  **L :** **Mode de d√©clenchement non r√©p√©table**, la sortie passe au niveau haut 
lorsqu'il d√©tecte un humain. Apr√®s le d√©lai, la sortie redevient automatiquement √† 
un niveau bas.



Sch√©ma de c√¢blage
---------------------

.. image:: img/image327.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image214.png
    :width: 800


**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.4/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.4_PIR.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, le capteur PIR d√©tecte les mouvements aux alentours 
et fait briller la LED RVB en jaune s'il d√©tecte quelqu'un passant √† proximit√©. 
Il y a deux potentiom√®tres sur le module PIR : l'un pour ajuster la sensibilit√© 
et l'autre pour ajuster la distance de d√©tection. Pour un fonctionnement optimal 
du module PIR, tournez les deux potentiom√®tres compl√®tement dans le sens antihoraire.

.. image:: img/PIR_TTE.png

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou s'il y a un message d'erreur indiquant : ¬´ wiringPi.h : Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.


**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softPwm.h>
    #include <stdio.h>
    #define uchar unsigned char

    #define pirPin    0     // le PIR est connect√© √† GPIO0
    #define redPin    1
    #define greenPin  2
    #define bluePin   3

    void ledInit(void){
        softPwmCreate(redPin,  0, 100);
        softPwmCreate(greenPin,0, 100);
        softPwmCreate(bluePin, 0, 100);
    }
    void ledColorSet(uchar r_val, uchar g_val, uchar b_val){
        softPwmWrite(redPin,   r_val);
        softPwmWrite(greenPin, g_val);
        softPwmWrite(bluePin,  b_val);
    }
    int main(void)
    {
        int pir_val;
        if(wiringPiSetup() == -1){ // En cas d'√©chec d'initialisation de wiringPi, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        ledInit();
        pinMode(pirPin, INPUT);
        while(1){
        pir_val = digitalRead(pirPin);
            if(pir_val== 1){ // si la lecture de pir est au niveau HAUT
                ledColorSet(0xff,0xff,0x00); 
            }
            else {
            ledColorSet(0x00,0x00,0xff); 
            }
        }
        return 0;
    }

**Explication du Code**

.. code-block:: c

    void ledInit(void);
    void ledColorSet(uchar r_val, uchar g_val, uchar b_val);

Ces lignes de code sont utilis√©es pour d√©finir la couleur de la LED RVB. Veuillez vous r√©f√©rer √†
 :ref:`1.1.2 RGB LED` pour plus de d√©tails.

.. code-block:: c

    int main(void)
    {
        int pir_val;
        //‚Ä¶‚Ä¶ 
        pinMode(pirPin, INPUT);
        while(1){
        pir_val = digitalRead(pirPin);
            if(pir_val== 1){ // si la lecture de pir est au niveau HAUT
                ledColorSet(0xff,0xff,0x00); 
            }
            else {
            ledColorSet(0x00,0x00,0xff); 
            }
        }
        return 0;
    }

Lorsque le capteur PIR d√©tecte le spectre infrarouge humain, la LED RVB √©met une 
lumi√®re jaune ; sinon, elle √©met une lumi√®re bleue.
