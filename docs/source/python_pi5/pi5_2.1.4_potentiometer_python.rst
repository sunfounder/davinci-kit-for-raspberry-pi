.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et surmontez les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des concours et √† des promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

.. _2.1.4_py_pi5:

2.1.4 Potentiom√®tre
=======================

Introduction
----------------

La fonction ADC (convertisseur analogique-num√©rique) est utilis√©e pour convertir 
des signaux analogiques en signaux num√©riques. Dans cette exp√©rience, le module 
ADC0834 est employ√© pour r√©aliser cette fonction. Ici, nous illustrons ce processus 
en utilisant un potentiom√®tre. Le potentiom√®tre modifie la grandeur physique (la tension), 
qui est ensuite convertie par l'ADC.

Composants n√©cessaires
--------------------------

Pour ce projet, nous aurons besoin des composants suivants.

.. image:: ../python_pi5/img/2.1.7_potentiometer_list.png

.. Il est tr√®s pratique d'acheter un kit complet, voici le lien :

.. .. list-table::
..     :widths: 20 20 20
..     :header-rows: 1

..     *   - Nom
..         - COMPOSANTS DANS CE KIT
..         - LIEN
..     *   - Kit Raphael
..         - 337
..         - |link_Raphael_kit|

.. Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. .. list-table::
..     :widths: 30 20
..     :header-rows: 1

..     *   - INTRODUCTION DES COMPOSANTS
..         - LIEN D'ACHAT

..     *   - :ref:`gpio_extension_board`
..         - |link_gpio_board_buy|
..     *   - :ref:`breadboard`
..         - |link_breadboard_buy|
..     *   - :ref:`wires`
..         - |link_wires_buy|
..     *   - :ref:`resistor`
..         - |link_resistor_buy|
..     *   - :ref:`led`
..         - |link_led_buy|
..     *   - :ref:`potentiometer`
..         - |link_potentiometer_buy|
..     *   - :ref:`adc0834`
..         - \-


Sch√©ma de circuit
----------------------

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_1.png

.. image:: ../python_pi5/img/2.1.7_potentiometer_second_2.png

Proc√©dure exp√©rimentale
--------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/2.1.7_Potentiometer_circuit.png

.. note::
    Placez le composant en vous r√©f√©rant √† la position correspondante indiqu√©e 
    sur l'image. Notez que l'encoche sur le composant doit √™tre orient√©e vers 
    la gauche lorsqu'il est en place.

**√âtape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python-pi5

**√âtape 3 :** Ex√©cutez le code.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.4_Potentiometer_zero.py

Une fois le code ex√©cut√©, tournez le bouton du potentiom√®tre, l'intensit√© de 
la LED changera en cons√©quence.

.. warning::

    En cas d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`. 

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, assurez-vous de vous rendre dans le r√©pertoire source, tel que ``raphael-kit/python-pi5``. Apr√®s modification, vous pouvez ex√©cuter le code pour observer le r√©sultat.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   from gpiozero import PWMLED
   import ADC0834
   import time

   # Initialiser une LED PWM sur la broche GPIO 22
   led = PWMLED(22)

   # Configurer le module ADC0834
   ADC0834.setup()

   def MAP(x, in_min, in_max, out_min, out_max):
       """
       Map a value from one range to another.
       :param x: The value to be mapped.
       :param in_min: The lower bound of the value's current range.
       :param in_max: The upper bound of the value's current range.
       :param out_min: The lower bound of the value's target range.
       :param out_max: The upper bound of the value's target range.
       :return: The mapped value.
       """
       return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

   try:
       while True:
           # Lire la valeur actuelle du module ADC0834
           res = ADC0834.getResult()
           print('res = %d' % res)

           # Convertir la valeur de l'ADC en une plage adapt√©e pour r√©gler la luminosit√© de la LED
           R_val = MAP(res, 0, 255, 0, 100)

           # R√©gler la luminosit√© de la LED
           led.value = float(R_val / 100)

           # Attendre 0,2 secondes avant la prochaine lecture
           time.sleep(0.2)

   # Sortie propre lors de l'appui sur 'Ctrl+C'
   except KeyboardInterrupt: 
       led.value = 0  # √âteindre la LED


**Explication du code**

#. ``gpiozero`` est utilis√© pour contr√¥ler la LED PWM, ``ADC0834`` pour la conversion analogique-num√©rique, et ``time`` pour les temporisations.

   .. code-block:: python

       #!/usr/bin/env python3

       from gpiozero import PWMLED
       import ADC0834
       import time

#. Initialisez une LED PWM connect√©e √† la broche GPIO 22 et configurez le convertisseur ADC0834.

   .. code-block:: python

       # Initialiser une LED PWM sur la broche GPIO 22
       led = PWMLED(22)

       # Configurer le module ADC0834
       ADC0834.setup()

#. D√©finissez une fonction appel√©e ``MAP`` pour convertir une plage de valeurs en une autre, utile pour ajuster les niveaux de luminosit√© de la LED en fonction des valeurs de l'ADC.

   .. code-block:: python

       def MAP(x, in_min, in_max, out_min, out_max):
           return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

#. Lisez continuellement la valeur de l'ADC, ajustez la luminosit√© de la LED en cons√©quence et impl√©mentez un d√©lai de 0,2 secondes pour am√©liorer la stabilit√©.

   .. code-block:: python

       try:
           while True:
               # Get the current reading from the ADC0834 module
               res = ADC0834.getResult()
               print('res = %d' % res)

               # Map the ADC value to a range suitable for setting LED brightness
               R_val = MAP(res, 0, 255, 0, 100)

               # Set the LED brightness
               led.value = float(R_val / 100)

               # Wait for 0.2 seconds before reading again
               time.sleep(0.2)

       # Sortie propre lors de l'appui sur 'Ctrl+C'
       except KeyboardInterrupt: 
           led.value = 0  # √âteindre la LED

