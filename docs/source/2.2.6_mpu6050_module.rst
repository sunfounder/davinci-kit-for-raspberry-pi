.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook¬†! Plongez dans le monde de Raspberry Pi, Arduino et ESP32 avec des passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support expert** : R√©solvez vos probl√®mes apr√®s-vente et d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui¬†!

2.2.6 Module MPU6050
=======================

Introduction
--------------

Le MPU-6050 est le premier et unique dispositif de suivi de mouvement 6 axes 
(3 axes de gyroscope et 3 axes d'acc√©l√©rom√®tre) con√ßu pour les smartphones, 
tablettes et capteurs portables, offrant une faible consommation, un faible 
co√ªt et des performances √©lev√©es.

Dans cette exp√©rience, nous utiliserons l'I2C pour obtenir les valeurs de l'acc√©l√©rom√®tre 
√† trois axes et du gyroscope √† trois axes du MPU6050 et les afficher √† l'√©cran.

Composants
-------------

.. image:: img/list_2.2.6.png

Principe
------------

**MPU6050**

Le MPU-6050 est un dispositif de suivi de mouvement √† 6 axes (3 axes de gyroscope, 
3 axes d'acc√©l√©rom√®tre).

Ses trois syst√®mes de coordonn√©es sont d√©finis comme suit :

Placez le MPU6050 √† plat sur la table, assurez-vous que la face avec l'√©tiquette 
est orient√©e vers le haut et qu'un point sur cette surface se trouve dans le coin 
sup√©rieur gauche. Ensuite, la direction verticale vers le haut correspond √† l'axe 
Z de la puce. La direction de gauche √† droite est l'axe X, et la direction de l'arri√®re 
vers l'avant est l'axe Y.

.. image:: img/image223.png

**Acc√©l√©rom√®tre 3 axes**

L'acc√©l√©rom√®tre fonctionne selon le principe de l'effet pi√©zo√©lectrique, la capacit√© de 
certains mat√©riaux √† g√©n√©rer une charge √©lectrique en r√©ponse √† une contrainte m√©canique 
appliqu√©e.

Imaginez ici une bo√Æte cubo√Øde avec une petite balle √† l'int√©rieur, comme sur l'image 
ci-dessus. Les parois de cette bo√Æte sont faites de cristaux pi√©zo√©lectriques. Chaque 
fois que vous inclinez la bo√Æte, la balle se d√©place dans la direction de l'inclinaison 
en raison de la gravit√©. La paroi avec laquelle la balle entre en collision cr√©e de petits 
courants pi√©zo√©lectriques. Il y a au total trois paires de parois oppos√©es dans le cubo√Øde. 
Chaque paire correspond √† un axe dans l'espace 3D¬†: les axes X, Y et Z. En fonction du 
courant produit par les parois pi√©zo√©lectriques, nous pouvons d√©terminer la direction 
et l'amplitude de l'inclinaison.

.. image:: img/image224.png

Nous pouvons utiliser le MPU6050 pour d√©tecter son acc√©l√©ration sur chaque axe de 
coordonn√©es (dans un √©tat stationnaire, l'acc√©l√©ration de l'axe Z est de 1 unit√© de 
gravit√©, et les axes X et Y sont √† 0). S'il est inclin√© ou dans une condition de 
sur/sous-poids, la lecture correspondante changera.

Quatre plages de mesure peuvent √™tre s√©lectionn√©es par programmation¬†:
 +/-2g, +/-4g, +/-8g et +/-16g (2g par d√©faut), correspondant √† chaque pr√©cision. 
 Les valeurs vont de -32768 √† 32767.

La lecture de l'acc√©l√©rom√®tre est convertie en valeur d'acc√©l√©ration en mappant la 
lecture sur la plage de mesure.

Acc√©l√©ration = (Donn√©es brutes de l'acc√©l√©rom√®tre / 65536 \* plage d'acc√©l√©ration totale) g

Prenons l'exemple de l'axe X, lorsque les donn√©es brutes de l'acc√©l√©rom√®tre de l'axe X 
sont de 16384 et que la plage s√©lectionn√©e est +/-2g :

**Acc√©l√©ration le long de l'axe X = (16384 / 65536 \* 4) g**  **=1g**

**Gyroscope 3 axes**

Les gyroscopes fonctionnent sur le principe de l'acc√©l√©ration de Coriolis. Imaginez 
une structure en forme de fourche qui effectue un mouvement constant d'avant en arri√®re, 
maintenue en place par des cristaux pi√©zo√©lectriques. Lorsque vous inclinez cet agencement, 
les cristaux subissent une force dans la direction de l'inclinaison, g√©n√©r√©e par l'inertie 
de la fourche en mouvement. Les cristaux produisent ainsi un courant conforme √† l'effet 
pi√©zo√©lectrique, qui est ensuite amplifi√©.

.. image:: img/image225.png
    :width: 800
    :align: center

Le gyroscope dispose √©galement de quatre plages de mesure¬†:
 +/-250, +/-500, +/-1000 et +/-2000. La m√©thode de calcul est essentiellement la m√™me 
 que celle de l'acc√©l√©ration.

La formule pour convertir la lecture en vitesse angulaire est la suivante :

Vitesse angulaire = (Donn√©es brutes de l'axe du gyroscope / 65536 \* plage du gyroscope) ¬∞/s

Prenons l'exemple de l'axe X¬†: si les donn√©es brutes du gyroscope pour l'axe X sont de 
16384 et que la plage est de +/- 250¬∞/s¬†:

**Vitesse angulaire le long de l'axe X = (16384 / 65536 \* 500)¬∞/s** **=125¬∞/s**

Sch√©ma
---------

Le MPU6050 communique avec le microcontr√¥leur via l'interface de bus I2C. Les broches 
SDA1 et SCL1 doivent √™tre connect√©es √† la broche correspondante.

.. image:: img/image330.png
    :width: 600
    :align: center


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1¬†:** Construisez le circuit.

.. image:: img/image227.png
    :width: 800

**√âtape 2**¬†: Configurez l'I2C (voir l'annexe. Si vous avez d√©j√† configur√© l'I2C, passez cette √©tape.)
Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 3 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.6/

**√âtape 4 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.6_mpu6050.c -lwiringPi -lm

**√âtape 5 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le code ex√©cut√©, les angles de d√©viation des axes X et Y, ainsi que 
l'acc√©l√©ration et la vitesse angulaire sur chaque axe, seront calcul√©s et affich√©s 
sur l'√©cran √† partir des donn√©es lues par le MPU6050.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou si un message d'erreur tel que ¬´¬†wiringPi.h: No such file or directory¬†¬ª appara√Æt, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include  <wiringPiI2C.h>
    #include <wiringPi.h>
    #include  <stdio.h>
    #include  <math.h>
    int fd;
    int acclX, acclY, acclZ;
    int gyroX, gyroY, gyroZ;
    double acclX_scaled, acclY_scaled, acclZ_scaled;
    double gyroX_scaled, gyroY_scaled, gyroZ_scaled;

    int read_word_2c(int addr)
    {
        int val;
        val = wiringPiI2CReadReg8(fd, addr);
        val = val << 8;
        val += wiringPiI2CReadReg8(fd, addr+1);
        if (val >= 0x8000)
            val = -(65536 - val);
        return val;
    }

    double dist(double a, double b)
    {
        return sqrt((a*a) + (b*b));
    }

    double get_y_rotation(double x, double y, double z)
    {
        double radians;
        radians = atan2(x, dist(y, z));
        return -(radians * (180.0 / M_PI));
    }

    double get_x_rotation(double x, double y, double z)
    {
        double radians;
        radians = atan2(y, dist(x, z));
        return (radians * (180.0 / M_PI));
    }

    int main()
    {
        fd = wiringPiI2CSetup (0x68);
        wiringPiI2CWriteReg8 (fd,0x6B,0x00); // d√©sactivation du mode veille
        printf("set 0x6B=%X\n",wiringPiI2CReadReg8 (fd,0x6B));
        
        while(1) {

            gyroX = read_word_2c(0x43);
            gyroY = read_word_2c(0x45);
            gyroZ = read_word_2c(0x47);

            gyroX_scaled = gyroX / 131.0;
            gyroY_scaled = gyroY / 131.0;
            gyroZ_scaled = gyroZ / 131.0;

        //Print values for the X, Y, and Z axes of the gyroscope sensor.
        printf("My gyroX_scaled: %f\n", gyroY X_scaled);
            delay(100);
        printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
            delay(100);
        printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);
            delay(100);

            acclX = read_word_2c(0x3B);
            acclY = read_word_2c(0x3D);
            acclZ = read_word_2c(0x3F);

            acclX_scaled = acclX / 16384.0;
            acclY_scaled = acclY / 16384.0;
            acclZ_scaled = acclZ / 16384.0;
            
        //Print the X, Y, and Z values of the acceleration sensor.
        printf("My acclX_scaled: %f\n", acclX_scaled);
            delay(100);
        printf("My acclY_scaled: %f\n", acclY_scaled);
            delay(100);
        printf("My acclZ_scaled: %f\n", acclZ_scaled);
            delay(100);

        printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
            delay(100);
        printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
            delay(100);
            
            delay(100);
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    int read_word_2c(int addr)
    {
    int val;
    val = wiringPiI2CReadReg8(fd, addr);
    val = val << 8;
    val += wiringPiI2CReadReg8(fd, addr+1);
    if (val >= 0x8000)
        val = -(65536 - val);
    return val;
    }

Lecture des donn√©es du capteur envoy√©es par le MPU6050.

.. code-block:: c

    double get_y_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(x, dist(y, z));
    return -(radians * (180.0 / M_PI));
    }

Obtention de l'angle de d√©viation sur l'axe Y.

.. code-block:: c

    double get_x_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(y, dist(x, z));
    return (radians * (180.0 / M_PI));
    }

Calcul de l'angle de d√©viation sur l'axe X.

.. code-block:: c

    gyroX = read_word_2c(0x43);
    gyroY = read_word_2c(0x45);
    gyroZ = read_word_2c(0x47);

    gyroX_scaled = gyroX / 131.0;
    gyroY_scaled = gyroY / 131.0;
    gyroZ_scaled = gyroZ / 131.0;

    //Print values for the X, Y, and Z axes of the gyroscope sensor.
    printf("My gyroX_scaled: %f\n", gyroY X_scaled);
    printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
    printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);

Lecture des valeurs des axes X, Y et Z sur le capteur gyroscope, conversion des m√©tadonn√©es en valeurs de vitesse angulaire, puis affichage des r√©sultats.

.. code-block:: c

    acclX = read_word_2c(0x3B);
    acclY = read_word_2c(0x3D);
    acclZ = read_word_2c(0x3F);

    acclX_scaled = acclX / 16384.0;
    acclY_scaled = acclY / 16384.0;
    acclZ_scaled = acclZ / 16384.0;
        
    //Print the X, Y, and Z values of the acceleration sensor.
    printf("My acclX_scaled: %f\n", acclX_scaled);
    printf("My acclY_scaled: %f\n", acclY_scaled);
    printf("My acclZ_scaled: %f\n", acclZ_scaled);

Lecture des valeurs des axes X, Y et Z sur le capteur d'acc√©l√©ration, conversion des m√©tadonn√©es en valeurs d'acc√©l√©ration (unit√©s gravitationnelles), puis affichage des r√©sultats.

.. code-block:: c

    printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
    printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));

Affichage des angles de d√©viation sur les axes X et Y.

Pour les utilisateurs du langage Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 3 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_mpu6050.py

Lorsque le code s'ex√©cute, l'angle de d√©viation des axes X et Y, ainsi que l'acc√©l√©ration 
et la vitesse angulaire sur chaque axe lues par le MPU6050, seront calcul√©s et affich√©s √† 
l'√©cran.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import smbus
    import math
    import time

    # Registres de gestion de l'alimentation
    power_mgmt_1 = 0x6b
    power_mgmt_2 = 0x6c

    def read_byte(adr):
        return bus.read_byte_data(address, adr)

    def read_word(adr):
        high = bus.read_byte_data(address, adr)
        low = bus.read_byte_data(address, adr+1)
        val = (high << 8) + low
        return val

    def read_word_2c(adr):
        val = read_word(adr)
        if (val >= 0x8000):
            return -((65535 - val) + 1)
        else:
            return val

    def dist(a,b):
        return math.sqrt((a*a)+(b*b))

    def get_y_rotation(x,y,z):
        radians = math.atan2(x, dist(y,z))
        return -math.degrees(radians)

    def get_x_rotation(x,y,z):
        radians = math.atan2(y, dist(x,z))
        return math.degrees(radians)


    bus = smbus.SMBus(1) # ou bus = smbus.SMBus(1) pour les cartes R√©vision 2
    address = 0x68       # Ceci est l'adresse lue via la commande i2cdetect

    # R√©veillez maintenant le MPU6050 car il commence en mode veille
    bus.write_byte_data(address, power_mgmt_1, 0)

    while True:
        time.sleep(0.1)
        gyro_xout = read_word_2c(0x43)
        gyro_yout = read_word_2c(0x45)
        gyro_zout = read_word_2c(0x47)

        print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
        print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
        print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

        accel_xout = read_word_2c(0x3b)
        accel_yout = read_word_2c(0x3d)
        accel_zout = read_word_2c(0x3f)

        accel_xout_scaled = accel_xout / 16384.0
        accel_yout_scaled = accel_yout / 16384.0
        accel_zout_scaled = accel_zout / 16384.0

        print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
        print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
        print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

        print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
        print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

        time.sleep(0.5)

**Explication du code**

.. code-block:: python

    def read_word(adr):
        high = bus.read_byte_data(address, adr)
        low = bus.read_byte_data(address, adr+1)
        val = (high << 8) + low
        return val

    def read_word_2c(adr):
        val = read_word(adr)
        if (val >= 0x8000):
            return -((65535 - val) + 1)
        else:
            return val

Lecture des donn√©es du capteur envoy√©es par le MPU6050.

.. code-block:: python

    def get_y_rotation(x,y,z):
        radians = math.atan2(x, dist(y,z))
        return -math.degrees(radians)

Calcul de l'angle de d√©viation de l'axe Y.

.. code-block:: python

    def get_x_rotation(x,y,z):
        radians = math.atan2(y, dist(x,z))
        return math.degrees(radians)

Calcul de l'angle de d√©viation de l'axe X.

.. code-block:: python

    gyro_xout = read_word_2c(0x43)
    gyro_yout = read_word_2c(0x45)
    gyro_zout = read_word_2c(0x47)

    print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
    print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
    print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

Lecture des valeurs des axes X, Y et Z du capteur gyroscope, conversion des donn√©es en valeurs de vitesse angulaire, et affichage des r√©sultats.

.. code-block:: python

    accel_xout = read_word_2c(0x3b)
    accel_yout = read_word_2c(0x3d)
    accel_zout = read_word_2c(0x3f)

    accel_xout_scaled = accel_xout / 16384.0
    accel_yout_scaled = accel_yout / 16384.0
    accel_zout_scaled = accel_zout / 16384.0

    print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
    print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
    print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

Lecture des valeurs des axes X, Y et Z du capteur d'acc√©l√©ration, conversion des 
donn√©es en valeurs d'acc√©l√©ration (en unit√©s gravitationnelles), puis affichage 
des r√©sultats.

.. code-block:: python

    print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
    print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

Affichage des angles de d√©viation des axes X et Y.

Image du ph√©nom√®ne
----------------------

.. image:: img/image228.jpeg