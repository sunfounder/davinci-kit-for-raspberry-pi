.. note::

    Bonjour, bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans le Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes post-vente et relevez les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des concours et promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.3.3 Moteur Pas √† Pas
=========================

Introduction
--------------

Les moteurs pas √† pas, gr√¢ce √† leur conception unique, peuvent √™tre contr√¥l√©s 
avec une grande pr√©cision sans n√©cessiter de m√©canismes de r√©troaction. L'arbre 
d'un moteur pas √† pas, √©quip√© d'une s√©rie d'aimants, est contr√¥l√© par une s√©rie 
de bobines √©lectromagn√©tiques charg√©es positivement et n√©gativement dans un ordre 
sp√©cifique, le d√©pla√ßant ainsi pr√©cis√©ment vers l'avant ou vers l'arri√®re par 
petites ¬´ √©tapes ¬ª.

Composants
-----------

.. image:: img/list_1.3.3.png


Principe
-----------

**Moteur Pas √† Pas**

Il existe deux types de moteurs pas √† pas, unipolaires et bipolaires, et il est tr√®s 
important de conna√Ætre le type de moteur avec lequel vous travaillez. Dans cette exp√©rience, 
nous utiliserons un moteur pas √† pas unipolaire.

Le moteur pas √† pas utilis√© ici est un moteur √† quatre phases qui utilise une 
alimentation DC unipolaire. Tant que vous alimentez les enroulements de chaque 
phase du moteur selon une s√©quence temporelle appropri√©e, vous pouvez le faire 
tourner √©tape par √©tape. Le sch√©ma d'un moteur pas √† pas r√©actif √† quatre phases 
est illustr√© ci-dessous :

.. image:: img/image129.png


Dans cette figure, au centre du moteur se trouve un rotor - un aimant permanent en 
forme d'engrenage. Autour du rotor, de 0 √† 5, se trouvent les dents. Plus √† l'ext√©rieur, 
il y a 8 p√¥les magn√©tiques, chacun connect√© par un enroulement de bobine avec son oppos√©. 
Ils forment ainsi quatre paires de A √† D, appel√©es ¬´ phases ¬ª. Chaque phase poss√®de quatre 
fils √† connecter √† des commutateurs SA, SB, SC et SD. Ainsi, les quatre phases sont 
connect√©es en parall√®le dans le circuit, et les deux p√¥les magn√©tiques d'une m√™me phase 
sont en s√©rie.

**Fonctionnement d'un moteur pas √† pas √† 4 phases :**

Lorsque l'interrupteur SB est aliment√©, et que SA, SC et SD sont d√©sactiv√©s, les p√¥les 
magn√©tiques de la phase B s'alignent avec les dents 0 et 3 du rotor. En m√™me temps, les 
dents 1 et 4 se d√©salignent avec les p√¥les des phases C et D. Les dents 2 et 5 se 
d√©salignent avec les p√¥les des phases D et A. Lorsque SC est aliment√©, et que SA, SB et SD 
sont d√©sactiv√©s, le rotor tourne sous l'effet du champ magn√©tique de l'enroulement de phase 
C entre les dents 1 et 4. Les dents 1 et 4 s'alignent alors avec les p√¥les magn√©tiques de la 
phase C, tandis que les dents 0 et 3 se d√©salignent avec les p√¥les des phases A et B, et les 
dents 2 et 5 se d√©salignent avec les p√¥les magn√©tiques des phases A et D. Ce sch√©ma se r√©p√®te 
de mani√®re continue. En alimentant successivement les phases A, B, C et D, le rotor tournera 
dans l'ordre A, B, C et D.

.. image:: img/image130.png


Le moteur pas √† pas √† quatre phases dispose de trois modes de fonctionnement : le mode ¬´ simple 
√† quatre pas ¬ª, le mode ¬´ double √† quatre pas ¬ª et le mode ¬´ huit pas ¬ª. L'angle de pas pour les 
modes simple et double √† quatre pas est le m√™me, mais le couple de rotation pour le mode simple √† 
quatre pas est plus faible. L'angle de pas du mode huit pas est la moiti√© de celui des modes simple 
et double √† quatre pas. Ainsi, le mode de fonctionnement √† huit pas permet de maintenir un couple 
√©lev√© tout en am√©liorant la pr√©cision du contr√¥le.

Le stator du moteur pas √† pas que nous utilisons a 32 p√¥les magn√©tiques, ce qui signifie 
qu'il faut 32 pas pour faire un tour complet. L'arbre de sortie du moteur pas √† pas est 
reli√© √† un r√©ducteur, avec un rapport de r√©duction de 1/64. Ainsi, pour un tour complet 
de l'arbre de sortie, il faut 32*64=2048 pas.

**ULN2003**

Pour utiliser le moteur dans le circuit, une carte pilote est n√©cessaire. Le pilote de moteur pas √† pas ULN2003 est un circuit inverseur √† 7 canaux. Cela signifie que lorsque la broche d'entr√©e est √† un niveau haut, la broche de sortie de l'ULN2003 est √† un niveau bas, et vice versa. Si nous alimentons IN1 √† un niveau haut et IN2, IN3 et IN4 √† un niveau bas, alors la sortie OUT1 sera √† un niveau bas, et toutes les autres sorties seront √† un niveau haut. 
La structure interne de la puce est illustr√©e ci-dessous.

.. image:: img/image338.png


Le pilote de moteur pas √† pas constitu√© par la puce ULN2003 et les 4 LED est pr√©sent√© 
comme suit. Sur la carte, IN1, IN2, IN3 et IN4 fonctionnent comme entr√©es, et les quatre 
LED A, B, C, D indiquent les √©tats des broches d'entr√©e. De plus, OUT1, OUT2, OUT3 et OUT4 
sont connect√©s √† SA, SB, SC et SD sur le pilote du moteur pas √† pas. Lorsque la valeur de 
IN1 est r√©gl√©e √† un niveau haut, la LED A s'allume, l'interrupteur SA est activ√©, et le 
moteur pas √† pas tourne d'un pas. Ce m√™me sch√©ma se r√©p√®te pour les autres LED. Ainsi, en 
appliquant une s√©quence temporelle sp√©cifique, le moteur pas √† pas tournera √©tape par √©tape. 
L'ULN2003 est utilis√© ici pour fournir des s√©quences temporelles particuli√®res au moteur 
pas √† pas.

.. image:: img/image132.png


Sch√©ma de c√¢blage
--------------------


.. image:: img/image339.png


Proc√©dures Exp√©rimentales
-------------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/image134.png
    :width: 800


**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.3/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.3_StepperMotor.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier compil√©.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le programme s'ex√©cute, le moteur pas √† pas tourne dans le sens horaire 
ou antihoraire selon votre saisie : 'a' pour antihoraire et 'c' pour horaire.

.. note::

    Si le programme ne fonctionne pas apr√®s l'ex√©cution ou s'il y a un message d'erreur : \"wiringPi.h: No such file or directory\", veuillez vous r√©f√©rer √† la section :ref:`C code is not working?`.


**Code**

.. code-block:: c

    #include <stdio.h>
    #include <wiringPi.h>

    const int motorPin[] = {1, 4, 5, 6};
    int rolePerMinute = 15;
    int stepsPerRevolution = 2048;
    int stepSpeed = 0;

    void rotary(char direction){
        if(direction == 'c'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99>>j & (0x08>>i));}
                delayMicroseconds(stepSpeed);
            }        
        }
        else if(direction =='a'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99<<j & (0x80>>i));}
                delayMicroseconds(stepSpeed);
            }   
        }
    }

    void loop()
    {
        char direction = '0';
        while (1)
        {       
            printf("select motor direction a=anticlockwise, c=clockwise: ");
            delay(100);
            direction=getchar();
            if (direction == 'c')
            {
                printf("motor running clockwise\n");
                delay(100);
                break;
            }
            else if (direction == 'a')
            {
                printf("motor running anti-clockwise\n");
                delay(100);
                break;
            }
            else
            {
                printf("input error, please try again!\n");
                delay(100);
            }
        }
        while(1)
        {
            rotary(direction);
        }
    }

    void main(void)
    {
        if (wiringPiSetup() == -1)
        {
            printf("setup wiringPi failed !");
            return;
        }
        for (int i = 0; i < 4; i++)
        {
            pinMode(motorPin[i], OUTPUT);
        }
        stepSpeed = (60000000 / rolePerMinute) / stepsPerRevolution;
        loop();
    }

**Explication du Code**

.. code-block:: c

    int rolePerMinute = 15;
    int stepsPerRevolution = 2048;
    int stepSpeed = 0;

**rolePerMinute :** R√©volutions par minute, la vitesse de rotation (RPM) du moteur pas 
√† pas utilis√©e dans ce kit doit √™tre comprise entre 0 et 17.

**stepsPerRevolution :** Le nombre de pas par tour, le moteur pas √† pas utilis√© dans ce 
kit n√©cessite 2048 pas par r√©volution.

**stepSpeed :** Le temps utilis√© pour chaque pas, et dans main(), nous attribuons les 
valeurs de cette mani√®re :„Äå(60000000 / rolePerMinute) / stepsPerRevolution„Äç
(60 000 000 us = 1 minute)

.. code-block:: c

    void loop()
    {
        char direction = '0';
        while (1)
        {       
            printf("select motor direction a=anticlockwise, c=clockwise: ");
            direction=getchar();
            if (direction == 'c')
            {
                printf("motor running clockwise\n");
                break;
            }
            else if (direction == 'a')
            {
                printf("motor running anti-clockwise\n");
                break;
            }
            else
            {
                printf("input error, please try again!\n");
            }
        }
        while(1)
        {
            rotary(direction);
        }
    }

La fonction `loop()` est divis√©e en deux parties (situ√©es entre deux `while(1)`) :

La premi√®re partie consiste √† obtenir la valeur de la touche. Lorsque \'a\' ou \'c\' est re√ßu, le programme sort de la boucle et arr√™te la saisie.

La deuxi√®me partie appelle `rotary(direction)` pour faire fonctionner le moteur pas √† pas.

.. code-block:: c

    void rotary(char direction){
        if(direction == 'c'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99>>j & (0x08>>i));}
                delayMicroseconds(stepSpeed);
            }        
        }
        else if(direction =='a'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99<<j & (0x80>>i));}
                delayMicroseconds(stepSpeed);
            }   
        }
    }

Pour faire tourner le **moteur dans le sens horaire**, le statut de niveau des broches `motorPin` est affich√© dans le tableau ci-dessous :

.. image:: img/image340.png


Ainsi, l'√©criture des potentiels des broches du moteur est impl√©ment√©e en utilisant une double boucle `for`.

In Step1, j=0, i=0~4.

motorPin[0] will be written in the high levelÔºà10011001&00001000=1Ôºâ

motorPin[1] will be written in the low levelÔºà10011001&00000100=0Ôºâ

motorPin[2] will be written in the low levelÔºà10011001&00000010=0Ôºâ

motorPin[3] will be written in the high levelÔºà10011001&00000001=1Ôºâ

In Step2, j=1, i=0~4.

motorPin[0] will be written in the high levelÔºà01001100&00001000=1Ôºâ

motorPin[1] will be written in the low levelÔºà01001100&00000100=1Ôºâ

et ainsi de suite.

Et pour faire tourner le moteur pas √† pas **dans le sens antihoraire**, le statut 
de niveau des broches `motorPin` est affich√© dans le tableau suivant.

.. image:: img/image341.png


In Step1, j=0, i=0~4.

motorPin[0] will be written in the high levelÔºà10011001&10000000=1Ôºâ

motorPin[1] will be written in the low levelÔºà10011001&01000000=0Ôºâ

In Step2Ôºåj=1, i=0~4.

motorPin[0] will be written in the high levelÔºà00110010&10000000=0Ôºâ

motorPin[1] will be written in the low levelÔºà00110010&01000000=0Ôºâ

et ainsi de suite.

