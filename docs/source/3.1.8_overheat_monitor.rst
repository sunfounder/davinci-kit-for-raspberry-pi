.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

3.1.8 Ãœberhitzungsmonitor
===========================

EinfÃ¼hrung
-------------------

MÃ¶glicherweise mÃ¶chten Sie ein ÃœberhitzungsÃ¼berwachungsgerÃ¤t herstellen, das fÃ¼r verschiedene Situationen gilt, z. B. im Werk, wenn wir einen Alarm und das rechtzeitige automatische Ausschalten der Maschine bei Ãœberhitzung des Stromkreises wÃ¼nschen. In dieser Lektion verwenden wir Thermistor, Joystick, Summer, LED und LCD, um ein intelligentes TemperaturÃ¼berwachungsgerÃ¤t zu erstellen, dessen Schwelle einstellbar ist.

Komponenten
-----------------

.. image:: media/list_Overheat_Monitor.png
    :align: center

.. image:: media/list_Overheat_Monitor2.png
    :align: center

Schematische Darstellung
--------------------------

============ ======== ======== ===
T-Karte Name physisch wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: media/Schematic_three_one8.png
   :width: 700
   :align: center

Experimentelle Verfahren
-----------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: media/image258.png
   :alt: Overheat Monitor_bb
   :width: 800

FÃ¼r Benutzer in C-Sprache
^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block:: 

    cd /home/pi/davinci-kit-for-raspberry-pi/c/3.1.8/

Schritt 3: Kompilieren Sie der Kode.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

Schritt 4: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

WÃ¤hrend die Kode ausgefÃ¼hrt wird, 
werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. 
Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, 
werden der Summer und die LED gestartet, um Sie zu alarmieren.


Der Joystick dient zum DrÃ¼cken, um die Hochtemperaturschwelle anzupassen. Durch Umschalten des Joystick in Richtung X-Achse und Y-Achse kann der aktuelle Hochtemperaturschwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

**Code ErklÃ¤rung**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

Diese Funktion liest die Werte von X und Y. 
Wenn X> 200 ist, wird â€ž1â€œ zurÃ¼ckgegeben. X<50, return â€ž-1â€œ; y> 200, 
geben Sie â€ž-10â€œ zurÃ¼ck, und y<50, geben Sie â€ž10â€œ zurÃ¼ck.

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

This function is for adjusting the threshold and displaying it on the I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Lesen Sie den Analogwert des CH0 (Thermistor) von ADC0834 ab und wandeln Sie ihn dann in einen Temperaturwert um.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

WÃ¤hrend die Kode ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, 
werden der Summer und die LED gestartet, um Sie zu alarmieren.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

Die Funktion ``main()`` enthÃ¤lt den gesamten Programmablauf wie folgt:

1. Wenn das Programm startet, ist der Anfangswert der Stufe 0, und die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 werden auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, werden der Summer und die LED gestartet, um Sie zu alarmieren.

#. DrÃ¼cken Sie den Joystick, und die Stufe ist 1, und Sie kÃ¶nnen die Hochtemperaturschwelle einstellen. Durch Umschalten des Joysticks in Richtung X-Achse und Y-Achse kann der aktuelle Schwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

FÃ¼r Python-Sprachbenutzer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block:: 

    cd /home/pi/davinci-kit-for-raspberry-pi/python/

Schritt 3: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.8_OverheatMonitor.py

WÃ¤hrend die Kode ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, werden der Summer und die LED gestartet, um Sie zu alarmieren.

Der Joystick dient zum DrÃ¼cken, um die Hochtemperaturschwelle anzupassen. Durch Umschalten des Joystick in Richtung X-Achse und Y-Achse kann der aktuelle Hochtemperaturschwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

**Code**

.. note::

    Sie kÃ¶nnen den folgenden Code **Ã„ndern/ZurÃ¼cksetzen/Kopieren/AusfÃ¼hren/Stoppen** . Zuvor mÃ¼ssen Sie jedoch zu einem Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python`` gehen.
   
.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24


    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Code ErklÃ¤rung**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

Diese Funktion liest die Werte von X und Y. Wenn X> 200 ist, wird â€ž1â€œ zurÃ¼ckgegeben. 
X<50, return â€ž-1â€œ; y> 200, geben Sie â€ž-10â€œ zurÃ¼ck, und y<50, geben Sie â€ž10â€œ zurÃ¼ck.

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

Diese Funktion dient zum Anpassen des Schwellenwerts und zum Anzeigen auf dem I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Lesen Sie den Analogwert des CH0 (Thermistor) von ADC0834 ab und wandeln Sie ihn dann in einen Temperaturwert um.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

WÃ¤hrend die Kode ausgefÃ¼hrt wird, 
werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. 
Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, 
werden der Summer und die LED gestartet, um Sie zu alarmieren.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

Die Funktion ``main()`` enthÃ¤lt den gesamten Programmablauf wie folgt:

1. Wenn das Programm startet, ist der Anfangswert der Stufe 0, und die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 werden auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, werden der Summer und die LED gestartet, um Sie zu alarmieren.

#. DrÃ¼cken Sie den Joystick, und die Stufe ist 1, und Sie kÃ¶nnen die Hochtemperaturschwelle einstellen. Durch Umschalten des Joysticks in Richtung X-Achse und Y-Achse kann der aktuelle Hochtemperaturschwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

PhÃ¤nomen Bild
-------------------------

.. image:: media/image259.jpeg
   :align: center