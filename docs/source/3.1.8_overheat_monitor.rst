.. note:: 

    Ciao, benvenuto nella Community SunFounder per appassionati di Raspberry Pi, Arduino e ESP32 su Facebook! Unisciti a noi per approfondire le conoscenze su Raspberry Pi, Arduino e ESP32 insieme ad altri entusiasti.

    **PerchÃ© unirsi a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con il supporto della nostra community e del nostro team.
    - **Impara e condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Accedi in anteprima agli annunci di nuovi prodotti e alle anticipazioni.
    - **Sconti speciali**: Goditi sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni e concorsi festivi**: Partecipa ai concorsi e alle promozioni durante le festivitÃ .

    ðŸ‘‰ Pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

3.1.8 Monitor di Surriscaldamento
====================================

Introduzione
--------------

Potresti voler creare un dispositivo di monitoraggio della temperatura che 
si adatta a diverse situazioni. Ad esempio, in una fabbrica, potremmo voler 
avere un sistema di allarme e spegnimento automatico quando câ€™Ã¨ un surriscaldamento 
del circuito. In questa lezione, utilizzeremo un termistore, un joystick, 
un buzzer, un LED e un display LCD per creare un dispositivo intelligente 
di monitoraggio della temperatura con una soglia regolabile.

Componenti
--------------

.. image:: img/list_Overheat_Monitor.png
    :align: center

.. image:: img/list_Overheat_Monitor2.png
    :align: center

Schema del Circuito
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one8.png
   :width: 700
   :align: center

Procedure Sperimentali
---------------------------

**Passo 1:** Costruisci il circuito.

.. image:: img/image258.png
   :alt: Overheat Monitor_bb
   :width: 800

**Per Utenti C**
^^^^^^^^^^^^^^^^^^^

**Passo 2**: Accedi alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.8/

**Passo 3**: Compila il codice.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

**Passo 4**: Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Allâ€™avvio del codice, la temperatura corrente e la soglia di alta temperatura 
**40** sono visualizzate su **I2C LCD1602**. Se la temperatura corrente supera 
la soglia, il buzzer e il LED si attivano per avvisarti.

.. note::

    Se non funziona dopo l'esecuzione, o compare un errore come: \"wiringPi.h: No such file or directory\", consulta :ref:`Il codice C non funziona?`.


Il **Joystick** consente di regolare la soglia della temperatura massima. 
Muovendo il **Joystick** lungo gli assi X e Y Ã¨ possibile aumentare o 
diminuire la soglia di alta temperatura. Premendo nuovamente il **Joystick** 
la soglia si resetta al valore iniziale.

**Spiegazione del Codice**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

Questa funzione legge i valori di X e Y. Se **X>200**, restituisce \"**1**\"; 
se **X<50**, restituisce \"**-1**\"; se **y>200**, restituisce \"**-10**\"; 
e se **y<50**, restituisce \"**10**\".

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,1,str);
    Â Â Â Â intÂ len;
    Â Â Â Â lenÂ =Â strlen(str);
    Â Â Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

Questa funzione serve a regolare la soglia e a visualizzarla sullâ€™I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Leggi il valore analogico del **CH0** (termistore) su **ADC0834** e 
convertilo in valore di temperatura.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

Quando il codice viene eseguito, la temperatura attuale e la soglia di 
alta temperatura **40** vengono visualizzate su **I2C LCD1602**. Se la 
temperatura corrente supera la soglia, il buzzer e il LED si attivano 
per avvisarti.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

La funzione main() contiene lâ€™intero processo del programma come segue:

1) Allâ€™avvio del programma, il valore iniziale di **stage** Ã¨ **0**, e la 
temperatura corrente e la soglia di alta temperatura **40** vengono visualizzate 
su **I2C LCD1602**. Se la temperatura corrente supera la soglia, il buzzer 
e il LED si attivano per avvisarti.

2) Premi il Joystick, e **stage** passerÃ  a **1**, permettendoti di regolare 
la soglia di alta temperatura. Muovendo il Joystick lungo gli assi X e Y Ã¨ 
possibile aumentare o diminuire la soglia attuale. Premendo nuovamente il 
Joystick, la soglia si resetta al valore iniziale.

**Per Utenti Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^

**Passo 2**: Vai alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**Passo 3**: Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.8_OverheatMonitor.py

All'avvio del codice, la temperatura corrente e la soglia di alta temperatura 
**40** sono visualizzate su **I2C LCD1602**. Se la temperatura corrente supera 
la soglia, il buzzer e il LED si attivano per avvisarti.

Il **Joystick** consente di regolare la soglia di alta temperatura. Muovendo 
il **Joystick** lungo gli assi X e Y Ã¨ possibile aumentare o diminuire la 
soglia attuale. Premendo nuovamente il **Joystick**, la soglia si resetta al 
valore iniziale.

**Codice**

.. note::

    Puoi **Modificare/Reimpostare/Copiare/Eseguire/Arrestare** il codice qui sotto. Prima di farlo, perÃ², devi accedere al percorso del codice sorgente, ad esempio ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24


    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Programma inizia da qui
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # Quando si preme 'Ctrl+C', viene eseguita la funzione destroy().
            destroy()
**Spiegazione del Codice**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

Questa funzione legge i valori di X e Y. Se **X>200**, restituisce
\"**1**\"; se **X<50**, restituisce \"**-1**\"; se **Y>200**, restituisce
\"**-10**\"; e se **Y<50**, restituisce \"**10**\".

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

Questa funzione regola la soglia e la visualizza su
I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Legge il valore analogico del **CH0** (termistore) su **ADC0834** e lo
converte in valore di temperatura.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

Quando il codice Ã¨ in esecuzione, la temperatura attuale e la soglia di
alta temperatura **40** vengono visualizzate su **I2C LCD1602**. Se la
temperatura corrente supera la soglia, il buzzer e il LED si attivano
per avvisarti.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

La funzione main() include lâ€™intero processo del programma come segue:

1) Quando il programma inizia, il valore iniziale di **stage** Ã¨ **0**, 
   e la temperatura corrente e la soglia di alta temperatura **40** sono 
   visualizzate su **I2C LCD1602**. Se la temperatura corrente supera la 
   soglia, il buzzer e il LED si attivano per avvisarti.

2) Premi il Joystick, e **stage** sarÃ  impostato a **1** permettendoti di 
   regolare la soglia di alta temperatura. Muovendo il Joystick lungo gli 
   assi X e Y Ã¨ possibile aumentare o diminuire la soglia attuale. Premendo 
   nuovamente il Joystick, la soglia torna al valore iniziale.


Immagine del Fenomeno
-------------------------

.. image:: img/image259.jpeg
   :align: center