.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _3.1.14_py_pi5:

3.1.14 SPIEL ‚Äì Not Not
===========================

Einf√ºhrung
--------------------

In dieser Lektion werden wir ein interessantes Spielger√§t bauen, das wir "Not Not" nennen.

W√§hrend des Spiels wird auf der Punkt-Matrix zuf√§llig ein Pfeil angezeigt. Ihre Aufgabe ist es, innerhalb einer begrenzten Zeit die Taste in die entgegengesetzte Richtung des Pfeils zu dr√ºcken. Ist die Zeit abgelaufen oder wird die Taste in die gleiche Richtung wie der Pfeil gedr√ºckt, sind Sie raus.

Dieses Spiel trainiert wirklich Ihr umgekehrtes Denken, und nun, wollen wir es ausprobieren?

Ben√∂tigte Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir folgende Komponenten.

.. image:: ../python_pi5/img/3.1.14_game_not_not_list.png
    :width: 800
    :align: center

Schaltplan
-----------------------

============ ======== ======== ===
T-Board Name physisch wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../python_pi5/img/3.1.14_game_not_not_schematic.png
   :align: center

Experimentelle Verfahren
---------------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../python_pi5/img/3.1.14_game_not_not_circuit.png

**Schritt 2:** √ñffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5


**Schritt 3:** F√ºhren Sie die ausf√ºhrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.14_MotionControl_zero.py

Nachdem das Programm gestartet ist, erscheint auf der Punkt-Matrix ein Pfeil, der nach rechts oder links zeigt. Ihre Aufgabe ist es, innerhalb einer begrenzten Zeit die Taste in die entgegengesetzte Richtung des Pfeils zu dr√ºcken. Dann erscheint auf der Punkt-Matrix ein ‚Äû**‚àö**‚Äú. Wenn die Zeit abgelaufen ist oder die Taste in die gleiche Richtung wie der Pfeil gedr√ºckt wird, sind Sie raus, und die Punkt-Matrix zeigt ein ‚Äûx‚Äú an. Sie k√∂nnen auch 2 neue Tasten hinzuf√ºgen oder sie durch Joystick-Tasten f√ºr oben, unten, links und rechts ‚Äì 4 Richtungen ersetzen, um den Schwierigkeitsgrad des Spiels zu erh√∂hen.

.. warning::

    Wenn die Fehlermeldung ``RuntimeError: Cannot determine SOC peripheral base address`` angezeigt wird, lesen Sie bitte :ref:`faq_soc`

**Code**

.. note::

    Sie k√∂nnen den untenstehenden Code **modifizieren/zur√ºcksetzen/kopieren/ausf√ºhren/stoppen**. Bevor Sie dies tun, sollten Sie jedoch zum Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python-pi5`` wechseln. Nachdem Sie den Code ge√§ndert haben, k√∂nnen Sie ihn direkt ausf√ºhren, um das Ergebnis zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice, Button
   import time
   import threading
   import random

   # GPIO-Pins f√ºr das 74HC595 Schieberegister
   SDI = OutputDevice(17)   # Serieller Dateneingang
   RCLK = OutputDevice(18)  # Registeruhr
   SRCLK = OutputDevice(27) # Schieberegisteruhr

   # GPIO-Pins f√ºr Tasten
   AButtonPin = Button(20)  # Taste A
   BButtonPin = Button(26)  # Taste B

   # Initialisierung von Spielvariablen
   timerPlay = 0
   timerCheck = 0
   waypoint = "NULL"
   stage = "NULL"

   # Pfeil-Glyphen f√ºr die LED-Matrix-Anzeige
   arrow = {
       "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
       "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
   }

   # Feedback-Glyphen f√ºr richtige/falsche Antworten
   check = {
       "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
       "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
   }

   def hc595_shift(dat):
       """ Verschiebt Daten in das 74HC595 Schieberegister. """
       for i in range(8):
           SDI.value = 0x80 & (dat << i)
           SRCLK.on()
           SRCLK.off()

   def display(glyphCode):
       """ Zeigt ein Glyph auf der LED-Matrix an. """
       for i in range(0, 8):
           hc595_shift(glyphCode[i])
           hc595_shift(0x80 >> i)
           RCLK.on()
           RCLK.off()

   def creatGlyph():
       """ Erstellt ein neues Glyph f√ºr das Spiel und startet den Spiel-Timer. """
       global waypoint, stage, timerPlay
       waypoint = random.choice(list(arrow.keys()))
       stage = "PLAY"
       timerPlay = threading.Timer(2.0, timeOut)
       timerPlay.start()

   def checkPoint(inputKey):
       """ √úberpr√ºft die Eingabe des Spielers und aktualisiert den Spielstatus. """
       global waypoint, stage, timerCheck
       if inputKey == "empty" oder inputKey == waypoint:
           waypoint = "wrong"
       else:
           waypoint = "right"
       timerPlay.cancel()
       stage = "CHECK"
       timerCheck = threading.Timer(1.0, creatGlyph)
       timerCheck.start()

   def timeOut():
       """ Behandelt das Szenario eines Spielzeit-√úberlaufs. """
       checkPoint("empty")

   def getKey():
       """ Erkennt Tastendruck und l√∂st Checkpoint aus. """
       if AButtonPin.is_pressed und nicht BButtonPin.is_pressed:
           checkPoint("right")
       elif nicht AButtonPin.is_pressed und BButtonPin.is_pressed:
           checkPoint("left")

   def main():
       """ Hauptspielschleife. """
       creatGlyph()
       while True:
           if stage == "PLAY":
               display(arrow[waypoint])
               getKey()
           elif stage == "CHECK":
               display(check[waypoint])

   def destroy():
       """ R√§umt Ressourcen bei Programmende auf. """
       global timerPlay, timerCheck
       timerPlay.cancel()  # Spiel-Timer abbrechen
       timerCheck.cancel()  # Checkpoint-Timer abbrechen

   # Spiel ausf√ºhren, KeyboardInterrupt f√ºr sauberen Ausstieg abfangen
   try:
       main()
   except KeyboardInterrupt:
       destroy()


**Code-Erkl√§rung**

Basierend auf **1.1.6 LED-Punkt-Matrix** f√ºgt diese Lektion **2** Tasten hinzu, um ein unterhaltsames Spielger√§t zu machen. Wenn Sie also nicht sehr vertraut mit der Punkt-Matrix sind, beziehen Sie sich bitte auf :ref:`1.1.6_py_pi5`.

#. Der Code beginnt mit dem Import der notwendigen Bibliotheken. ‚Äûgpiozero‚Äú wird f√ºr die Interaktion mit GPIO-Pins wie Tasten und Ausgabeger√§ten verwendet. ‚Äûtime‚Äú erm√∂glicht das Hinzuf√ºgen von Verz√∂gerungen, ‚Äûthreading‚Äú erm√∂glicht das gleichzeitige Ausf√ºhren mehrerer Aufgaben und ‚Äûrandom‚Äú ist n√ºtzlich, um Zuf√§lligkeit im Projekt einzuf√ºhren.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice, Button
       import time
       import threading
       import random

#. Initialisiert GPIO-Pins f√ºr das Schieberegister (‚ÄûSDI‚Äú, ‚ÄûRCLK‚Äú, ‚ÄûSRCLK‚Äú) und Tasten (‚ÄûAButtonPin‚Äú, ‚ÄûBButtonPin‚Äú). Das Schieberegister wird verwendet, um mehrere LEDs mit weniger GPIO-Pins zu steuern, was f√ºr die LED-Matrixanzeige entscheidend ist.

   .. code-block:: python

       # GPIO-Pins f√ºr das 74HC595 Schieberegister
       SDI = OutputDevice(17)   # Serieller Dateneingang
       RCLK = OutputDevice(18)  # Registeruhr
       SRCLK = OutputDevice(27) # Schieberegisteruhr

       # GPIO-Pins f√ºr Tasten
       AButtonPin = Button(20)  # Taste A
       BButtonPin = Button(26)  # Taste B

#. Initialisiert Variablen, die in der Spiellogik verwendet werden, wie Timer und Spielzustandsindikatoren.

   .. code-block:: python

       # Spielvariablen-Initialisierung
       timerPlay = 0
       timerCheck = 0
       waypoint = "NULL"
       stage = "NULL"

#. Definiert bin√§re Muster zur Anzeige von Pfeilen und Feedback (richtig/falsch) auf der LED-Matrix. Jedes Array-Element repr√§sentiert eine Reihe der LED-Matrix, wobei ‚Äû1‚Äú und ‚Äû0‚Äú entsprechend bedeuten, dass eine LED an oder aus ist.

   .. code-block:: python

       # Pfeil-Glyphen f√ºr die LED-Matrixanzeige
       arrow = {
           "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
           "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
       }

       # Feedback-Glyphen f√ºr richtige/falsche Antworten
       check = {
           "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
           "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
       }

#. Diese Funktion verschiebt ein Byte Daten in das 74HC595 Schieberegister. Sie iteriert √ºber jedes Bit des ‚Äûdat‚Äú-Bytes, setzt den ‚ÄûSDI‚Äú-Pin entsprechend hoch oder niedrig und toggelt den ‚ÄûSRCLK‚Äú-Pin, um das Bit in das Register zu schieben.

   .. code-block:: python

       def hc595_shift(dat):
           """ Daten in das 74HC595 Schieberegister verschieben. """
           for i in range(8):
               SDI.value = 0x80 & (dat << i)
               SRCLK.on()
               SRCLK.off()

#. Diese Funktion zeigt ein Glyph auf der LED-Matrix an. Sie sendet jede Reihe des Glyphs (repr√§sentiert durch ‚ÄûglyphCode‚Äú) und die Adresse der Reihe an das Schieberegister mit ‚Äûhc595_shift‚Äú und toggelt dann den ‚ÄûRCLK‚Äú-Pin, um die Anzeige zu aktualisieren.

   .. code-block:: python

       def display(glyphCode):
           """ Ein Glyph auf der LED-Matrix anzeigen. """
           for i in range(0, 8):
               hc595_shift(glyphCode[i])
               hc595_shift(0x80 >> i)
               RCLK.on()
               RCLK.off()

#. Diese Funktion w√§hlt zuf√§llig ein Glyph aus dem ‚Äûarrow‚Äú-W√∂rterbuch aus, startet den Spiel-Timer und setzt die Spielphase auf ‚ÄûPLAY‚Äú. Der ‚Äûthreading.Timer‚Äú wird f√ºr die Zeitsteuerung im Spiel verwendet.

   .. code-block:: python

       def creatGlyph():
           """ Ein neues Glyph f√ºr das Spiel erstellen und den Spiel-Timer starten. """
           global waypoint, stage, timerPlay
           waypoint = random.choice(list(arrow.keys()))
           stage = "PLAY"
           timerPlay = threading.Timer(2.0, timeOut)
           timerPlay.start()

#. Diese Funktion √ºberpr√ºft die Eingabe des Spielers gegen√ºber dem aktuellen Glyph. Ist die Eingabe korrekt, wird das Wegpunkt auf "right" gesetzt, andernfalls auf "wrong". Anschlie√üend wird der aktuelle Spiel-Timer abgebrochen und ein neuer Timer f√ºr das n√§chste Glyph gestartet.

   .. code-block:: python

       def checkPoint(inputKey):
           """ Spieler-Eingabe √ºberpr√ºfen und Spielstatus aktualisieren. """
           global waypoint, stage, timerCheck
           if inputKey == "empty" oder inputKey == waypoint:
               waypoint = "wrong"
           else:
               waypoint = "right"
           timerPlay.cancel()
           stage = "CHECK"
           timerCheck = threading.Timer(1.0, creatGlyph)
           timerCheck.start()

#. Diese Funktion wird aufgerufen, wenn das Spiel zeitlich abl√§uft. Sie ruft ‚ÄûcheckPoint‚Äú mit ‚Äûempty‚Äú auf, um anzuzeigen, dass keine Taste rechtzeitig gedr√ºckt wurde.

   .. code-block:: python

       def timeOut():
           """ Szenario eines Spielzeit-√úberlaufs behandeln. """
           checkPoint("empty")

#. Diese Funktion √ºberpr√ºft den Zustand der Tasten. Wenn ‚ÄûAButtonPin‚Äú gedr√ºckt wird (und ‚ÄûBButtonPin‚Äú nicht), ruft sie ‚ÄûcheckPoint‚Äú mit "right" auf. Wenn ‚ÄûBButtonPin‚Äú gedr√ºckt wird (und ‚ÄûAButtonPin‚Äú nicht), ruft sie ‚ÄûcheckPoint‚Äú mit "left" auf.

   .. code-block:: python

       def getKey():
           """ Tastendruck erkennen und Checkpoint ausl√∂sen. """
           if AButtonPin.is_pressed und nicht BButtonPin.is_pressed:
               checkPoint("right")
           elif nicht AButtonPin.is_pressed und BButtonPin.is_pressed:
               checkPoint("left")

#. Die ‚Äûmain‚Äú-Funktion steuert den Spielablauf. Sie beginnt mit der Erstellung eines Glyphs und √ºberpr√ºft kontinuierlich die Spielphase. In der Phase ‚ÄûPLAY‚Äú wird das aktuelle Glyph angezeigt und auf Tastendr√ºcke gepr√ºft. In der Phase ‚ÄûCHECK‚Äú wird das Feedback basierend auf der Aktion des Spielers angezeigt.

   .. code-block:: python

       def main():
           """ Hauptspiel-Schleife. """
           creatGlyph()
           while True:
               if stage == "PLAY":
                   display(arrow[waypoint])
                   getKey()
               elif stage == "CHECK":
                   display(check[waypoint])

#. Diese Funktion bricht alle laufenden Timer ab, wenn das Programm beendet wird, um einen sauberen Abschluss zu gew√§hrleisten.

   .. code-block:: python

       def destroy():
           """ Ressourcen bei Programmende aufr√§umen. """
           global timerPlay, timerCheck
           timerPlay.cancel()  # Spiel-Timer abbrechen
           timerCheck.cancel()  # Checkpoint-Timer abbrechen

#. Das Spiel wird in einem ‚Äûtry‚Äú-Block ausgef√ºhrt. Tritt eine ‚ÄûKeyboardInterrupt‚Äú (wie das Dr√ºcken von Strg+C) auf, f√§ngt es die Ausnahme ab und ruft ‚Äûdestroy‚Äú auf, um vor dem Beenden aufzur√§umen.

   .. code-block:: python

       # Spiel ausf√ºhren, KeyboardInterrupt f√ºr sauberen Ausstieg abfangen
       try:
           main()
       except KeyboardInterrupt:
           destroy()
