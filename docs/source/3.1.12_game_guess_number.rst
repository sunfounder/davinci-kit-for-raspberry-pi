.. note::

    Bonjour, bienvenue dans la communautÃ© SunFounder pour les passionnÃ©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profondÃ©ment dans le monde de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques avec l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & Partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : Recevez en avant-premiÃ¨re les annonces de nouveaux produits et des aperÃ§us exclusifs.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez Ã  des concours et Ã  des promotions spÃ©ciales pendant les fÃªtes.

    ğŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.12 JEU â€“ Devine le Nombre
=================================

Introduction
------------------

"Deviner le Nombre" est un jeu amusant oÃ¹ vous et vos amis tour Ã  tour entrez 
un nombre (0~99). La plage de valeurs se rÃ©duit au fur et Ã  mesure que les 
joueurs entrent des nombres, jusqu'Ã  ce que quelqu'un devine correctement le 
nombre mystÃ¨re. Ce joueur est alors considÃ©rÃ© comme perdant et reÃ§oit une punition. 
Par exemple, si le nombre mystÃ¨re est 51 (non visible par les joueurs), et que 
le joueur â‘  entre 50, la plage de nombres passe Ã  50~99 ; si le joueur â‘¡ entre 70, 
la plage devient 50~70 ; et si le joueur â‘¢ entre 51, ce joueur perd. Ici, nous 
utilisons un clavier pour entrer les nombres et un Ã©cran LCD pour afficher les rÃ©sultats.

Composants
-----------------

.. image:: img/list_GAME_Guess_Number.png
    :align: center

SchÃ©ma de cÃ¢blage
-----------------------

============ ======== ======== =======
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: img/Schematic_three_one12.png
   :align: center

ProcÃ©dures expÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Construire le circuit.

.. image:: img/image273.png
   :alt: Guess Number_bb
   :width: 800

**Ã‰tape 2 :** Configurer I2C (voir l'Annexe. Si vous avez dÃ©jÃ  configurÃ© I2C, 
passez cette Ã©tape.)

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 3 :** Changer de rÃ©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.12/

**Ã‰tape 4 :** Compiler.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.12_GAME_GuessNumber.c -lwiringPi

**Ã‰tape 5 :** ExÃ©cuter.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

AprÃ¨s le dÃ©marrage du programme, l'Ã©cran LCD affiche la page d'accueil :

.. code-block::

   Welcome!
   PressÂ AÂ toÂ go!

Appuyez sur 'A' pour lancer le jeu, et la page de jeu apparaÃ®tra sur l'Ã©cran LCD.

.. code-block::

   Entrez le nombre :
   0 â€¹pointâ€¹ 99

.. note::

   Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur s'affiche : "wiringPi.h: No such file or directory", veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.


Un nombre alÃ©atoire '**point**' est gÃ©nÃ©rÃ© mais non affichÃ© sur l'Ã©cran LCD au 
dÃ©but du jeu, et votre objectif est de le deviner. Le nombre que vous avez saisi 
apparaÃ®t Ã  la fin de la premiÃ¨re ligne jusqu'Ã  ce que le calcul final soit effectuÃ©. 
(Appuyez sur 'D' pour lancer la comparaison, et si le nombre saisi est supÃ©rieur Ã  
**10**, la comparaison se dÃ©clenchera automatiquement.)

La plage de valeurs du '**point**' s'affiche sur la seconde ligne. Vous devez entrer 
un nombre dans cette plage. Ã€ chaque saisie, la plage se rÃ©duit ; si vous trouvez le 
nombre chanceux, ou si vous perdez, l'Ã©cran affichera "Vous avez trouvÃ© !".


**Explication du code**

Au dÃ©but du code, on trouve les fonctions de base pour le **clavier** et l'
**I2C LCD1602**. Vous pouvez en apprendre davantage sur ces Ã©lÃ©ments dans les 
sections **1.1.7 I2C LCD1602** et **2.1.5 Keypad**.

Voici les points clÃ©s Ã  connaÃ®tre :

.. code-block:: c

    /****************************************/
    //DÃ©but du code
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
    Â Â Â Â lcd_init();
    Â Â Â Â lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
    Â Â Â Â }
    Â Â Â Â lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }

Cette fonction initialise l'**I2C LCD1602** et le **clavier** tout en affichant 
"Bienvenue!" et "Appuyez sur A!".

.. code-block:: c

    voidÂ init_new_value(void){
    Â Â Â Â srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }


La fonction gÃ©nÃ¨re un nombre alÃ©atoire '**point**' et rÃ©initialise les limites du jeu.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

La fonction detect_point() compare le nombre saisi avec le "point" gÃ©nÃ©rÃ©. 
Si les nombres sont diffÃ©rents, **count** est utilisÃ© pour ajuster les valeurs 
de **upper** et **lower**, et renvoie '0'. S'ils sont identiques, elle renvoie '1'.

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
    Â Â Â Â lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
    Â Â Â Â Â Â Â Â delay(5000);
    Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â return;
    Â Â Â Â }
    Â Â Â Â write(0,0,"EnterÂ number:");
    Â Â Â Â Int2Str(str,count);
    Â Â Â Â write(13,0,str);
    Â Â Â Â Int2Str(str,lower);
    Â Â Â Â write(0,1,str);
    Â Â Â Â write(3,1,"<Point<");
    Â Â Â Â Int2Str(str,upper);
    Â Â Â Â write(12,1,str);
    }

Cette fonction affiche la page de jeu. La fonction **Int2Str(str,count)** 
convertit les variables **count**, **lower**, et **upper** d'**entier** en 
**chaÃ®ne de caractÃ¨res** pour l'affichage correct sur l'**LCD**.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){Â //whenÂ initializeÂ wiringÂ failed,printÂ messagetoÂ screen
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
    Â Â Â Â }
    Â Â Â Â init();
    Â Â Â Â init_new_value();
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;Â Â Â 
    }





La fonction Main() contient l'ensemble du processus du programme, tel que dÃ©crit ci-dessous :

1) Initialiser l'**I2C LCD1602** et le **clavier**.

2) Utiliser **init_new_value()** pour crÃ©er un nombre alÃ©atoire entre **0 et 99**.

3) VÃ©rifier si un bouton a Ã©tÃ© pressÃ© et lire sa valeur.

4) Si le bouton \'**A**\' est pressÃ©, un nombre alÃ©atoire entre **0 et 99** est 
   gÃ©nÃ©rÃ© et le jeu commence.

5) Si le bouton \'**D**\' est dÃ©tectÃ© comme pressÃ©, le programme passe Ã  l'Ã©tape de 
    comparaison et affiche le rÃ©sultat sur l'Ã©cran LCD. Cette Ã©tape permet Ã©galement 
   de juger le rÃ©sultat en appuyant seulement sur un chiffre et ensuite sur le bouton \'**D**\'.

6) Si un des boutons **0-9** est pressÃ©, la valeur de **count** sera modifiÃ©e ; si 
   **count** est supÃ©rieur Ã  **10**, la comparaison dÃ©marre.

7) Les changements de jeu et leurs valeurs sont affichÃ©s sur l'**LCD1602**.

**Pour les utilisateurs Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 3** : AccÃ©der au rÃ©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**Ã‰tape 4** : ExÃ©cuter le programme.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.12_GAME_GuessNumber.py

AprÃ¨s le dÃ©marrage du programme, la page initiale s'affiche sur l'Ã©cran LCD :

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

Appuyez sur \'A\', et le jeu commencera. La page du jeu apparaÃ®tra sur l'Ã©cran LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Un nombre alÃ©atoire \'**point**\' est gÃ©nÃ©rÃ© mais n'est pas affichÃ© sur l'Ã©cran 
LCD au dÃ©but du jeu, et votre objectif est de le deviner. Le nombre que vous avez 
saisi s'affiche Ã  la fin de la premiÃ¨re ligne jusqu'Ã  ce que le calcul final soit 
terminÃ©. (Appuyez sur \'D\' pour dÃ©marrer la comparaison, et si le nombre saisi 
est supÃ©rieur Ã  **10**, la comparaison automatique commencera.)

L'intervalle de nombres pour \'point\' est affichÃ© sur la seconde ligne. Vous devez 
taper un nombre dans cet intervalle. Ã€ chaque tentative, l'intervalle se rÃ©trÃ©cit ; 
si vous trouvez le nombre chanceux par hasard, l'Ã©cran affichera "Vous avez trouvÃ©!"

**Code**

.. note:: 

   Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. 
   Mais avant cela, vous devez accÃ©der au chemin source du code comme ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

   import RPi.GPIO as GPIO
   import time
   import LCD1602
   import random

   ##################### LIBRAIRIE KEYPAD ADAPTÃ‰E D'ARDUINO ############
   #class Key: DÃ©finition de quelques propriÃ©tÃ©s de Key
   class Keypad():

      def __init__(self, rowsPins, colsPins, keys):
         self.rowsPins = rowsPins
         self.colsPins = colsPins
         self.keys = keys
         GPIO.setwarnings(False)
         GPIO.setmode(GPIO.BCM)
         GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
         GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

      def read(self):
         pressed_keys = []
         for i, row in enumerate(self.rowsPins):
               GPIO.output(row, GPIO.HIGH)
               for j, col in enumerate(self.colsPins):
                  index = i * len(self.colsPins) + j
                  if (GPIO.input(col) == 1):
                     pressed_keys.append(self.keys[index])
               GPIO.output(row, GPIO.LOW)
         return pressed_keys

   ################ DÃ‰BUT DU CODE D'EXEMPLE ################  

   count = 0
   pointValue = 0
   upper=99
   lower=0

   def setup():
      global keypad, last_key_pressed,keys
      rowsPins = [18,23,24,25]
      colsPins = [10,22,27,17]
      keys = ["1","2","3","A",
               "4","5","6","B",
               "7","8","9","C",
               "*","0","#","D"]
      keypad = Keypad(rowsPins, colsPins, keys)
      last_key_pressed = []
      LCD1602.init(0x27, 1)    # init(adresse esclave, lumiÃ¨re de fond)
      LCD1602.clear()
      LCD1602.write(0, 0, 'Welcome!')
      LCD1602.write(0, 1, 'Press A to Start!')

   def init_new_value():
      global pointValue,upper,count,lower
      pointValue = random.randint(0,99)
      upper = 99
      lower = 0
      count = 0
      print('point is %d' %(pointValue))
      

   def detect_point():
      global count,upper,lower
      if count > pointValue:
         if count < upper:
               upper = count 
      elif count < pointValue:
         if count > lower:
               lower = count
      elif count == pointValue:
         count = 0
         return 1
      count = 0
      return 0

   def lcd_show_input(result):
      LCD1602.clear()
      if result == 1:
         LCD1602.write(0,1,'You have got it!')
         time.sleep(5)
         init_new_value()
         lcd_show_input(0)
         return
      LCD1602.write(0,0,'Enter number:')
      LCD1602.write(13,0,str(count))
      LCD1602.write(0,1,str(lower))
      LCD1602.write(3,1,' < Point < ')
      LCD1602.write(13,1,str(upper))

   def loop():
      global keypad, last_key_pressed,count
      while(True):
         result = 0
         pressed_keys = keypad.read()
         if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
               if pressed_keys == ["A"]:
                  init_new_value()
                  lcd_show_input(0)
               elif pressed_keys == ["D"]:
                  result = detect_point()
                  lcd_show_input(result)
               elif pressed_keys[0] in keys:
                  if pressed_keys[0] in list(["A","B","C","D","#","*"]):
                     continue
                  count = count * 10
                  count += int(pressed_keys[0])
                  if count >= 10:
                     result = detect_point()
                  lcd_show_input(result)
               print(pressed_keys)
         last_key_pressed = pressed_keys
         time.sleep(0.1)

   # Fonction pour nettoyer tout aprÃ¨s la fin du script
   def destroy():
      # LibÃ©rer les ressources
      GPIO.cleanup()
      LCD1602.clear() 

   if __name__ == '__main__':     # Le programme commence ici
      try:
         setup()
         while True:
               loop()
      except KeyboardInterrupt:   # Quand 'Ctrl+C' est pressÃ©, la fonction destroy() sera exÃ©cutÃ©e.
         destroy()

**Explication du code**

Au dÃ©but du code, vous trouverez les fonctions liÃ©es au **clavier** et Ã  l'
**I2C LCD1602**. Vous pouvez en savoir plus Ã  leur sujet dans les sections 
**1.1.7 I2C LCD1602** et **2.1.5 Clavier**.

Voici ce qu'il faut savoir :

.. code-block:: python

    defÂ init_new_value():
    Â Â Â Â globalÂ pointValue,upper,count,lower
    Â Â Â Â pointValueÂ =Â random.randint(0,99)
    Â Â Â Â upperÂ =Â 99
    Â Â Â Â lowerÂ =Â 0
    Â Â Â Â countÂ =Â 0
    Â Â Â Â print('pointÂ isÂ %d'Â %(pointValue))

Cette fonction gÃ©nÃ¨re un nombre alÃ©atoire appelÃ© '**point**' et rÃ©initialise 
l'intervalle de recherche.

.. code-block:: python

    defÂ detect_point():
    Â Â Â Â globalÂ count,upper,lower
    Â Â Â Â ifÂ countÂ >Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ <Â upper:
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â countÂ 
    Â Â Â Â elifÂ countÂ <Â pointValue:
    Â Â Â Â Â Â Â Â ifÂ countÂ >Â lower:
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count
    Â Â Â Â elifÂ countÂ ==Â pointValue:
    Â Â Â Â Â Â Â Â countÂ =Â 0
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â countÂ =Â 0
    Â Â Â Â returnÂ 0

La fonction detect_point() compare le nombre saisi (**count**) avec le nombre 
alÃ©atoire '**point**'. Si les nombres ne sont pas identiques, **count** attribue 
de nouvelles valeurs Ã  **upper** et **lower**, et retourne '**0**'. Si les nombres 
sont identiques, la fonction retourne '**1**'.

.. code-block:: python

    defÂ lcd_show_input(result):
        LCD1602.clear()
    Â Â Â Â ifÂ resultÂ ==Â 1:
    Â Â Â Â Â Â Â Â LCD1602.write(0,1,'YouÂ haveÂ gotÂ it!')
            time.sleep(5)
            init_new_value()
            lcd_show_input(0)
            return
    Â Â Â Â LCD1602.write(0,0,'EnterÂ number:')
    Â Â Â Â LCD1602.write(13,0,str(count))
    Â Â Â Â LCD1602.write(0,1,str(lower))
    Â Â Â Â LCD1602.write(3,1,'Â <Â PointÂ <Â ')
    Â Â Â Â LCD1602.write(13,1,str(upper))

Cette fonction affiche l'interface du jeu.

str(count) : Ã‰tant donnÃ© que **write()** ne prend en charge que les chaÃ®nes de 
caractÃ¨res (**string**), il est nÃ©cessaire de convertir le **nombre** en **chaÃ®ne** 
Ã  l'aide de **str()**.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ keypad,Â last_key_pressed,count
        while(True):
    Â Â Â Â Â Â Â Â resultÂ =Â 0
    Â Â Â Â Â Â Â Â pressed_keysÂ =Â keypad.read()
    Â Â Â Â Â Â Â Â ifÂ len(pressed_keys)Â !=Â 0Â andÂ last_key_pressedÂ !=Â pressed_keys:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keysÂ ==Â ["A"]:
                    init_new_value()
                    lcd_show_input(0)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keysÂ ==Â ["D"]:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
                    lcd_show_input(result)
    Â Â Â Â Â Â Â Â Â Â Â Â elifÂ pressed_keys[0]Â inÂ keys:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ pressed_keys[0]Â inÂ list(["A","B","C","D","#","*"]):
                        continue
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ +=Â int(pressed_keys[0])
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ countÂ >=Â 10:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point()
                    lcd_show_input(result)
                print(pressed_keys)
    Â Â Â Â Â Â Â Â last_key_pressedÂ =Â pressed_keys
            time.sleep(0.1)
    

Main() contient l'ensemble du processus du programme, comme dÃ©crit ci-dessous :

1) Initialiser **I2C LCD1602** et **Keypad**.

2) VÃ©rifier si un bouton est pressÃ© et lire sa valeur.

3) Si le bouton '**A**' est pressÃ©, un nombre alÃ©atoire entre **0 et 99** est 
   gÃ©nÃ©rÃ©, et le jeu commence.

4) Si le bouton '**D**' est pressÃ©, le programme effectue la comparaison et 
   dÃ©termine le rÃ©sultat.

5) Si un des boutons **0-9** est pressÃ©, la valeur de **count** est modifiÃ©e. Si
    **count** est supÃ©rieur Ã  **10**, la comparaison commence.

6) Les changements dans le jeu et les valeurs sont affichÃ©s sur l'Ã©cran **LCD1602**.

Photo du phÃ©nomÃ¨ne
------------------------

.. image:: img/image274.jpeg
   :align: center