.. note::

    Bonjour, bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres amateurs.

    **Pourquoi nous rejoindre ?**

    - **Assistance d'experts** : R√©solvez vos probl√®mes apr√®s-vente et surmontez les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des conseils et des tutoriels pour perfectionner vos comp√©tences.
    - **Avant-premi√®res exclusives** : Soyez les premiers inform√©s des nouvelles annonces de produits et d√©couvrez des aper√ßus en exclusivit√©.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des tirages au sort et b√©n√©ficiez de promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _1.3.2_py_pi5:

1.3.2 Servo
==============

Introduction
---------------

Dans ce projet, nous allons apprendre √† faire tourner un servo-moteur.

Composants requis
--------------------

Pour ce projet, nous aurons besoin des composants suivants :

.. image:: ../python_pi5/img/1.3.2_servo_list.png



Sch√©ma de c√¢blage
------------------------

.. image:: ../img/image337.png


Proc√©dures exp√©rimentales
------------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../img/image125.png

**√âtape 2 :** Acc√©dez au dossier contenant le code.
.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3 :** Ex√©cutez le fichier.
.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.2_Servo.py

Apr√®s l'ex√©cution du programme, le servo effectuera une rotation de 0¬∞ √† 90¬∞, puis √† 180¬∞, avant de revenir √† 90¬∞ et enfin √† 0¬∞, en un mouvement cyclique.

.. warning::

    Si le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address`` appara√Æt, consultez :ref:`faq_soc`.

**Code**

.. note::

    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Avant de l'ex√©cuter, assurez-vous de vous rendre dans le r√©pertoire source comme ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s modification, vous pouvez l'ex√©cuter directement pour observer les r√©sultats.
.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import Servo
   from time import sleep

   # D√©finir le num√©ro de la broche GPIO o√π le servo est connect√©
   myGPIO = 18

   # D√©finir un facteur de correction pour ajuster la largeur d'impulsion du servo
   myCorrection = 0.45
   maxPW = (2.0 + myCorrection) / 1000  # Calculer la largeur d'impulsion maximale
   minPW = (1.0 - myCorrection) / 1000  # Calculer la largeur d'impulsion minimale

   # Initialiser l'objet Servo avec des largeurs d'impulsion personnalis√©es
   servo = Servo(myGPIO, min_pulse_width=minPW, max_pulse_width=maxPW)

   try:
       while True:
           # Placer le servo √† la position centrale et attendre
           servo.mid()
           print("mid")  # Indiquer la position actuelle
           sleep(0.5)       # Pause de 0,5 seconde

           # D√©placer le servo √† sa position minimale et attendre
           servo.min()
           print("min")     # Indiquer la position actuelle
           sleep(1)         # Maintenir la position pendant 1 seconde

           # Revenir √† la position centrale et attendre
           servo.mid()
           print("mid")  # Indiquer la position actuelle
           sleep(0.5)       # Pause de 0,5 seconde

           # D√©placer le servo √† sa position maximale et attendre
           servo.max()
           print("max")     # Indiquer la position actuelle
           sleep(1)         # Maintenir la position pendant 1 seconde

   except KeyboardInterrupt:
       # Terminer le script proprement en cas d'interruption clavier (Ctrl+C)
       pass


**Explication du code**

1. Ces instructions importent la classe ``Servo`` pour le contr√¥le du servo et la fonction ``sleep`` pour la temporisation.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import Servo
       from time import sleep

2. D√©finir le num√©ro de la broche GPIO utilis√©e (18) pour connecter le servo.

   .. code-block:: python

       # D√©finir le num√©ro de la broche GPIO o√π le servo est connect√©
       myGPIO = 18

3. Ces lignes d√©finissent un facteur de correction et l'utilisent pour calculer les largeurs d'impulsion maximales et minimales, ajustant ainsi la plage de mouvement du servo.

   .. code-block:: python

       # D√©finir un facteur de correction pour ajuster la largeur d'impulsion du servo
       myCorrection = 0.45
       maxPW = (2.0 + myCorrection) / 1000  # Calculer la largeur d'impulsion maximale
       minPW = (1.0 - myCorrection) / 1000  # Calculer la largeur d'impulsion minimale

4. Initialiser l'objet Servo avec la broche GPIO sp√©cifi√©e et les largeurs d'impulsion d√©finies.

   .. code-block:: python

       # Initialiser l'objet Servo avec des largeurs d'impulsion personnalis√©es
       servo = Servo(myGPIO, min_pulse_width=minPW, max_pulse_width=maxPW)

5. Le bloc `try` contient une boucle `while True` qui d√©place continuellement le servo. Le servo se positionne au centre, aux points minimum et maximum, chaque position √©tant affich√©e et maintenue pendant une dur√©e d√©finie.

   .. code-block:: python

       try:
           while True:
               # Placer le servo √† la position centrale et attendre
               servo.mid()
               print("mid")  # Indiquer la position actuelle
               sleep(0.5)       # Pause de 0,5 seconde

               # D√©placer le servo √† sa position minimale et attendre
               servo.min()
               print("min")     # Indiquer la position actuelle
               sleep(1)         # Maintenir la position pendant 1 seconde

               # Revenir √† la position centrale et attendre
               servo.mid()
               print("mid")  # Indiquer la position actuelle
               sleep(0.5)       # Pause de 0,5 seconde

               # D√©placer le servo √† sa position maximale et attendre
               servo.max()
               print("max")     # Indiquer la position actuelle
               sleep(1)         # Maintenir la position pendant 1 seconde



       except KeyboardInterrupt:
       # Terminer le script proprement en cas d'interruption clavier (Ctrl+C)
       pass
