.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d‚Äôexperts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l‚Äôaide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts exclusifs.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de remises exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des tirages au sort et √† des promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

1.3.1 Moteur
===============

Introduction
---------------

Dans cette le√ßon, nous allons apprendre √† utiliser le L293D pour piloter un moteur 
√† courant continu (DC) et le faire tourner dans le sens horaire et antihoraire. √âtant 
donn√© que le moteur DC n√©cessite un courant plus √©lev√©, nous utilisons le module 
d'alimentation pour alimenter les moteurs en toute s√©curit√©.

Composants
--------------

.. image:: img/list_1.3.1.png


Principe
------------

**L293D**

Le L293D est un circuit int√©gr√© de commande de moteur √† 4 canaux capable de 
supporter des tensions et des courants √©lev√©s. Il est con√ßu pour se connecter 
aux niveaux logiques standard DTL et TTL, et pour piloter des charges inductives 
(telles que des relais, des moteurs DC, des moteurs pas √† pas) ainsi que des 
transistors de commutation de puissance. Les moteurs DC sont des dispositifs qui 
transforment l'√©nergie √©lectrique en √©nergie m√©canique. Ils sont largement utilis√©s 
dans les syst√®mes de commande √©lectrique en raison de leurs excellentes performances 
de r√©gulation de vitesse.

Consultez le sch√©ma des broches ci-dessous. Le L293D dispose de deux broches (Vcc1 et Vcc2) 
pour l'alimentation. Vcc2 est utilis√©e pour alimenter le moteur, tandis que Vcc1 alimente 
la puce. √âtant donn√© que nous utilisons ici un moteur DC de petite taille, connectez les 
deux broches au +5V.

.. image:: img/image111.png


Le sch√©ma ci-dessous montre la structure interne du L293D. La broche EN est une broche 
d'activation et ne fonctionne qu'avec un niveau haut ; A repr√©sente l'entr√©e et Y la 
sortie. Vous pouvez voir la relation entre elles en bas √† droite. Lorsque la broche EN 
est √† un niveau haut, si A est √† un niveau haut, Y d√©livre un niveau haut ; si A est √† 
un niveau bas, Y d√©livre un niveau bas. Lorsque la broche EN est √† un niveau bas, le L293D 
ne fonctionne pas.

.. image:: img/image334.png


**Moteur DC**

.. image:: img/image114.jpeg


Il s'agit d'un moteur DC 5V. Il tourne lorsque l‚Äôon applique des niveaux haut et 
bas sur les deux bornes. Pour plus de commodit√©, vous pouvez souder des broches 
sur ses connecteurs.

.. image:: img/image335.png


**Module d'Alimentation**

Dans cette exp√©rience, il est n√©cessaire d'avoir un courant important pour piloter 
le moteur, en particulier lors des phases de d√©marrage et d'arr√™t, ce qui peut 
interf√©rer avec le bon fonctionnement du Raspberry Pi. Par cons√©quent, nous alimentons 
le moteur s√©par√©ment avec ce module afin qu'il fonctionne de mani√®re stable et s√©curis√©e.

Vous pouvez simplement le brancher sur la plaque d'essai pour fournir l'alimentation. 
Il fournit des tensions de 3,3V et 5V, et vous pouvez s√©lectionner la tension via un 
cavalier inclus.

.. image:: img/image115.png


Sch√©ma de montage
---------------------

Branchez le module d'alimentation sur la plaque d'essai, ins√©rez le cavalier sur la broche 
5V, et il fournira une tension de 5V. Connectez la broche 1 du L293D au GPIO22, et r√©glez-la 
sur un niveau haut. Connectez la broche 2 au GPIO27, et la broche 7 au GPIO17, puis r√©glez 
une broche sur haut, et l'autre sur bas. Ainsi, vous pouvez changer la direction de rotation 
du moteur.

.. image:: img/image336.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/1.3.1.png
    :width: 800

.. note::
    Le module d'alimentation peut √™tre aliment√© par une pile de 9V avec le support de 
    pile inclus dans le kit. Ins√©rez le cavalier du module d'alimentation dans la bande 
    5V de la plaque d'essai.

.. image:: img/image118.jpeg


**√âtape 2 :** Acc√©dez au dossier contenant le code.

.. raw:: html

    <run></run>
    
.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.1/

**√âtape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.1_Motor.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le code est ex√©cut√©, le moteur tourne d'abord dans le sens horaire pendant 
5 secondes, puis s'arr√™te pendant 5 secondes ; ensuite, il tourne dans le sens antihoraire 
pendant 5 secondes, puis s'arr√™te √† nouveau pendant 5 secondes. Cette s√©rie d'actions se 
r√©p√®te continuellement.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur : \"wiringPi.h: Aucun fichier ou r√©pertoire de ce type\", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define MotorPin1       0
    #define MotorPin2       2
    #define MotorEnable     3

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //en cas d'√©chec de l'initialisation de wiringPi, affiche un message d'erreur √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        
        pinMode(MotorPin1, OUTPUT);
        pinMode(MotorPin2, OUTPUT);
        pinMode(MotorEnable, OUTPUT);
        while(1){
            printf("Clockwise\n");
            delay(100);
            digitalWrite(MotorEnable, HIGH);
            digitalWrite(MotorPin1, HIGH);
            digitalWrite(MotorPin2, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Stop\n");
            delay(100);
            digitalWrite(MotorEnable, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Anti-clockwise\n");
            delay(100);
            digitalWrite(MotorEnable, HIGH);
            digitalWrite(MotorPin1, LOW);
            digitalWrite(MotorPin2, HIGH);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Stop\n");
            delay(100);
            digitalWrite(MotorEnable, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    digitalWrite(MotorEnable, HIGH);

Active le L293D.

.. code-block:: c

    digitalWrite(MotorPin1, HIGH);
    digitalWrite(MotorPin2, LOW);

Met un niveau haut pour 2A (broche 7) ; comme 1,2EN (broche 1) est √† 
un niveau haut, 2Y √©mettra un niveau haut.

Met un niveau bas pour 1A, alors 1Y √©mettra un niveau bas, et le moteur 
commencera √† tourner.

.. code-block:: c

    for(i=0;i<3;i++){
    delay(1000);
    }

Cette boucle permet de cr√©er un d√©lai de 3*1000ms.

.. code-block:: c

    digitalWrite(MotorEnable, LOW)

Si 1,2EN (broche 1) est √† un niveau bas, le L293D ne fonctionne pas. Le moteur s'arr√™te.

.. code-block:: c

    digitalWrite(MotorPin1, LOW)
    digitalWrite(MotorPin2, HIGH)

Inverse le sens du courant dans le moteur, ce qui entra√Æne une rotation dans le sens inverse.

