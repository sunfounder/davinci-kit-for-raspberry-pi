.. note::

    Â¡Hola! Bienvenido a la comunidad de entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Ãšnete para profundizar en Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **Â¿Por quÃ© unirte?**

    - **Soporte de Expertos**: Resuelve problemas post-venta y desafÃ­os tÃ©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances Exclusivos**: ObtÃ©n acceso anticipado a anuncios de nuevos productos y vistas previas.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

    ðŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy.

3.1.14 JUEGO â€“ Not Not
===========================

IntroducciÃ³n
--------------------

En esta lecciÃ³n, haremos un dispositivo de juego interesante al que llamamos "Not Not".

Durante el juego, la matriz de puntos mostrarÃ¡ una flecha en una direcciÃ³n aleatoria. Lo que debes hacer es presionar el botÃ³n en la direcciÃ³n opuesta a la flecha dentro de un tiempo limitado. Si el tiempo se acaba o si presionas el botÃ³n en la misma direcciÃ³n que la flecha, pierdes.

Este juego realmente pone a prueba tu pensamiento inverso, Â¿te animas a probarlo?

Componentes
---------------

.. image:: img/list_GAME_Not_Not.png
    :align: center

Diagrama EsquemÃ¡tico
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one14.png
   :align: center

Procedimientos Experimentales
--------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image280.png
    :width: 800


**Para Usuarios de Lenguaje C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Ve a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.14/

**Paso 3**: Compila el cÃ³digo.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

**Paso 4**: Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

DespuÃ©s de que el programa inicie, una flecha aleatoria hacia la izquierda 
o derecha se mostrarÃ¡ en la matriz de puntos. Lo que necesitas hacer es 
presionar el botÃ³n en la direcciÃ³n opuesta a la flecha dentro de un tiempo 
limitado. Luego aparecerÃ¡ un \"**âˆš**\" en la matriz de puntos. Si el tiempo 
se agota o si presionas el botÃ³n en la misma direcciÃ³n que la flecha, pierdes, 
y la matriz de puntos muestra una \"x\". Puedes agregar 2 botones nuevos o 
reemplazarlos con un joystick para incluir las direcciones arriba, abajo, 
izquierda y derecha, y asÃ­ aumentar la dificultad del juego.

.. note::

    Si no funciona despuÃ©s de ejecutarlo, o aparece un mensaje de error: \"wiringPi.h: No such file or directory", consulta :ref:`C code is not working?`.


**ExplicaciÃ³n del CÃ³digo**

Basado en **1.1.6 Matriz de LED**, esta lecciÃ³n aÃ±ade **2** botones para hacer 
un divertido dispositivo de juego. Si no estÃ¡s familiarizado con la matriz de 
puntos, consulta :ref:`1.1.6 LED Dot Matrix`.

El proceso del programa es el siguiente:

1. Selecciona aleatoriamente una direcciÃ³n de flecha y genera **timer 1**.

2. Muestra la imagen de la flecha en la matriz de puntos.

3. EvalÃºa la entrada del botÃ³n. Si se presiona el botÃ³n o **timer 1** 
indica que el tiempo se agotÃ³, comienza la evaluaciÃ³n.

4. Muestra la imagen en la matriz segÃºn el resultado de la evaluaciÃ³n; 
mientras tanto, genera **timer 2**.

5. Vuelve a ejecutar el **paso 1** cuando **timer 2** indique que el tiempo ha terminado.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
        {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
    Â Â Â Â //Â {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
    Â Â Â Â //Â {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},Â Â Â Â 
        {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
        {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
        {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

La estructura GLYPH funciona como un diccionario: el atributo **word** 
corresponde a la **clave** en el diccionario; el atributo **code** 
corresponde al **valor**.

AquÃ­, el cÃ³digo se utiliza para almacenar un array que permite a la matriz 
de puntos mostrar imÃ¡genes (una matriz de 8x8 bits).

El array **arrow** puede usarse para mostrar el patrÃ³n de flechas en las 
direcciones izquierda y derecha en la matriz de LED.

Ahora **down** y **up** estÃ¡n comentadas, y puedes descomentarlas si las 
necesitas.

El array **check** se usa para mostrar estas dos imÃ¡genes: \"**Ã—**\" y \"**âˆš**\".

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
        {
    Â Â Â Â Â Â Â Â if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
            }
        }     
    }

La funciÃ³n **lookup()** trabaja \"consultando el diccionario\". 
Define una **clave**, busca palabras idÃ©nticas en la estructura 
**GLYPH *glyph** y devuelve la informaciÃ³n correspondienteâ€” el 
\"**cÃ³digo**\" de esa palabra.

La funciÃ³n **Strcmp()** se usa para comparar la identidad de dos 
cadenas de caracteres, **glyph[i].word** y **key**; si coincide, 
devuelve **glyph[i].code** (como se muestra).

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
            hc595_in(glyphCode[i]);
    Â Â Â Â Â Â Â Â hc595_in(0x80>>i);
            hc595_out();
        }
    }

Muestra el patrÃ³n especificado en la matriz de puntos.

.. code-block:: c

    voidÂ createGlyph(){
        srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â waypoint=arrow[i].word;
    Â Â Â Â stage="PLAY";
        alarm(2);
    }

La funciÃ³n **createGlyph()** se usa para seleccionar aleatoriamente 
una direcciÃ³n (el atributo word de un elemento en el array **arrow[]:** 
"left", "right"â€¦). Establece el estado como "PLAY" y comienza una funciÃ³n 
de alarma de 2 segundos.

**srand(time(NULL)):** Inicializa semillas aleatorias obtenidas del reloj 
del sistema.

**(sizeof(arrow)/sizeof(arrow[0]))ï¼š** Obtiene la longitud del array, 
siendo el resultado 2.

**rand() % 2:** El resto es **0** o **1**, obtenido al dividir un nÃºmero 
aleatorio generado entre 2.

**waypoint = arrow[i].word:** El resultado es \"right\" o \"left\".

.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
    Â Â Â Â alarm(0)==0;
    Â Â Â Â if(inputKey==waypoint||inputKey=="empty")
        {
    Â Â Â Â Â Â Â Â waypoint="wrong";
        }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â waypoint="right";
        }
    Â Â Â Â stage="CHECK";
        alarm(1);
    }

checkPoint() se usa para verificar la entrada del botÃ³n; si el botÃ³n 
no se presiona o se presiona el botÃ³n en la misma direcciÃ³n que la flecha, 
el resultado es "wrong" y aparece una \"**x**\ en la matriz de puntos. 
De lo contrario, el resultado es "right" y la matriz de puntos muestra \"**âˆš**\". 
AquÃ­ el **stage** es **CHECK,** y se puede establecer una funciÃ³n de alarma 
de 1 segundo.

alarm() tambiÃ©n se conoce como "reloj despertador", en el cual se puede 
configurar un temporizador que envÃ­a seÃ±ales **SIGALRM** al proceso cuando 
se alcanza el tiempo definido.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
    Â Â Â Â {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
    Â Â Â Â {checkPoint("left");}
    }

getKey() lee los estados de estos dos botones; si se presiona el botÃ³n 
derecho, el parÃ¡metro de checkPoint() es **right** y si se presiona el 
botÃ³n izquierdo, el parÃ¡metro es **left**.

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
            checkPoint("empty");
        }
    Â Â Â Â elseÂ if(stage=="CHECK"){
            createGlyph();
        }
    }

Anteriormente, timer() se llamaba cuando se establecÃ­a la funciÃ³n alarm(). 
En el modo \"PLAY\", se llama a checkPoint() para evaluar el resultado. 
Si el programa estÃ¡ en modo \"CHECK\", se llama a createGlyph() para 
seleccionar nuevos patrones.

.. code-block:: c

    voidÂ main(){
        setup();
    Â Â Â Â signal(SIGALRM,timer);
        createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
            {
    Â Â Â Â Â Â Â Â Â Â Â Â code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
                display(code);
                getKey();
            }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
            {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
                display(code);
            }
        }
    }

El funcionamiento de signal(SIGALRM, timer): llama a la funciÃ³n timer() cuando 
se recibe una seÃ±al SIGALRM (generada por la funciÃ³n de alarma).

Cuando el programa inicia, llama a createGlyph() una vez y luego inicia el bucle.

En el bucle: en el modo PLAY, la matriz de puntos muestra patrones de flechas y 
verifica el estado del botÃ³n; si estÃ¡ en el modo CHECK, se muestra \"x\" o \"âˆš\".

**Para Usuarios de Lenguaje Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2**: Accede a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**Paso 3**: Ejecuta el cÃ³digo.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.14_GAME_NotNot.py

Al iniciar el programa, aparecerÃ¡ en la matriz de puntos una flecha 
apuntando a la derecha o a la izquierda. Lo que debes hacer es presionar 
el botÃ³n en la direcciÃ³n opuesta a la flecha dentro de un tiempo limitado. 
Luego, aparecerÃ¡ un \"**âˆš**\" en la matriz de puntos. Si el tiempo se agota 
o si presionas el botÃ³n en la misma direcciÃ³n que la flecha, pierdes y la 
matriz muestra una \"x\". TambiÃ©n puedes agregar 2 botones nuevos o reemplazarlos 
con un joystick para incluir las direcciones arriba, abajo, izquierda y derecha, 
aumentando asÃ­ la dificultad del juego.

**CÃ³digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el cÃ³digo a continuaciÃ³n. Pero antes de eso, debes acceder a la ruta del cÃ³digo fuente como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading
    import random

    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    timerPlay = 0
    timerCheck = 0

    AButtonPin = 20
    BButtonPin = 26

    waypoint = "NULL"
    stage = "NULL"

    arrow={
        #"down" :[0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF],
        #"up":[0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF],
        "right" : [0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF],    
        "left":[0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF]
    }
    check={
        "wrong":[0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF],
        "right":[0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF]
    }

    def setup():
        GPIO.setmode(GPIO.BCM)    # Numera GPIOs segÃºn su ubicaciÃ³n BCM
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        GPIO.output(SDI, GPIO.LOW)
        GPIO.output(RCLK, GPIO.LOW)
        GPIO.output(SRCLK, GPIO.LOW)
        GPIO.setup(AButtonPin,GPIO.IN)
        GPIO.setup(BButtonPin,GPIO.IN)    
    
    # Desplaza los datos hacia 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8): 
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)

    def display(glyphCode):
        for i in range(0, 8):
            hc595_shift(glyphCode[i])
            hc595_shift(0x80>>i)
            GPIO.output(RCLK, GPIO.HIGH)
            GPIO.output(RCLK, GPIO.LOW)

    def creatGlyph():
        global waypoint
        global stage
        global timerPlay    
        waypoint=random.choice(list(arrow.keys()))
        stage = "PLAY"
        timerPlay = threading.Timer(2.0, timeOut)  
        timerPlay.start()  

    def checkPoint(inputKey):
        global waypoint
        global stage
        global timerCheck    
        if inputKey == "empty" or inputKey == waypoint:
            waypoint = "wrong"
        else:
            waypoint = "right"
        timerPlay.cancel()
        stage = "CHECK"
        timerCheck = threading.Timer(1.0, creatGlyph)
        timerCheck.start()  

    def timeOut():  
        checkPoint("empty")

    def getKey():
        if GPIO.input(AButtonPin)==1 and GPIO.input(BButtonPin)==0:
            checkPoint("right")
        elif GPIO.input(AButtonPin)==0 and GPIO.input(BButtonPin)==1:
            checkPoint("left")
        
    def main():
        creatGlyph()
        while True:
            if stage == "PLAY":
                display(arrow[waypoint])
                getKey()
            elif stage == "CHECK":
                display(check[waypoint])

    def destroy():
        global timer1
        GPIO.cleanup()
        timerPlay.cancel()  # cancela el temporizador
        timerCheck.cancel()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**ExplicaciÃ³n del CÃ³digo**

Basado en **1.1.6 Matriz de LED**, esta lecciÃ³n aÃ±ade **2** botones 
para crear un dispositivo de juego divertido. Si no estÃ¡s familiarizado 
con la matriz de puntos, consulta :ref:`1.1.6 LED Dot Matrix`.

El proceso completo del programa es el siguiente:

.. image:: img/notnot3.png
    :width: 800

1. Selecciona aleatoriamente una direcciÃ³n de flecha y genera **timer 1**.

2. Muestra la imagen correspondiente en la matriz de puntos.

3. EvalÃºa la entrada del botÃ³n. Si se presiona el botÃ³n o **timer 1** indica que el tiempo se ha agotado, comienza la evaluaciÃ³n.

4. Muestra la imagen en funciÃ³n del resultado de la evaluaciÃ³n; al mismo tiempo, genera **timer 2**.

5. Vuelve a ejecutar **paso 1** cuando **timer 2** indique que el tiempo ha terminado.

.. code-block:: python

    defÂ main():
        creatGlyph()
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â "PLAY":
                display(arrow[waypoint])
                getKey()
    Â Â Â Â Â Â Â Â elifÂ stageÂ ==Â "CHECK":
                display(check[waypoint])

Main() contiene el proceso completo de ejecuciÃ³n.

Cuando el programa comienza, llama a createGlyph() una vez y luego inicia el bucle.

En el bucle: en el modo PLAY, la matriz de puntos muestra patrones de flechas y 
verifica el estado del botÃ³n; en el modo CHECK, se muestra \"**x**\" o \"**âˆš**\".

.. code-block:: python

    arrow={
    Â Â Â Â #"down"Â :[0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF],
        #"up":[0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF],
    Â Â Â Â "right"Â :Â [0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF],Â Â Â Â 
        "left":[0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF]
    }
    check={
        "wrong":[0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF],
        "right":[0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF]
    }

AquÃ­, el **diccionario** arrow se usa para mostrar el patrÃ³n de flecha en las 
direcciones arriba, abajo, izquierda y derecha en la matriz de LED.

Actualmente, las direcciones abajo y arriba estÃ¡n comentadas; descomÃ©ntalas si 
es necesario.

El **diccionario** check se utiliza para mostrar las imÃ¡genes: \"**Ã—**\" y \"**âˆš**\".

.. code-block:: python

    defÂ display(glyphCode):
    Â Â Â Â forÂ iÂ inÂ range(0,Â 8):
            hc595_shift(glyphCode[i])
            hc595_shift(0x80>>i)
    Â Â Â Â Â Â Â Â GPIO.output(RCLK,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(RCLK,Â GPIO.LOW)

Muestra el patrÃ³n especificado en la matriz de puntos.

.. code-block:: python

    defÂ creatGlyph():
    Â Â Â Â globalÂ waypoint
    Â Â Â Â globalÂ stage
    Â Â Â Â globalÂ timerPlayÂ Â Â Â 
    Â Â Â Â waypoint=random.choice(list(arrow.keys()))
    Â Â Â Â stageÂ =Â "PLAY"
    Â Â Â Â timerPlayÂ =Â threading.Timer(2.0,Â timeOut)Â Â 
        timerPlay.start()

La funciÃ³n **createGlyph()** se usa para seleccionar aleatoriamente una 
direcciÃ³n (el atributo palabra de un elemento en el array **arrow[]:** 
\"**left**\", \"**right**\"...). Configura el estado como \"PLAY\" e inicia 
una funciÃ³n de temporizador de 2 segundos.

**arrow.keys():** Selecciona las claves \"right\" y \"left\" en el array arrow.

**list(arrow.keys()):** Combina estas claves en un array.

**random.choice(list(arrow.keys())):** Selecciona aleatoriamente un elemento en el array.

Por lo tanto, el resultado de **waypoint=random.choice(list(arrow.keys()))** 
deberÃ­a ser \"right\" o \"left\".

.. code-block:: python

    defÂ checkPoint(inputKey):
    Â Â Â Â globalÂ waypoint
    Â Â Â Â globalÂ stage
    Â Â Â Â globalÂ timerCheckÂ Â Â Â 
    Â Â Â Â ifÂ inputKeyÂ ==Â "empty"Â orÂ inputKeyÂ ==Â waypoint:
    Â Â Â Â Â Â Â Â waypointÂ =Â "wrong"
        else:
    Â Â Â Â Â Â Â Â waypointÂ =Â "right"
        timerPlay.cancel()
    Â Â Â Â stageÂ =Â "CHECK"
    Â Â Â Â timerCheckÂ =Â threading.Timer(1.0,Â creatGlyph)
        timerCheck.start()  

checkPoint() detecta el estado actual de la entrada del botÃ³n:

Si no se presiona ningÃºn botÃ³n o se presiona el botÃ³n en la misma direcciÃ³n 
que la flecha, el valor asignado de **``waypoint``** es **``wrong``** y se 
muestra una ``x`` en la matriz de puntos.

De lo contrario, el waypoint es correcto y aparece \"**âˆš**\".

Ahora el estado es **CHECK** e inicia un temporizador de 1 segundo 
**timerCheck** para llamar a la funciÃ³n creatGlyph() en un segundo.

.. code-block:: python

    defÂ timeOut():Â Â 
        checkPoint("empty")

En la funciÃ³n timeOut(), establece el parÃ¡metro de checkPoint() como \"**empty**\".

.. code-block:: python

    defÂ getKey():
    Â Â Â Â ifÂ GPIO.input(AButtonPin)==1Â andÂ GPIO.input(BButtonPin)==0:
            checkPoint("right")
    Â Â Â Â elifÂ GPIO.input(AButtonPin)==0Â andÂ GPIO.input(BButtonPin)==1:
            checkPoint("left")

getKey() lee el estado de estos dos botones, y si se presiona el botÃ³n derecho, 
el parÃ¡metro de checkPoint() es **right**; si se presiona el botÃ³n izquierdo, 
el parÃ¡metro es **left**.

Imagen del FenÃ³meno
------------------------

.. image:: img/image281.jpeg
   :align: center