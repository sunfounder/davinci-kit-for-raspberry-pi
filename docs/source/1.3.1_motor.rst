.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez au c≈ìur du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes post-vente et d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des concours et des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.3.1 Moteur
===============

Introduction
--------------

Dans cette le√ßon, nous apprendrons √† utiliser le L293D pour piloter un moteur √† 
courant continu (DC) et le faire tourner dans le sens horaire et antihoraire. 
Comme le moteur DC n√©cessite un courant plus important, pour des raisons de s√©curit√©, 
nous utilisons ici le module d'alimentation pour alimenter les moteurs.

Composants
------------

.. image:: img/list_1.3.1.png

Principe
-----------

**L293D**

Le L293D est un circuit int√©gr√© de pilote de moteur √† 4 canaux avec haute tension et 
haut courant. Il est con√ßu pour se connecter aux niveaux logiques standards DTL, TTL, 
et pour piloter des charges inductives (comme des relais, moteurs DC, moteurs pas √† pas) 
ainsi que des transistors de commutation de puissance, etc. Les moteurs DC sont des 
dispositifs qui transforment l'√©nergie √©lectrique en √©nergie m√©canique. Ils sont largement 
utilis√©s pour leur excellente performance de r√©gulation de vitesse.

Voyez l'image des broches ci-dessous. Le L293D dispose de deux broches (Vcc1 et Vcc2) pour 
l'alimentation. Vcc2 est utilis√© pour alimenter le moteur, tandis que Vcc1 alimente la puce. 
Comme un petit moteur DC est utilis√© ici, connectez les deux broches au +5V.

.. image:: img/image111.png

L'image suivante montre la structure interne du L293D. La broche EN est une broche 
d'activation et ne fonctionne qu'avec un niveau haut. A repr√©sente l'entr√©e et Y la 
sortie. Vous pouvez voir la relation entre eux en bas √† droite. Lorsque la broche EN 
est √† un niveau haut, si A est √† un niveau haut, Y envoie un niveau haut ; si A est √† 
un niveau bas, Y envoie un niveau bas. Lorsque la broche EN est √† un niveau bas, le 
L293D ne fonctionne pas.

.. image:: img/image334.png

**Moteur DC**

.. image:: img/image114.jpeg

Voici un moteur DC 5V. Il tourne lorsque vous appliquez un niveau haut √† une borne et 
un niveau bas √† l'autre. Pour plus de commodit√©, vous pouvez souder des broches √† ses bornes.

.. image:: img/image335.png

**Module d'alimentation**

Dans cette exp√©rience, il faut des courants importants pour entra√Æner le moteur, surtout 
lors des d√©marrages et arr√™ts, ce qui peut interf√©rer avec le fonctionnement normal du 
Raspberry Pi. Par cons√©quent, nous alimentons s√©par√©ment le moteur via ce module afin 
qu'il fonctionne de mani√®re s√ªre et stable.

Vous pouvez simplement le brancher sur la breadboard pour l'alimenter. Il fournit une 
tension de 3,3V ou 5V, et vous pouvez choisir l'une ou l'autre avec un cavalier inclus.

.. image:: img/image115.png

Sch√©ma de c√¢blage
-----------------------

Branchez le module d'alimentation sur la breadboard et ins√©rez le cavalier sur la broche 
5V pour obtenir une sortie de 5V. Connectez la broche 1 du L293D au GPIO22, et r√©glez-la 
sur un niveau haut. Connectez la broche 2 au GPIO27, et la broche 7 au GPIO17. R√©glez une 
broche sur un niveau haut et l'autre sur un niveau bas. Ainsi, vous pouvez changer la 
direction de rotation du moteur.

.. image:: img/image336.png


Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/1.3.1.png
    :width: 800

.. note::
    Le module d'alimentation peut √™tre utilis√© avec une pile 9V gr√¢ce √† l'attache de 
    pile 9V fournie dans le kit. Ins√©rez le cavalier du module d'alimentation dans les 
    barres d'alimentation 5V de la breadboard.

.. image:: img/image118.jpeg


Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

    <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.1/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.1_Motor.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable ci-dessus.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le code s'ex√©cute, le moteur tourne d'abord dans le sens horaire pendant 
5 secondes, puis s'arr√™te pendant 5 secondes. Ensuite, il tourne dans le sens 
antihoraire pendant 5 secondes, puis s'arr√™te √† nouveau pendant 5 secondes. 
Cette s√©rie d'actions sera ex√©cut√©e en boucle.

.. note::

    Si cela ne fonctionne pas apr√®s ex√©cution ou si un message d'erreur s'affiche : \"wiringPi.h: Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez consulter :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define MotorPin1       0
    #define MotorPin2       2
    #define MotorEnable     3

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //en cas d'√©chec de l'initialisation de wiringPi, affichage du message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        
        pinMode(MotorPin1, OUTPUT);
        pinMode(MotorPin2, OUTPUT);
        pinMode(MotorEnable, OUTPUT);
        while(1){
            printf("Clockwise\n");
            delay(100);
            digitalWrite(MotorEnable, HIGH);
            digitalWrite(MotorPin1, HIGH);
            digitalWrite(MotorPin2, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Stop\n");
            delay(100);
            digitalWrite(MotorEnable, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Anti-clockwise\n");
            delay(100);
            digitalWrite(MotorEnable, HIGH);
            digitalWrite(MotorPin1, LOW);
            digitalWrite(MotorPin2, HIGH);
            for(i=0;i<3;i++){
                delay(1000);
            }

            printf("Stop\n");
            delay(100);
            digitalWrite(MotorEnable, LOW);
            for(i=0;i<3;i++){
                delay(1000);
            }
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    digitalWrite(MotorEnable, HIGH);

Active le L239D.

.. code-block:: c

    digitalWrite(MotorPin1, HIGH);
    digitalWrite(MotorPin2, LOW);

Met un niveau haut pour 2A (broche 7) ; puisque 1,2EN (broche 1) est √† un niveau 
haut, 2Y sortira un niveau haut.

Met un niveau bas pour 1A, alors 1Y sortira un niveau bas, et le moteur tournera.

.. code-block:: c

    for(i=0;i<3;i++){
    delay(1000);
    }

Cette boucle permet un d√©lai de 3 * 1000ms.

.. code-block:: c

    digitalWrite(MotorEnable, LOW)

Si 1,2EN (broche 1) est √† un niveau bas, le L293D ne fonctionne pas. Le moteur s'arr√™te.

.. code-block:: c

    digitalWrite(MotorPin1, LOW)
    digitalWrite(MotorPin2, HIGH)

Inverse le sens du courant dans le moteur, puis le moteur tournera dans le sens inverse.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**√âtape 3 :** Ex√©cutez le code.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.1_Motor.py

Lorsque le code s'ex√©cute, le moteur tourne d'abord dans le sens horaire pendant 5s, 
puis s'arr√™te pendant 5s. Ensuite, il tourne dans le sens antihoraire pendant 5s, 
puis s'arr√™te √† nouveau pendant 5s. Cette s√©rie d'actions sera ex√©cut√©e en boucle.


**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre sur le chemin du code source, par exemple ``davinci-kit-for-raspberry-pi/python``.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import RPi.GPIO as GPIO
    import time
    
    # Configurer les broches
    MotorPin1   = 17
    MotorPin2   = 27
    MotorEnable = 22
    
    def setup():
        # Configurer les modes GPIO selon la num√©rotation BCM
        GPIO.setmode(GPIO.BCM)
        # D√©finir les broches en sortie
        GPIO.setup(MotorPin1, GPIO.OUT)
        GPIO.setup(MotorPin2, GPIO.OUT)
        GPIO.setup(MotorEnable, GPIO.OUT, initial=GPIO.LOW)
    
    # D√©finir une fonction pour faire tourner le moteur
    # La direction doit √™tre 
    # 1(sens horaire), 0(arr√™t), -1(sens antihoraire)
    def motor(direction):
        # Sens horaire
        if direction == 1:
            # Configurer la direction
            GPIO.output(MotorPin1, GPIO.HIGH)
            GPIO.output(MotorPin2, GPIO.LOW)
            # Activer le moteur
            GPIO.output(MotorEnable, GPIO.HIGH)
    		print ("Clockwise")
        # Sens antihoraire
        if direction == -1:
            # Configurer la direction
            GPIO.output(MotorPin1, GPIO.LOW)
            GPIO.output(MotorPin2, GPIO.HIGH)
            # Activer le moteur
            GPIO.output(MotorEnable, GPIO.HIGH)
    		print ("Counterclockwise")
        # Arr√™t
        if direction == 0:
            # D√©sactiver le moteur
            GPIO.output(MotorEnable, GPIO.LOW)
    		print ("Stop")
    
    def main():
    
        # D√©finir un dictionnaire pour rendre le script plus lisible
        # CW pour sens horaire, CCW pour sens antihoraire, STOP pour arr√™t
        directions = {'CW': 1, 'CCW': -1, 'STOP': 0}
        while True:
            # Sens horaire
            motor(directions['CW'])
            time.sleep(5)
            # Arr√™t
            motor(directions['STOP'])
            time.sleep(5)
            # Sens antihoraire
            motor(directions['CCW'])
            time.sleep(5)
            # Arr√™t
            motor(directions['STOP'])
            time.sleep(5)
    
    def destroy():
        # Arr√™ter le moteur
        GPIO.output(MotorEnable, GPIO.LOW)
        # Lib√©rer les ressources
        GPIO.cleanup()    
    
    # Si ce script est ex√©cut√© directement :
    if __name__ == '__main__':
        setup()
        try:
            main()
        # Lorsque 'Ctrl+C' est press√©, la fonction destroy() est ex√©cut√©e.
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    def motor(direction):
        # Sens horaire
        if direction == 1:
            # Configurer la direction
            GPIO.output(MotorPin1, GPIO.HIGH)
            GPIO.output(MotorPin2, GPIO.LOW)
            # Activer le moteur
            GPIO.output(MotorEnable, GPIO.HIGH)
            print ("Clockwise")
    ...

Cr√©ez une fonction, **motor()**, dont la variable est direction. Si la condition 
direction=1 est remplie, le moteur tourne dans le sens horaire ; lorsque direction=-1, 
le moteur tourne dans le sens antihoraire ; et sous la condition direction=0, il s'arr√™te.

.. code-block:: python

    def main():
        # D√©finir un dictionnaire pour rendre le script plus lisible
        # CW pour sens horaire, CCW pour sens antihoraire, STOP pour arr√™t
        directions = {'CW': 1, 'CCW': -1, 'STOP': 0}
        while True:
            # Sens horaire
            motor(directions['CW'])
            time.sleep(5)
            # Arr√™t
            motor(directions['STOP'])
            time.sleep(5)
            # Sens antihoraire
            motor(directions['CCW'])
            time.sleep(5)
            # Arr√™t
            motor(directions['STOP'])
            time.sleep(5)
        
Dans la fonction main(), cr√©ez un tableau directions[], dans lequel CW est √©gal √† 1, 
CCW vaut -1 et 0 repr√©sente l'arr√™t.

Lorsque le code s'ex√©cute, le moteur tourne d'abord dans le sens horaire pendant 
5 secondes, puis s'arr√™te pendant 5 secondes. Ensuite, il tourne dans le sens antihoraire 
pendant 5 secondes, puis s'arr√™te √† nouveau pendant 5 secondes. Cette s√©rie d'actions se r√©p√®te.

Vous devriez maintenant voir la lame du moteur tourner.

Image du ph√©nom√®ne
-----------------------

.. image:: img/image119.jpeg
