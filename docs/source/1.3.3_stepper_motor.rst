.. note::

    Bonjour, bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez au c≈ìur du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes techniques et apr√®s-vente avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Soyez les premiers √† d√©couvrir les nouvelles annonces produits et aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions et concours festifs** : Participez √† des concours et des promotions sp√©ciales pour les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !



1.3.3 Stepper Motor
=======================

Introduction
------------

Les moteurs pas √† pas, gr√¢ce √† leur conception unique, peuvent √™tre contr√¥l√©s avec 
une grande pr√©cision sans m√©canismes de r√©troaction. L'axe d'un moteur pas √† pas, 
mont√© avec une s√©rie d'aimants, est contr√¥l√© par une s√©rie de bobines √©lectromagn√©tiques 
qui sont charg√©es positivement et n√©gativement dans une s√©quence sp√©cifique, le d√©pla√ßant 
pr√©cis√©ment vers l'avant ou l'arri√®re en petits ¬´ pas ¬ª.

Composants
-------------

.. image:: img/list_1.3.3.png


Principe
-----------

**Moteur Pas √† Pas**

Il existe deux types de moteurs pas √† pas : unipolaires et bipolaires, et il est tr√®s 
important de savoir quel type vous utilisez. Dans cette exp√©rience, nous utiliserons 
un moteur pas √† pas unipolaire.

Le moteur pas √† pas est un moteur √† quatre phases qui utilise une alimentation en courant 
continu unipolaire. Tant que vous alimentez toutes les phases du moteur avec une s√©quence 
de synchronisation appropri√©e, vous pouvez le faire tourner √©tape par √©tape. Le sch√©ma d'un 
moteur pas √† pas r√©actif √† quatre phases :

.. image:: img/image129.png


Dans cette figure, au centre du moteur se trouve un rotor - un aimant permanent en forme 
d'engrenage. Autour du rotor, il y a des dents num√©rot√©es de 0 √† 5. Plus √† l'ext√©rieur, 
il y a 8 p√¥les magn√©tiques, avec chaque paire oppos√©e connect√©e par un enroulement de 
bobine. Elles forment ainsi quatre paires de A √† D, appel√©es phases. Il dispose de quatre 
fils de connexion √† brancher sur les interrupteurs SA, SB, SC et SD. Par cons√©quent, les 
quatre phases sont en parall√®le dans le circuit, et les deux p√¥les magn√©tiques d'une phase 
sont en s√©rie.

**Voici comment fonctionne un moteur pas √† pas √† 4 phases :**

Lorsque l'interrupteur SB est activ√©, et que SA, SC et SD sont d√©sactiv√©s, les p√¥les 
magn√©tiques de la phase B s'alignent avec les dents 0 et 3 du rotor. En m√™me temps, les 
dents 1 et 4 forment des dents d√©cal√©es avec les p√¥les des phases C et D. Les dents 2 et 
5 forment des dents d√©cal√©es avec les p√¥les des phases A et D. Lorsque l'interrupteur SC 
est activ√©, et que SB, SA et SD sont d√©sactiv√©s, le rotor tourne sous l'effet du champ 
magn√©tique de l'enroulement de la phase C, faisant aligner les dents 1 et 4 avec les p√¥les 
magn√©tiques de la phase C. Cette situation se r√©p√®te en continu. En activant les phases A, 
B, C et D √† tour de r√¥le, le rotor tourne dans l'ordre des phases A, B, C et D.

.. image:: img/image130.png


Le moteur pas √† pas √† quatre phases a trois modes de fonctionnement : quatre √©tapes simples, 
quatre √©tapes doubles et huit √©tapes. L'angle de pas pour les modes simple et double quatre 
√©tapes est le m√™me, mais le couple moteur est plus faible en simple quatre √©tapes. L'angle 
de pas du mode huit √©tapes est la moiti√© de celui des autres modes, ce qui permet d'am√©liorer 
la pr√©cision de contr√¥le tout en maintenant un couple moteur √©lev√©.

Le stator du moteur pas √† pas que nous utilisons poss√®de 32 p√¥les magn√©tiques, donc un tour 
complet n√©cessite 32 pas. L'arbre de sortie du moteur pas √† pas est connect√© √† un r√©ducteur 
avec un rapport de r√©duction de 1/64. Ainsi, pour que l'arbre de sortie effectue un tour 
complet, il faut 32 * 64 = 2048 pas.

**ULN2003**

Pour utiliser le moteur dans le circuit, une carte pilote est n√©cessaire. Le pilote de 
moteur pas √† pas ULN2003 est un circuit inverseur √† 7 canaux. C'est-√†-dire que lorsque 
la broche d'entr√©e est √† haut niveau, la broche de sortie de l'ULN2003 est √† bas niveau, 
et vice versa. Si nous fournissons un haut niveau √† IN1, et un bas niveau √† IN2, IN3 et 
IN4, alors la sortie OUT1 sera √† bas niveau, et toutes les autres sorties seront √† haut 
niveau.
La structure interne de la puce est illustr√©e ci-dessous.

.. image:: img/image338.png


Le pilote de moteur pas √† pas constitu√© par la puce ULN2003 et 4 LEDs est illustr√© comme 
suit. Sur la carte, les broches IN1, IN2, IN3 et IN4 servent d'entr√©e et les quatre LEDs 
A, B, C, D indiquent l'√©tat des broches d'entr√©e. De plus, les broches OUT1, OUT2, OUT3 
et OUT4 sont connect√©es aux interrupteurs SA, SB, SC et SD du pilote de moteur pas √† pas. 
Lorsque la valeur d'IN1 est d√©finie √† haut niveau, la LED A s'allume, l'interrupteur SA 
est activ√©, et le moteur pas √† pas tourne d'un pas. Ce processus se r√©p√®te √† l'infini. 
Ainsi, en fournissant au moteur pas √† pas une s√©quence de synchronisation sp√©cifique, il 
tournera √©tape par √©tape. L'ULN2003 est utilis√© ici pour fournir des s√©quences de 
synchronisation particuli√®res au moteur pas √† pas.

.. image:: img/image132.png


Sch√©ma √©lectrique
--------------------

.. image:: img/image339.png


Proc√©dures Exp√©rimentales
---------------------------

**√âtape 1:** Construisez le circuit.

.. image:: img/image134.png
    :width: 800


Pour les Utilisateurs du Langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2**: Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.3/

**√âtape 3**: Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.3_StepperMotor.c -lwiringPi

**√âtape 4**: Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le code s'ex√©cute, le moteur pas √† pas tournera dans le sens horaire 
ou antihoraire selon votre entr√©e 'a' ou 'c'.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur appara√Æt : \"wiringPi.h: Aucun fichier ou r√©pertoire de ce type\", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <stdio.h>
    #include <wiringPi.h>

    const int motorPin[] = {1, 4, 5, 6};
    int rolePerMinute = 15;
    int stepsPerRevolution = 2048;
    int stepSpeed = 0;

    void rotary(char direction){
        if(direction == 'c'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99>>j & (0x08>>i));}
                delayMicroseconds(stepSpeed);
            }        
        }
        else if(direction =='a'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99<<j & (0x80>>i));}
                delayMicroseconds(stepSpeed);
            }   
        }
    }

    void loop()
    {
        char direction = '0';
        while (1)
        {       
            printf("select motor direction a=anticlockwise, c=clockwise: ");
            delay(100);
            direction=getchar();
            if (direction == 'c')
            {
                printf("motor running clockwise\n");
                delay(100);
                break;
            }
            else if (direction == 'a')
            {
                printf("motor running anti-clockwise\n");
                delay(100);
                break;
            }
            else
            {
                printf("input error, please try again!\n");
                delay(100);
            }
        }
        while(1)
        {
            rotary(direction);
        }
    }

    void main(void)
    {
        if (wiringPiSetup() == -1)
        {
            printf("setup wiringPi failed !");
            return;
        }
        for (int i = 0; i < 4; i++)
        {
            pinMode(motorPin[i], OUTPUT);
        }
        stepSpeed = (60000000 / rolePerMinute) / stepsPerRevolution;
        loop();
    }
**Explication du Code**

.. code-block:: c

    int rolePerMinute = 15;
    int stepsPerRevolution = 2048;
    int stepSpeed = 0;

**rolePerMinute :** r√©volutions par minute, la vitesse du moteur pas √† pas utilis√©e 
dans ce kit doit √™tre comprise entre 0 et 17 RPM.

**stepsPerRevolution :** le nombre de pas pour chaque tour. Le moteur pas √† pas 
utilis√© dans ce kit n√©cessite 2048 pas par r√©volution.

**stepSpeed :** le temps utilis√© pour chaque pas. Dans la fonction main(), on 
attribue les valeurs avec la formule : „Äå(60000000 / rolePerMinute) / stepsPerRevolution„Äç
(60 000 000 ¬µs = 1 minute).

.. code-block:: c

    void loop()
    {
        char direction = '0';
        while (1)
        {       
            printf("select motor direction a=anticlockwise, c=clockwise: ");
            direction=getchar();
            if (direction == 'c')
            {
                printf("motor running clockwise\n");
                break;
            }
            else if (direction == 'a')
            {
                printf("motor running anti-clockwise\n");
                break;
            }
            else
            {
                printf("input error, please try again!\n");
            }
        }
        while(1)
        {
            rotary(direction);
        }
    }

La fonction **loop()** est divis√©e en deux parties (entre deux `while(1)`) :

La premi√®re partie r√©cup√®re la valeur de la touche. Quand 'a' ou 'c' est re√ßu, on quitte la boucle et on arr√™te l'entr√©e.

La seconde partie appelle **rotary(direction)** pour faire tourner le moteur pas √† pas.

.. code-block:: c

    void rotary(char direction){
        if(direction == 'c'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99>>j & (0x08>>i));}
                delayMicroseconds(stepSpeed);
            }        
        }
        else if(direction =='a'){
            for(int j=0;j<4;j++){
                for(int i=0;i<4;i++)
                    {digitalWrite(motorPin[i],0x99<<j & (0x80>>i));}
                delayMicroseconds(stepSpeed);
            }   
        }
    }

Pour faire tourner le moteur pas √† pas **dans le sens horaire**, l'√©tat de niveau 
des broches moteur (motorPin) est pr√©sent√© dans le tableau ci-dessous :

.. image:: img/image340.png


L'√©criture des niveaux des broches **motorPin** est r√©alis√©e √† l'aide d'une double boucle `for`.

**√âtape 1**, j=0, i=0~4.

motorPin[0] sera √©crit en niveau hautÔºà10011001&00001000=1Ôºâ

motorPin[1] sera √©crit en niveau basÔºà10011001&00000100=0Ôºâ

motorPin[2] sera √©crit en niveau basÔºà10011001&00000010=0Ôºâ

motorPin[3] sera √©crit en niveau hautÔºà10011001&00000001=1Ôºâ

**√âtape 2**, j=1, i=0~4.

motorPin[0] sera √©crit en niveau hautÔºà01001100&00001000=1Ôºâ

motorPin[1] sera √©crit en niveau basÔºà01001100&00000100=1Ôºâ

etc.

Pour faire tourner le moteur pas √† pas **dans le sens antihoraire**, l'√©tat de niveau des broches moteur est pr√©sent√© dans le tableau suivant.

.. image:: img/image341.png

**√âtape 1**, j=0, i=0~4.

motorPin[0] sera √©crit en niveau hautÔºà10011001&10000000=1Ôºâ

motorPin[1] sera √©crit en niveau basÔºà10011001&01000000=0Ôºâ

**√âtape 2**, j=1, i=0~4.

motorPin[0] sera √©crit en niveau hautÔºà00110010&10000000=0Ôºâ

motorPin[1] sera √©crit en niveau basÔºà00110010&01000000=0Ôºâ

etc.


Pour les Utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2**: Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3**: Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.3_StepperMotor.py

Lorsque le code s'ex√©cute, le moteur pas √† pas tournera dans le sens horaire ou 
antihoraire selon votre entr√©e 'a' ou 'c'.
**Explication du Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source, tel que ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    from time import sleep

    motorPin = (18,23,24,25) 
    rolePerMinute =15
    stepsPerRevolution = 2048
    stepSpeed = (60/rolePerMinute)/stepsPerRevolution

    def setup():
        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)
        for i in motorPin:
            GPIO.setup(i, GPIO.OUT)

    def rotary(direction):
        if(direction == 'c'):   
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99>>j & (0x08>>i))
                sleep(stepSpeed)

        elif(direction == 'a'):
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99<<j & (0x80>>i))
                sleep(stepSpeed)

    def loop():
        while True:
            direction = input('select motor direction a=anticlockwise, c=clockwise: ')
            if(direction == 'c'):
                print('motor running clockwise\n')
                break
            elif(direction == 'a'):
                print('motor running anti-clockwise\n')
                break
            else:
                print('input error, please try again!')
        while True:
            rotary(direction)

    def destroy():
        GPIO.cleanup()   

    if __name__ == '__main__':    
        setup()
        try:
            loop()        
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    rolePerMinute =15
    stepsPerRevolution = 2048
    stepSpeed = (60/rolePerMinute)/stepsPerRevolution

**rolePerMinute :** r√©volutions par minute, la vitesse du moteur pas √† pas dans 
ce kit devrait √™tre comprise entre 0 et 17 RPM.

**stepsPerRevolution :** le nombre de pas pour chaque tour, le moteur pas √† pas de 
ce kit n√©cessite 2048 pas par r√©volution.

**stepSpeed :** le temps utilis√© pour chaque pas, et nous leur attribuons les valeurs 
suivantes :„Äå(60 / rolePerMinute) / stepsPerRevolution„Äç(60s = 1 minute).

.. code-block:: python

    def loop():
        while True:
            direction = input('select motor direction a=anticlockwise, c=clockwise: ')
            if(direction == 'c'):
                print('motor running clockwise\n')
                break
            elif(direction == 'a'):
                print('motor running anti-clockwise\n')
                break
            else:
                print('input error, please try again!')
        while True:
            rotary(direction)

La fonction **loop()** est divis√©e en deux parties (situ√©es dans deux `while(1)`) :

La premi√®re partie consiste √† r√©cup√©rer la valeur de la touche. Lorsque 'a' ou 'c' est obtenu, on quitte la boucle et arr√™te l'entr√©e.

La seconde partie appelle la fonction **rotary(direction)** pour faire tourner le moteur pas √† pas.

.. code-block:: python

    def rotary(direction):
        if(direction == 'c'):   
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99>>j & (0x08>>i))
                sleep(stepSpeed)

        elif(direction == 'a'):
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99<<j & (0x80>>i))
                sleep(stepSpeed)

Pour faire tourner le moteur pas √† pas **dans le sens horaire**, l'√©tat de niveau des 
broches motorPin est pr√©sent√© dans le tableau suivant :

.. image:: img/image342.png

Par cons√©quent, l'√©criture des niveaux des broches **motorPin** est r√©alis√©e √† l'aide 
d'une boucle **for** √† deux niveaux.

Dans **√âtape 1**, j=0, i=0~4.

motorPin[0] sera en niveau hautÔºà10011001&00001000=1Ôºâ

motorPin[1] sera en niveau basÔºà10011001&00000100=0Ôºâ

motorPin[2] sera en niveau basÔºà10011001&00000010=0Ôºâ

motorPin[3] sera en niveau hautÔºà10011001&00000001=1Ôºâ

Dans **√âtape 2**, j=1, i=0~4.

motorPin[0] sera en niveau hautÔºà01001100&00001000=1Ôºâ

motorPin[1] sera en niveau basÔºà01001100&00000100=1Ôºâ

et ainsi de suite.

Pour faire tourner le moteur pas √† pas **dans le sens antihoraire**, l'√©tat de niveau 
des broches motorPin est pr√©sent√© dans le tableau suivant.

.. image:: img/image343.png

Dans **√âtape 1**, j=0, i=0~4.

motorPin[0] sera en niveau hautÔºà10011001&10000000=1Ôºâ

motorPin[1] sera en niveau basÔºà10011001&01000000=0Ôºâ

Dans **√âtape 2**, j=1, i=0~4.

motorPin[0] sera en niveau hautÔºà00110010&10000000=0Ôºâ

motorPin[1] sera en niveau basÔºà00110010&01000000=0Ôºâ

et ainsi de suite.


Image de R√©sultat
------------------
.. image:: img/image135.jpeg
