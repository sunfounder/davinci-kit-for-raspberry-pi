.. note::

    Bonjour et bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et des promotions √† l'occasion des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.3 DHT-11
===============

Introduction
----------------

Le capteur num√©rique de temp√©rature et d'humidit√© DHT11 est un capteur composite 
qui fournit un signal de sortie num√©rique calibr√© de temp√©rature et d'humidit√©. 
La technologie de collecte de modules num√©riques d√©di√©s et celle de d√©tection de 
temp√©rature et d'humidit√© sont appliqu√©es pour garantir une haute fiabilit√© et une 
excellente stabilit√© du produit.

Le capteur inclut un capteur d'humidit√© r√©sistif et un capteur de temp√©rature CTN, 
tous deux connect√©s √† un microcontr√¥leur 8 bits haute performance.

Composants
------------

.. image:: img/list_2.2.3_dht-11.png


Principe
-----------

Le DHT11 est un capteur num√©rique de temp√©rature et d'humidit√© basique et √† tr√®s faible 
co√ªt. Il utilise un capteur capacitif pour l'humidit√© et une thermistance pour mesurer 
l'air environnant, puis il envoie un signal num√©rique via la broche de donn√©es (aucune 
broche d'entr√©e analogique n'est n√©cessaire).

.. image:: img/image205.png
    :width: 200


Il dispose de seulement trois broches : VCC, GND et DATA. Le processus de communication 
commence lorsque la ligne de donn√©es (DATA) envoie des signaux de d√©marrage au DHT11, 
et le DHT11 re√ßoit ces signaux et renvoie un signal de r√©ponse. Ensuite, l'h√¥te re√ßoit 
le signal de r√©ponse et commence √† recevoir 40 bits de donn√©es (8 bits pour l'humidit√© 
enti√®re + 8 bits pour l'humidit√© d√©cimale + 8 bits pour la temp√©rature enti√®re + 8 bits 
pour la temp√©rature d√©cimale + 8 bits de contr√¥le de parit√©). Pour plus d'informations, 
veuillez vous r√©f√©rer √† la fiche technique du DHT11.

Sch√©ma de c√¢blage
---------------------

.. image:: img/image326.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image207.png
    :width: 800


**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.3/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.3_DHT.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du programme, la temp√©rature et l'humidit√© d√©tect√©es par le DHT11 
seront affich√©es sur l'√©cran de l'ordinateur.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou s'il y a un message d'erreur indiquant : ¬´ wiringPi.h : Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>

    #define maxTim 85
    #define dhtPin 0

    int dht11_dat[5] = {0,0,0,0,0};

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // Fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // Tirer la broche vers le bas pendant 18 millisecondes
        pinMode(dhtPin, OUTPUT);
        digitalWrite(dhtPin, LOW);
        delay(18);
        // Puis tirer la broche vers le haut pendant 40 microsecondes
        digitalWrite(dhtPin, HIGH);
        delayMicroseconds(40); 
        // Pr√©parer la lecture de la broche
        pinMode(dhtPin, INPUT);

        // D√©tecter les changements et lire les donn√©es
        for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);

            if (counter == 255) break;
            // Ignorer les 3 premi√®res transitions
            if ((i >= 4) && (i%2 == 0)) {
                // Ins√©rer chaque bit dans les octets de stockage
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }
        // V√©rifier que nous avons lu 40 bits (8 bits x 5) et v√©rifier le checksum dans le dernier octet
        // Afficher les r√©sultats si les donn√©es sont valides
        if ((j >= 40) && 
                (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
            Fah = dht11_dat[2] * 9. / 5. + 32;
            printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                    dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
        }
    }

    int main (void) {
        if(wiringPiSetup() == -1){ // En cas d'√©chec d'initialisation de wiringPi, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1; 
        }
        while (1) {
            readDht11();
            delay(500); // attendre 1 seconde pour actualiser
        }
        return 0 ;
    }

**Explication du Code**

.. code-block:: c

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // Fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // ...
    }

Cette fonction est utilis√©e pour impl√©menter le fonctionnement du DHT11.

Elle peut g√©n√©ralement √™tre divis√©e en 3 parties :

1. Pr√©paration de la broche pour la lecture :

.. code-block:: c

    // Tirer la broche vers le bas pendant 18 millisecondes
    pinMode(dhtPin, OUTPUT);
    digitalWrite(dhtPin, LOW);
    delay(18);
    // Puis tirer la broche vers le haut pendant 40 microsecondes
    digitalWrite(dhtPin, HIGH);
    delayMicroseconds(40); 
    // Pr√©parer la lecture de la broche
    pinMode(dhtPin, INPUT);

Le flux de communication est d√©termin√© par la synchronisation du fonctionnement.

.. image:: img/image208.png
    :width: 800


Lorsque le DHT11 d√©marre, le MCU envoie un signal de niveau bas, puis maintient le 
signal √† un niveau haut pendant 40 microsecondes. Apr√®s cela, la d√©tection des conditions 
de l'environnement externe commence.

2. Lecture des donn√©es :

.. code-block:: c

    // d√©tecter les changements et lire les donn√©es  
    for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);
            if (counter == 255) break;
            // ignorer les 3 premi√®res transitions
            if ((i >= 4) && (i%2 == 0)) {
                // ins√©rer chaque bit dans les octets de stockage
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }

La boucle stocke les donn√©es d√©tect√©es dans le tableau dht11_dat[]. Le DHT11 
transmet des donn√©es par blocs de 40 bits. Les 16 premiers bits sont li√©s √† 
l'humidit√©, les 16 bits interm√©diaires sont li√©s √† la temp√©rature, et les 8 
derniers bits sont utilis√©s pour la v√©rification. Le format des donn√©es est :

**8 bits de donn√©es enti√®res pour l'humidit√©** + **8 bits de donn√©es d√©cimales 
pour l'humidit√©** + **8 bits de donn√©es enti√®res pour la temp√©rature** + **8 bits 
de donn√©es d√©cimales pour la temp√©rature** + **8 bits de bit de contr√¥le**.

3. Affichage de l'humidit√© et de la temp√©rature.

.. code-block:: c

    // v√©rifier que nous avons bien lu 40 bits (8 bits x 5) + v√©rifier le checksum dans le dernier octet
    // afficher si les donn√©es sont correctes
    if ((j >= 40) && 
            (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
        Fah = dht11_dat[2] * 9. / 5. + 32;
        printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
    }

Lorsque le stockage des donn√©es atteint 40 bits, v√©rifiez la validit√© des donn√©es 
√† l'aide du **bit de contr√¥le (dht11_dat[4])**, puis affichez la temp√©rature et l'humidit√©.

Par exemple, si les donn√©es re√ßues sont : 00101011 (valeur enti√®re de l'humidit√© 
sur 8 bits) 00000000 (valeur d√©cimale de l'humidit√© sur 8 bits) 00111100 (valeur 
enti√®re de la temp√©rature sur 8 bits) 00000000 (valeur d√©cimale de la temp√©rature 
sur 8 bits) 01100111 (bit de contr√¥le)

**Calcul :**

00101011+00000000+00111100+00000000=01100111.

Le r√©sultat final est √©gal au bit de contr√¥le, ce qui signifie que les donn√©es 
re√ßues sont correctes :

Humidit√© = 43 %, Temp√©rature = 60 ¬∞C.

Si ce n'est pas √©gal au bit de contr√¥le, la transmission des donn√©es n'est pas 
correcte et les donn√©es doivent √™tre re√ßues √† nouveau.
