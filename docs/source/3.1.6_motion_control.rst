.. note::

    Bonjour et bienvenue dans la communautÃ© SunFounder pour les passionnÃ©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez vos problÃ¨mes aprÃ¨s-vente et vos dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & Partager** : Ã‰changez des astuces et des tutoriels pour perfectionner vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us exclusifs.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des concours et Ã  des promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.6 ContrÃ´le de mouvement
==============================

Introduction
----------------

Dans cette leÃ§on, nous allons crÃ©er un dispositif simple de dÃ©tection et de contrÃ´le 
de mouvement. Le MPU6050 est utilisÃ© comme capteur et le moteur pas Ã  pas comme dispositif 
contrÃ´lÃ©. En fixant le MPU6050 sur un gant, vous pouvez contrÃ´ler le moteur pas Ã  pas en 
faisant pivoter votre poignet.

Composants
-------------

.. image:: img/list_Motion_Control.png
    :align: center

SchÃ©ma de cÃ¢blage
---------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one6.png
   :align: center

ProcÃ©dures expÃ©rimentales
----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: img/image251.png
   :width: 800
   :align: center

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.6/

**Ã‰tape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.6_MotionControl.c -lwiringPi -lm

**Ã‰tape 4 :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'exÃ©cute, si l'angle d'inclinaison du **mpu6050** sur l'axe 
`Y <https://cn.bing.com/dict/search?q=Y&FORM=BDVSP6&mkt=zh-cn>`__-`axis <https://cn.bing.com/dict/search?q=axis&FORM=BDVSP6&mkt=zh-cn>`__ 
dÃ©passe **45** Â°, le moteur pas Ã  pas tourne dans le sens antihoraire ; s'il est infÃ©rieur Ã  **-45** Â°, 
le moteur tourne dans le sens horaire.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur apparaÃ®t : \"wiringPi.h: Aucun fichier ou dossier de ce type Â», veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.

**Explication du code**

.. code-block:: c

    doubleÂ mpu6050(){
    Â Â Â Â acclXÂ =Â read_word_2c(0x3B);
    Â Â Â Â acclYÂ =Â read_word_2c(0x3D);
    Â Â Â Â acclZÂ =Â read_word_2c(0x3F);
    Â Â Â Â acclX_scaledÂ =Â acclXÂ /Â 16384.0;
    Â Â Â Â acclY_scaledÂ =Â acclYÂ /Â 16384.0;
    Â Â Â Â acclZ_scaledÂ =Â acclZÂ /Â 16384.0;
    Â Â Â Â doubleÂ angle=get_y_rotation(acclX_scaled,Â acclY_scaled,Â acclZ_scaled);
    Â Â Â Â returnÂ angle;
    }

La fonction `mpu6050` obtient l'angle d'inclinaison dans la direction de l'axe Y.

.. code-block:: c

    voidÂ rotary(charÂ direction){
    Â Â Â Â if(directionÂ ==Â 'c'){
    Â Â Â Â Â Â Â Â for(intÂ j=0;j<4;j++){
    Â Â Â Â Â Â Â Â Â Â Â Â for(intÂ i=0;i<4;i++)
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {digitalWrite(motorPin[i],0x99>>jÂ &Â (0x08>>i));}
    Â Â Â Â Â Â Â Â Â Â Â Â delayMicroseconds(stepSpeed);
    Â Â Â Â Â Â Â Â }Â Â Â Â Â Â Â Â 
    Â Â Â Â }
    Â Â Â Â elseÂ if(directionÂ =='a'){
    Â Â Â Â Â Â Â Â for(intÂ j=0;j<4;j++){
    Â Â Â Â Â Â Â Â Â Â Â Â for(intÂ i=0;i<4;i++)
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {digitalWrite(motorPin[i],0x99<<jÂ &Â (0x80>>i));}
    Â Â Â Â Â Â Â Â Â Â Â Â delayMicroseconds(stepSpeed);
    Â Â Â Â Â Â Â Â }Â Â Â 
    Â Â Â Â }
    }

Si la **touche** de direction reÃ§ue est '**c**', le moteur pas Ã  pas tourne dans le sens 
horaire ; si la **touche** est '**a**', le moteur tourne dans le sens antihoraire. Pour 
plus de dÃ©tails sur le calcul de la direction de rotation du moteur pas Ã  pas, rÃ©fÃ©rez-vous 
Ã  :ref:`1.3.3 Stepper Motor`.

.. code-block:: c

    intÂ main()
    {
    Â Â Â Â setup();
    Â Â Â Â doubleÂ angle;
    Â Â Â Â while(1)Â {
    Â Â Â Â Â Â Â Â angleÂ =Â mpu6050();
    Â Â Â Â Â Â Â Â ifÂ (angleÂ >=45){rotary('a');}
    Â Â Â Â Â Â Â Â elseÂ ifÂ (angle<=-45){rotary('c');}
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

L'angle d'inclinaison dans la direction de l'axe Y est lu depuis **mpu6050**, 
et s'il est supÃ©rieur Ã  **45** Â°, le moteur pas Ã  pas tourne dans le sens 
antihoraire ; s'il est infÃ©rieur Ã  **-45** Â°, le moteur tourne dans le sens horaire.

**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Ã‰tape 3 :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.6_MotionControl.py

Lorsque le code s'exÃ©cute, si l'angle d'inclinaison du **mpu6050** sur l'axe 
`Y <https://cn.bing.com/dict/search?q=Y&FORM=BDVSP6&mkt=zh-cn>`__ **-** `axis <https://cn.bing.com/dict/search?q=axis&FORM=BDVSP6&mkt=zh-cn>`__ 
dÃ©passe **45** Â°, le moteur pas Ã  pas tourne dans le sens antihoraire ; s'il est infÃ©rieur Ã  **-45** Â°, le moteur tourne dans le sens horaire.

**Code**

.. note::

    Vous pouvez **modifier/rÃ©initialiser/copier/exÃ©cuter/arrÃªter** le code ci-dessous. Mais avant cela, vous devez vous rendre sur le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import smbus
    import math
    import time



    # Power management registers
    power_mgmt_1 = 0x6b
    power_mgmt_2 = 0x6c

    bus = smbus.SMBus(1) 
    address = 0x68     
    bus.write_byte_data(address, power_mgmt_1, 0)

    #Stepper motor pins
    motorPin = (18,23,24,25) 
    rolePerMinute =15
    stepsPerRevolution = 2048
    stepSpeed = (60/rolePerMinute)/stepsPerRevolution

    #mpu6050
    def read_byte(adr):
        return bus.read_byte_data(address, adr)

    def read_word(adr):
        high = bus.read_byte_data(address, adr)
        low = bus.read_byte_data(address, adr+1)
        val = (high << 8) + low
        return val

    def read_word_2c(adr):
        val = read_word(adr)
        if (val >= 0x8000):
            return -((65535 - val) + 1)
        else:
            return val

    def dist(a,b):
        return math.sqrt((a*a)+(b*b))

    def get_y_rotation(x,y,z):
        radians = math.atan2(x, dist(y,z))
        return -math.degrees(radians)

    def get_x_rotation(x,y,z):
        radians = math.atan2(y, dist(x,z))
        return math.degrees(radians)

    def mpu6050():
        accel_xout = read_word_2c(0x3b)
        accel_yout = read_word_2c(0x3d)
        accel_zout = read_word_2c(0x3f)
        accel_xout_scaled = accel_xout / 16384.0
        accel_yout_scaled = accel_yout / 16384.0
        accel_zout_scaled = accel_zout / 16384.0
        angle=get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled)
        return angle

    #Stepper Motor
    def rotary(direction):
        if(direction == 'c'):   
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99>>j & (0x08>>i))
                time.sleep(stepSpeed)

        elif(direction == 'a'):
            for j in range(4):
                for i in range(4):
                    GPIO.output(motorPin[i],0x99<<j & (0x80>>i))
                time.sleep(stepSpeed)

    
    def setup():
        GPIO.setwarnings(False)
        GPIO.setmode(GPIO.BCM)
        for i in motorPin:
            GPIO.setup(i, GPIO.OUT)

    def loop():
        while True:
            angle=mpu6050()
            if angle >=45 :
                rotary('a')
            elif angle <=-45:
                rotary('c')

    def destroy():
        GPIO.cleanup()   

    if __name__ == '__main__':    
        setup()
        try:
            loop()        
        except KeyboardInterrupt:
            destroy()

**Explication du code**

.. code-block:: python

    defÂ mpu6050():
    Â Â Â Â accel_xoutÂ =Â read_word_2c(0x3b)
    Â Â Â Â accel_youtÂ =Â read_word_2c(0x3d)
    Â Â Â Â accel_zoutÂ =Â read_word_2c(0x3f)
    Â Â Â Â accel_xout_scaledÂ =Â accel_xoutÂ /Â 16384.0
    Â Â Â Â accel_yout_scaledÂ =Â accel_youtÂ /Â 16384.0
    Â Â Â Â accel_zout_scaledÂ =Â accel_zoutÂ /Â 16384.0
    Â Â Â Â angle=get_y_rotation(accel_xout_scaled,Â accel_yout_scaled,Â accel_zout_scaled)
    Â Â Â Â returnÂ angle

La fonction `mpu6050` obtient l'angle d'inclinaison dans la direction de l'axe Y.

.. code-block:: python

    defÂ rotary(direction):
    Â Â Â Â if(directionÂ ==Â 'c'):Â Â Â 
    Â Â Â Â Â Â Â Â forÂ jÂ inÂ range(4):
    Â Â Â Â Â Â Â Â Â Â Â Â forÂ iÂ inÂ range(4):
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â GPIO.output(motorPin[i],0x99>>jÂ &Â (0x08>>i))
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(stepSpeed)

    Â Â Â Â elif(directionÂ ==Â 'a'):
    Â Â Â Â Â Â Â Â forÂ jÂ inÂ range(4):
    Â Â Â Â Â Â Â Â Â Â Â Â forÂ iÂ inÂ range(4):
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â GPIO.output(motorPin[i],0x99<<jÂ &Â (0x80>>i))
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(stepSpeed)

Si la **touche** de direction reÃ§ue est '**c**', le moteur pas Ã  pas tourne dans 
le sens horaire ; si la **touche** est '**a**', le moteur tourne dans le sens 
antihoraire. Pour plus de dÃ©tails sur le calcul de la direction de rotation du 
moteur pas Ã  pas, rÃ©fÃ©rez-vous Ã  :ref:`1.3.3 Stepper Motor`.

.. code-block:: python

    defÂ loop():
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â angle=mpu6050()
    Â Â Â Â Â Â Â Â ifÂ angleÂ >=45Â :
    Â Â Â Â Â Â Â Â Â Â Â Â rotary('a')
    Â Â Â Â Â Â Â Â elifÂ angleÂ <=-45:
    Â Â Â Â Â Â Â Â Â Â Â Â rotary('c')

L'angle d'inclinaison dans la direction de l'**axe Y** est lu depuis **mpu6050**, et 
s'il est supÃ©rieur Ã  **45** Â°, la fonction `rotary()` est appelÃ©e pour faire tourner 
le moteur pas Ã  pas dans le sens antihoraire ; s'il est infÃ©rieur Ã  **-45** Â°, le moteur 
tourne dans le sens horaire.

Image du phÃ©nomÃ¨ne
----------------------

.. image:: img/image252.jpeg
   :align: center