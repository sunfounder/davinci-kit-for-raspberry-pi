.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte experto**: Resuelve problemas post-venta y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Acceso exclusivo**: Obt√©n acceso anticipado a anuncios y adelantos de nuevos productos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones y sorteos**: Participa en sorteos y promociones festivas.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo!

1.1.1 LED parpadeante
=========================

Introducci√≥n
-----------------

En esta lecci√≥n, aprenderemos a hacer que un LED parpadee mediante programaci√≥n. 
A trav√©s de tus configuraciones, tu LED puede producir una serie de fen√≥menos 
interesantes. Ahora, ¬°manos a la obra!

Componentes
------------------

.. image:: img/blinking_led_list.png
    :width: 800
    :align: center

.. note::
    Para proceder sin inconvenientes, necesitas traer tu propia
    Raspberry Pi, tarjeta TF y alimentaci√≥n para Raspberry Pi.

Principio
-----------

**Protoboard**

Una protoboard es una base de construcci√≥n para la creaci√≥n de prototipos 
electr√≥nicos. Se utiliza para construir y probar circuitos r√°pidamente antes 
de finalizar cualquier dise√±o de circuito. Tiene muchos orificios en los que 
se pueden insertar los componentes mencionados anteriormente, como ICs y 
resistencias, as√≠ como cables puente. La protoboard te permite conectar y quitar 
componentes con facilidad.

La imagen muestra la estructura interna de una protoboard completa. Aunque estos 
orificios en la protoboard parecen independientes entre s√≠, en realidad est√°n 
conectados entre s√≠ a trav√©s de tiras de metal internamente.

.. image:: img/image41.png

**LED**

El LED es un tipo de diodo. El LED solo brillar√° si el pin largo est√° conectado 
al electrodo positivo y el pin corto est√° conectado al electrodo negativo.

.. |image42| image:: img/image42.png

.. |image43| image:: img/image43.png

|image42|\ |image43|

El LED no puede conectarse directamente a la fuente de alimentaci√≥n, ya que puede 
da√±ar el componente. Debe conectarse en serie una resistencia de 160Œ© o mayor 
(funcionando a 5V) en el circuito del LED.



**Resistencia**

La resistencia es un elemento electr√≥nico que puede limitar la corriente de 
una rama. Una resistencia fija es un tipo de resistencia cuyo valor no puede 
cambiarse, mientras que el de un potenci√≥metro o una resistencia variable puede ajustarse.

Se utiliza una resistencia fija en este kit. En el circuito, es esencial para 
proteger los componentes conectados. Las siguientes im√°genes muestran un objeto 
real, una resistencia de 220Œ© y dos s√≠mbolos de circuito com√∫nmente usados para 
resistencias. Œ© es la unidad de resistencia y las unidades m√°s grandes incluyen 
KŒ©, MŒ©, etc. Su relaci√≥n se puede expresar de la siguiente manera: 1 MŒ© = 1000 KŒ©, 
1 KŒ© = 1000 Œ©. Normalmente, el valor de la resistencia est√° marcado en ella. 
As√≠ que si ves estos s√≠mbolos en un circuito, significa que hay una resistencia.

.. image:: img/image44.png

.. |image45| image:: img/image45.png

.. |image46| image:: img/image46.png

|image45|\ |image46|

Al usar una resistencia, primero necesitamos conocer su valor. Aqu√≠ hay dos 
m√©todos: puedes observar las bandas en la resistencia o usar un mult√≠metro 
para medir la resistencia. Se recomienda usar el primer m√©todo, ya que es 
m√°s conveniente y r√°pido. Para medir el valor, utiliza el mult√≠metro.

Como se muestra en la tarjeta, cada color representa un n√∫mero.

.. image:: img/image47.jpeg

Diagrama Esquem√°tico
-------------------------

En este experimento, conecta una resistencia de 220Œ© al √°nodo (el pin largo) 
del LED, luego conecta la resistencia a 3.3 V y conecta el c√°todo (el pin corto) 
del LED a GPIO17 de la Raspberry Pi. Por lo tanto, para encender un LED, 
necesitamos establecer el GPIO17 en un nivel bajo (0V). Podemos obtener este 
fen√≥meno mediante programaci√≥n.

.. note::

    **Pin11** se refiere al und√©cimo pin de la Raspberry Pi de izquierda a derecha, y sus correspondientes n√∫meros de pin **wiringPi** y **BCM** se muestran en la siguiente tabla.

En el contenido relacionado con el lenguaje C, hacemos que GPIO0 sea 
equivalente a 0 en el wiringPi. En el contenido relacionado con el 
lenguaje Python, BCM 17 es 17 en la columna BCM de la siguiente tabla. 
Al mismo tiempo, son equivalentes al und√©cimo pin de la Raspberry Pi, Pin 11.

============ ======== ======== ====
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ==== 

.. image:: img/image48.png
    :width: 800
    :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: img/image49.png
    :width: 800
    :align: center

**Paso 2:** Ve a la carpeta del c√≥digo.

1) Si usas una pantalla, se recomienda que sigas estos pasos.

Ve a **~/** y encuentra la carpeta 
**davinci-kit-for-raspberry-pi**.

Encuentra **C** en la carpeta, haz clic derecho sobre ella y selecciona **Abrir en Terminal**.

.. image:: img/image50.png
    :width: 800
    :align: center

Luego, aparecer√° una ventana como se muestra a continuaci√≥n. As√≠ que ahora has ingresado a la ruta del c√≥digo **1.1.1_BlinkingLed.c**.

.. image:: img/image51.png
    :width: 800
    :align: center

En las siguientes lecciones, utilizaremos comandos para acceder al archivo de 
c√≥digo en lugar de hacer clic derecho. Pero puedes elegir el m√©todo que prefieras.

2) Si accedes a la Raspberry Pi de forma remota, usa ``cd`` para cambiar de directorio:

.. raw:: html

   <run></run>

.. code-block::

   cd ~/davinci-kit-for-raspberry-pi/c/1.1.1/

.. note::
    Cambia el directorio a la ruta del c√≥digo en este experimento usando cd.

De cualquiera de las maneras, ahora est√°s en la carpeta C. Los procedimientos 
posteriores basados en estos dos m√©todos son los mismos. Continuemos.

**Paso 3:** Compila el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

   gcc 1.1.1_BlinkingLed.c -o BlinkingLed -lwiringPi

.. note::
    gcc es GNU Compiler Collection. Aqu√≠, funciona como
    compilador del archivo de lenguaje C *1_BlinkingLed.c* y genera un
    archivo ejecutable.

En el comando, ``-o`` significa salida (el car√°cter inmediatamente
siguiente a -o es el nombre del archivo que se generar√° tras la compilaci√≥n, y se generar√° un ejecutable llamado ``BlinkingLed``) y ``-lwiringPi`` es para cargar
la biblioteca wiringPi (``l`` es la abreviatura de biblioteca).

**Paso 4:** Ejecuta el archivo ejecutable generado en el paso anterior.

.. raw:: html

   <run></run>

.. code-block::

   sudo ./BlinkingLed

.. note::

   Para controlar el GPIO, necesitas ejecutar el programa con el
   comando, sudo (superusuario). El comando ``./`` indica el directorio actual. 
   El comando completo es para ejecutar ``BlinkingLed`` en el
   directorio actual.

.. image:: img/image52.png
    :width: 800
    :align: center

Despu√©s de que el c√≥digo se ejecute, ver√°s el LED parpadeando.

.. note::

   Si no funciona despu√©s de ejecutarlo, o si aparece un mensaje de error: "wiringPi.h: No such file or directory", consulta :ref:`c code is not working?`.

Si deseas editar el archivo de c√≥digo ``1.1.1_BlinkingLed.c``, presiona ``Ctrl + C`` 
para detener la ejecuci√≥n del c√≥digo. Luego, escribe el siguiente comando para abrirlo:

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.c

.. note::
    nano es una herramienta de editor de texto. El comando se utiliza para abrir el
    archivo de c√≥digo ``1.1.1_BlinkingLed.c`` mediante esta herramienta.

Presiona ``Ctrl+X`` para salir. Si has modificado el c√≥digo, aparecer√° un
mensaje preguntando si deseas guardar los cambios o no. Escribe ``Y`` (guardar)
o ``N`` (no guardar). Luego presiona ``Enter`` para salir. Repite ``Paso 3``
y ``Paso 4`` para ver el efecto despu√©s de modificar.

.. image:: img/image53.png
    :width: 800
    :align: center

**C√≥digo**

El c√≥digo del programa se muestra a continuaci√≥n:

.. code-block:: c

   #include <wiringPi.h>  
   #include <stdio.h>
   #define LedPin      0
   int main(void)
   {
      // Si la inicializaci√≥n de wiring falla, imprime un mensaje en la pantalla
      if(wiringPiSetup() == -1){
         printf("setup wiringPi failed !");
         return 1;
      }
      pinMode(LedPin, OUTPUT);// Establece LedPin como salida para escribirle un valor.
      while(1){
         // LED encendido
         digitalWrite(LedPin, LOW);
         printf("...LED on\n");
         delay(500);
         // LED apagado
         digitalWrite(LedPin, HIGH);
         printf("LED off...\n");
         delay(500);
      }
      return 0;
   }

**Explicaci√≥n del C√≥digo**

.. code-block:: c

   include <wiringPi.h>

La biblioteca de control de hardware est√° dise√±ada para el lenguaje C de la 
Raspberry Pi. A√±adir esta biblioteca facilita la inicializaci√≥n del hardware,
y la salida de puertos de I/O, PWM, etc.

.. code-block:: c

   #include <stdio.h>

Biblioteca est√°ndar de I/O. La funci√≥n pintf utilizada para imprimir los datos 
que se muestran en la pantalla se realiza mediante esta biblioteca. Hay muchas 
otras funciones de rendimiento que puedes explorar.

.. code-block:: c

   #define LedPin 0

El pin GPIO17 de la T_Extension Board corresponde al GPIO0 en
wiringPi. Asignamos GPIO0 a LedPin, por lo que LedPin representa GPIO0 en el 
c√≥digo posterior.

.. code-block:: c

    if(wiringPiSetup() == -1){
        printf("setup wiringPi failed !");
        return 1;

Esto inicializa wiringPi y asume que el programa que lo llama va a usar
el esquema de numeraci√≥n de pines de wiringPi.

Esta funci√≥n necesita ser llamada con privilegios de root.
Cuando la inicializaci√≥n de wiring falla, imprime un mensaje en la pantalla. 
La funci√≥n "return" se utiliza para salir de la funci√≥n actual. Usar return 
en la funci√≥n main() finalizar√° el programa.

.. code-block:: c

   pinMode(LedPin, OUTPUT);

Establece LedPin como salida para escribirle un valor.

.. code-block:: c

   digitalWrite(LedPin, LOW);

Establece GPIO0 en 0V (nivel bajo). Dado que el c√°todo del LED est√° conectado a
GPIO0, el LED se encender√° si GPIO0 se establece en bajo. Por el contrario,
si GPIO0 se establece en alto, digitalWrite (LedPin, HIGH): el LED se apagar√°.

.. code-block:: c

   printf("...LED¬†off\n");

La funci√≥n printf es una funci√≥n de la biblioteca est√°ndar y su prototipo 
de funci√≥n se encuentra en el archivo de encabezado "stdio.h". La forma 
general de la llamada es: printf(" cadena de control de formato ", columnas 
de salida). La cadena de control de formato se utiliza para especificar el 
formato de salida, que se divide en cadena de formato y cadena no formateada. 
La cadena de formato comienza con '%' seguido de caracteres de formato, como 
'%d' para la salida de enteros decimales. Las cadenas no formateadas se imprimen 
como prototipos. Lo que se usa aqu√≠ es una cadena no formateada, seguida de "\n", 
que es un car√°cter de nueva l√≠nea, representando un salto de l√≠nea autom√°tico 
despu√©s de imprimir una cadena.

.. code-block:: c

   delay(500);

Delay (500) mantiene el estado actual de HIGH o LOW durante 500ms.

Esta es una funci√≥n que suspende el programa durante un periodo de tiempo. 
Y la velocidad del programa est√° determinada por nuestro hardware. Aqu√≠ 
encendemos
o apagamos el LED. Si no hay una funci√≥n de delay, el programa ejecutar√° 
todo el c√≥digo muy r√°pidamente y en un bucle continuo. As√≠ que necesitamos 
la funci√≥n de delay para ayudarnos a escribir y depurar el programa.

.. code-block:: c

   return 0;

Normalmente, se coloca al final de la funci√≥n principal, indicando que la
funci√≥n devuelve 0 al ejecutarse con √©xito.
