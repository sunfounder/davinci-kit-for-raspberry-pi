.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et vos d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† des concours et des offres sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _2.2.3_py_pi5:

2.2.3 DHT-11
================

Introduction
----------------

Dans cette le√ßon, vous apprendrez √† connecter et √† lire les donn√©es d'un capteur de temp√©rature et d'humidit√© DHT11 en utilisant un Raspberry Pi. Vous apprendrez √† configurer le capteur, √† lire la temp√©rature en Celsius et en Fahrenheit, et √† obtenir des relev√©s d'humidit√©. Ce projet vous initiera au travail avec des capteurs externes, √† la gestion des donn√©es en temps r√©el et aux bases de la gestion des exceptions en Python.


Composants n√©cessaires
-------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_2.2.3_dht-11.png


Sch√©ma de c√¢blage
--------------------

.. image:: ../img/image326.png


Proc√©dure exp√©rimentale
--------------------------

**√âtape 1 :** Montez le circuit.

.. image:: ../img/image207.png

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python_pi5/

**√âtape 3 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Lorsque le code s'ex√©cute, le programme affichera la temp√©rature et 
l'humidit√© d√©tect√©es par le capteur DHT11 sur l'√©cran de l'ordinateur.

.. warning::

    En cas de message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`

**Code**

.. note::

    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Mais avant cela, assurez-vous de vous rendre dans le chemin source du code, comme ``davinci-kit-for-raspberry-pi/python_pi5``.
    
.. raw:: html

    <run></run>

.. code-block:: python

   from gpiozero import OutputDevice, InputDevice
   import time


   class DHT11():
      MAX_DELAY_COUINT = 100
      BIT_1_DELAY_COUNT = 10
      BITS_LEN = 40

      def __init__(self, pin, pull_up=False):
         self._pin = pin
         self._pull_up = pull_up


      def read_data(self):
         bit_count = 0
         delay_count = 0
         bits = ""

         # -------------- envoi de d√©marrage --------------
         gpio = OutputDevice(self._pin)
         gpio.off()
         time.sleep(0.02)

         gpio.close()
         gpio = InputDevice(self._pin, pull_up=self._pull_up)

         # -------------- attente de r√©ponse --------------
         while gpio.value == 1:
               pass
         
         # -------------- lecture des donn√©es --------------
         while bit_count < self.BITS_LEN:
               while gpio.value == 0:
                  pass

               # st = time.time()
               while gpio.value == 1:
                  delay_count += 1
                  # break
                  if delay_count > self.MAX_DELAY_COUINT:
                     break
               if delay_count > self.BIT_1_DELAY_COUNT:
                  bits += "1"
               else:
                  bits += "0"

               delay_count = 0
               bit_count += 1

         # -------------- v√©rification --------------
         humidity_integer = int(bits[0:8], 2)
         humidity_decimal = int(bits[8:16], 2)
         temperature_integer = int(bits[16:24], 2)
         temperature_decimal = int(bits[24:32], 2)
         check_sum = int(bits[32:40], 2)

         _sum = humidity_integer + humidity_decimal + temperature_integer + temperature_decimal

         # print(bits)
         # print(humidity_integer, humidity_decimal, temperature_integer, temperature_decimal)
         # print(f'sum:{_sum}, check_sum:{check_sum}')
         # print()

         if check_sum != _sum:
               humidity = 0.0
               temperature = 0.0
         else:
               humidity = float(f'{humidity_integer}.{humidity_decimal}')
               temperature = float(f'{temperature_integer}.{temperature_decimal}')

         # -------------- retour --------------
         return humidity, temperature


   if __name__ == '__main__':
      dht11 = DHT11(17)
      while True:
         humidity, temperature = dht11.read_data()
         print(f"{time.time():.3f}  temperature:{temperature}¬∞C  humidity: {humidity}%")
         time.sleep(2)

**Explication du code**

.. code-block:: python

   def read_data(self):
      bit_count = 0
      delay_count = 0
      bits = ""

      # -------------- envoi de d√©marrage --------------
      gpio = OutputDevice(self._pin)
      gpio.off()
      time.sleep(0.02)

      gpio.close()
      gpio = InputDevice(self._pin, pull_up=self._pull_up)
      #...

Cette fonction est utilis√©e pour impl√©menter les fonctions du capteur DHT11. 
Elle stocke les donn√©es d√©tect√©es dans le tableau `bits[]`. Le DHT11 transmet 
des donn√©es par paquet de 40 bits. Les 16 premiers bits sont li√©s √† l'humidit√©, 
les 16 bits suivants √† la temp√©rature, et les huit derniers bits sont utilis√©s 
pour la v√©rification. Le format de donn√©es est :

**8 bits de donn√©es enti√®res d'humidit√©** + **8 bits de donn√©es d√©cimales d'humidit√©** 
+ **8 bits de donn√©es enti√®res de temp√©rature** + **8 bits de donn√©es d√©cimales de temp√©rature** + **8 bits de somme de contr√¥le**.

Lorsque la validit√© est v√©rifi√©e via le bit de contr√¥le, la fonction retourne deux r√©sultats : 1. une erreur ; 2. l'humidit√© et la temp√©rature.

.. code-block:: python

   _sum = humidity_integer + humidity_decimal + temperature_integer + temperature_decimal

   if check_sum != _sum:
         humidity = 0.0
         temperature = 0.0
   else:
         humidity = float(f'{humidity_integer}.{humidity_decimal}')
         temperature = float(f'{temperature_integer}.{temperature_decimal}')

Par exemple, si les donn√©es re√ßues sont 00101011 (valeur enti√®re de l'humidit√© sur 8 bits) 
00000000 (valeur d√©cimale de l'humidit√© sur 8 bits) 00111100 (valeur enti√®re de la 
temp√©rature sur 8 bits) 00000000 (valeur d√©cimale de la temp√©rature sur 8 bits) 01100111 
(bit de v√©rification).

**Calcul :**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Si le r√©sultat final est √©gal au bit de v√©rification, la transmission des donn√©es est 
correcte : l'humidit√© et la temp√©rature sont retourn√©es, par exemple : 
``Humidit√© = 43%, Temp√©rature = 60¬∞C``.
