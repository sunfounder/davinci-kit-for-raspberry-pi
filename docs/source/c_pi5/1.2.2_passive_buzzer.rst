.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez dans le monde du Raspberry Pi, Arduino et ESP32 avec d‚Äôautres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d‚Äôexperts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l‚Äôaide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts exclusifs.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de remises exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des tirages au sort et des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

1.2.2 Buzzer Passif
=======================

Introduction
---------------

Dans cette le√ßon, nous allons apprendre √† faire jouer de la musique √† un buzzer passif.

Composants
-------------

.. image:: img/list_1.2.2.png


Sch√©ma de montage
---------------------

Dans cette exp√©rience, un buzzer passif, un transistor PNP et une r√©sistance 
de 1kŒ© sont utilis√©s entre la base du transistor et le GPIO pour prot√©ger le transistor.

Lorsque le GPIO17 g√©n√®re diff√©rentes fr√©quences, le buzzer passif √©met diff√©rents sons ; 
ainsi, il est possible de jouer de la musique.

.. image:: img/image333.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image106.png
    :width: 800

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.2.2/

**√âtape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**√âtape 4 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le code ex√©cut√©, le buzzer joue une m√©lodie.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur : \"wiringPi.h: Aucun fichier ou r√©pertoire de ce type\", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.


**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //si l'initialisation de wiring √©choue, affiche un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");
            delay(100);
            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }

**Explication du Code**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294


Ces fr√©quences correspondent aux notes de musique. CL indique une note basse, 
CM une note moyenne, et CH une note haute ; les chiffres 1 √† 7 correspondent aux 
notes de la gamme C, D, E, F, G, A, B.

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

Le tableau song_1[] contient les fr√©quences des notes de la chanson, et beat_1[] 
repr√©sente la dur√©e de chaque note (chaque unit√© de battement repr√©sente 0,5 seconde).

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        
Cela cr√©e une broche de tonalit√© contr√¥l√©e par logiciel. Vous pouvez utiliser n'importe 
quelle broche GPIO. La valeur de retour est 0 en cas de succ√®s. En cas d'√©chec, v√©rifiez 
la variable globale errno pour identifier le probl√®me.

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

Utilisez une boucle for pour jouer la m√©lodie song_1.

Dans la condition de la boucle, **i<sizeof(song_1)/4**, la division par 4 est 
n√©cessaire car chaque √©l√©ment du tableau song_1[] est un entier de 4 octets.

Le nombre d'√©l√©ments dans song_1 (c'est-√†-dire le nombre de notes de la m√©lodie) 
est d√©termin√© en divisant sizeof(song_1) par 4.

Pour que chaque note joue pendant beat \* 500 ms, la fonction delay(beat_1[i] \* 500) 
est utilis√©e.

Le prototype de softToneWrite(BuzPin, song_1[i]) est :

.. code-block:: c

    void softToneWrite (int pin, int freq);

Cette fonction met √† jour la fr√©quence de la tonalit√© sur la broche sp√©cifi√©e. La 
tonalit√© continue de jouer jusqu'√† ce que vous d√©finissiez la fr√©quence √† 0.

