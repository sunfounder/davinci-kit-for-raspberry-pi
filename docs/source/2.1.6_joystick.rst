.. note::

    隆Hola! Bienvenidos a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum茅rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **驴Por qu茅 unirse?**

    - **Soporte Experto**: Resuelve problemas post-venta y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas Exclusivas**: Obt茅n acceso anticipado a anuncios de nuevos productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy.

2.1.6 Joystick
================

Introducci贸n
---------------

En este proyecto, aprenderemos c贸mo funciona el joystick. Manipularemos 
el joystick y mostraremos los resultados en la pantalla.

Componentes
-------------

.. image:: img/image317.png

Principio
-------------

**Joystick**

La idea b谩sica de un joystick es traducir el movimiento de una palanca en 
informaci贸n electr贸nica que una computadora pueda procesar.

Para comunicar un rango completo de movimiento, un joystick necesita medir 
la posici贸n de la palanca en dos ejes: el eje X (izquierda a derecha) y el 
eje Y (arriba y abajo). Al igual que en la geometr铆a b谩sica, las coordenadas 
X-Y identifican la posici贸n de la palanca con precisi贸n.

Para determinar la ubicaci贸n de la palanca, el sistema de control del joystick 
simplemente monitorea la posici贸n de cada eje. El dise帽o de joystick anal贸gico 
convencional hace esto con dos potenci贸metros o resistencias variables.

El joystick tambi茅n cuenta con una entrada digital que se activa cuando el 
joystick se presiona hacia abajo.

.. image:: img/image318.png

Diagrama Esquem谩tico
-------------------------

Al leer los datos del joystick, hay algunas diferencias entre los ejes: los 
datos de los ejes X y Y son anal贸gicos, por lo que se necesita utilizar el 
ADC0834 para convertir el valor anal贸gico a digital. Los datos del eje Z son 
digitales, por lo que puedes leerlos directamente desde el GPIO, aunque tambi茅n 
puedes usar el ADC para leerlos.

.. image:: img/image319.png

.. image:: img/image320.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image193.png
    :width: 800

Para Usuarios de Lenguaje C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Ve a la carpeta del c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.6/

**Paso 3:** Compila el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.6_Joystick.c -lwiringPi

**Paso 4:** Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu茅s de ejecutar el c贸digo, mueve el joystick y los valores correspondientes 
de x, y y Btn se mostrar谩n en la pantalla.


.. note::

    Si no funciona despu茅s de ejecutarlo, o aparece un mensaje de error: \"wiringPi.h: No such file or directory\", consulta :ref:`C code is not working?`.



**C贸digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     BtnPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de entrada 煤nica
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Impar
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci贸n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);
        
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        
        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }
        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }
        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }
    int main(void)
    {
        uchar x_val;
        uchar y_val;
        uchar btn_val;
        if(wiringPiSetup() == -1){ // Si la inicializaci贸n de wiring falla, imprime mensaje en la pantalla
            printf("setup wiringPi failed !");
            return 1;
        }
        pinMode(BtnPin,  INPUT);
        pullUpDnControl(BtnPin, PUD_UP);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            x_val = get_ADC_Result(0);
            y_val = get_ADC_Result(1);
            btn_val = digitalRead(BtnPin);
            printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
            delay(100);
        }
        return 0;
    }

**Explicaci贸n del C贸digo**

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de entrada 煤nica
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        ......

El proceso de funcionamiento de la funci贸n se detalla en el apartado 2.1.4 Potenci贸metro.

.. code-block:: c

    while(1){
            x_val = get_ADC_Result(0);
            y_val = get_ADC_Result(1);
            btn_val = digitalRead(BtnPin);
            printf("x = %d, y = %d, btn = %d\n", x_val, y_val, btn_val);
            delay(100);
        }

VRX y VRY del joystick est谩n conectados a CH0 y CH1 del ADC0834 respectivamente. 
Por lo tanto, se llama a la funci贸n getResult() para leer los valores de CH0 y CH1. 
Luego, los valores le铆dos se almacenan en las variables x_val y y_val. Adem谩s, 
se lee el valor de SW del joystick y se almacena en la variable btn_val. Finalmente, 
los valores de x_val, y_val y btn_val se muestran usando la funci贸n print().

Para Usuarios de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Dir铆gete a la carpeta del c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_Joystick.py

Despu茅s de ejecutar el c贸digo, mueve el joystick y los valores 
correspondientes de x, y, Btn se mostrar谩n en la pantalla.


**C贸digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el 
    c贸digo a continuaci贸n. Pero antes de hacerlo, debes dirigirte a 
    la ruta del c贸digo fuente como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import ADC0834
    import time

    BtnPin = 22

    def setup():
        # Establece los modos de GPIO en numeraci贸n BCM
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        ADC0834.setup()

    def destroy():
        # Libera los recursos
        GPIO.cleanup()

    def loop():
        while True:
            x_val = ADC0834.getResult(0)
            y_val = ADC0834.getResult(1)
            Btn_val = GPIO.input(BtnPin)
            print ('X: %d  Y: %d  Btn: %d' % (x_val, y_val, Btn_val))
            time.sleep(0.2)

    if __name__ == '__main__':
        setup()
        try:
            loop()
        except KeyboardInterrupt: # Cuando se presiona 'Ctrl+C', se ejecutar谩 el programa destroy().
            destroy()

**Explicaci贸n del C贸digo**

.. code-block:: python

    def loop():
        while True:
            x_val = ADC0834.getResult(0)
            y_val = ADC0834.getResult(1)
            Btn_val = GPIO.input(BtnPin)
            print ('X: %d  Y: %d  Btn: %d' % (x_val, y_val, Btn_val))
            time.sleep(0.2)

VRX y VRY del joystick est谩n conectados respectivamente a CH0 y CH1 del ADC0834. 
Por lo tanto, se llama a la funci贸n getResult() para leer los valores de CH0 y CH1. 
Los valores le铆dos se almacenan en las variables x_val y y_val. Adem谩s, se lee el valor 
de SW del joystick y se almacena en la variable Btn_val. Finalmente, los valores de x_val, 
y_val y Btn_val se muestran utilizando la funci贸n print().

Imagen del Fen贸meno
------------------------

.. image:: img/image194.jpeg


