.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!


3.1.13 SPIEL - 10 Sekunden
============================

EinfÃ¼hrung
-------------------

Als nÃ¤chstes folge mir, um ein SpielgerÃ¤t zu bauen, das deine Konzentration herausfordert. Binden Sie den Neigungsschalter an einen Stock, um einen Zauberstab herzustellen. SchÃ¼tteln Sie den Stab, die 4-stellige Segmentanzeige beginnt zu zÃ¤hlen. Durch erneutes SchÃ¼tteln wird die ZÃ¤hlung beendet. Wenn es Ihnen gelingt, die angezeigte Anzahl bei 10,00 zu halten, gewinnen Sie. Sie kÃ¶nnen das Spiel mit Ihren Freunden spielen, um zu sehen, wer der Zeitassistent ist.

Komponenten
----------------

.. image:: media/list_GAME_10_Second.png
    :align: center

Schematische Darstellung
-------------------------------

============ ======== ======== ===
T-Karte Name physisch wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: media/Schematic_three_one13.png
   :align: center

Experimentelle Verfahren
---------------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: media/image277.png
   :alt: 10 second_bb
   :width: 800

FÃ¼r Benutzer in C-Sprache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.13/

Schritt 3: Kompilieren Sie die Kode.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.13_GAME_10Second.c -lwiringPi

Schritt 4: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

SchÃ¼tteln Sie den Stab, die 4-stellige Segmentanzeige beginnt zu zÃ¤hlen. 
Durch erneutes SchÃ¼tteln wird die ZÃ¤hlung beendet. Wenn es Ihnen gelingt, 
die angezeigte Anzahl bei 10,00 zu halten, gewinnen Sie. 
SchÃ¼tteln Sie es noch einmal, um die nÃ¤chste Runde des Spiels zu starten.

**Code ErklÃ¤rung**

.. code-block:: c

    voidÂ stateChange(){
    Â Â Â Â ifÂ (gameStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â counterÂ =Â 0;
    Â Â Â Â Â Â Â Â delay(1000);
    Â Â Â Â Â Â Â Â ualarm(10000,10000);Â 
    Â Â Â Â }else{
    Â Â Â Â Â Â Â Â alarm(0);
    Â Â Â Â Â Â Â Â delay(1000);
    Â Â Â Â }
    Â Â Â Â gameStateÂ =Â (gameStateÂ +Â 1)%2;
    }

Das Spiel ist in zwei Modi unterteilt:

``gameState=0`` ist der â€žStartâ€œ -Modus, in dem die Zeit zeitlich festgelegt und auf der Segmentanzeige angezeigt wird und der Kippschalter geschÃ¼ttelt wird, um in den â€žShowâ€œ -Modus zu wechseln.

``gameState=1`` ist der â€žshowâ€œ -Modus, der das Timing stoppt und die Zeit auf der Segmentanzeige anzeigt. Durch erneutes SchÃ¼tteln des Neigungsschalters wird der Timer zurÃ¼ckgesetzt und das Spiel neu gestartet.

.. code-block:: c

    voidÂ loop(){
    Â Â Â Â intÂ currentStateÂ =0;
    Â Â Â Â intÂ lastState=0;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â display();
    Â Â Â Â Â Â Â Â currentState=digitalRead(sensorPin);
    Â Â Â Â Â Â Â Â if((currentState==0)&&(lastState==1)){
    Â Â Â Â Â Â Â Â Â Â Â Â stateChange();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â }
    }


``loop()`` ist die Hauptfunktion. ZunÃ¤chst wird die Zeit auf der 
4-Bit-Segmentanzeige angezeigt und der Wert des Neigungsschalters gelesen. 
Wenn sich der Status des Neigungsschalters geÃ¤ndert hat, wird ``stateChange()`` aufgerufen.

FÃ¼r Python-Sprachbenutzer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

Schritt 3: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.13_GAME_10Second.py

SchÃ¼tteln Sie den Stab, die 4-stellige Segmentanzeige beginnt zu zÃ¤hlen. 
Durch erneutes SchÃ¼tteln wird die ZÃ¤hlung beendet. 
Wenn es Ihnen gelingt, die angezeigte Anzahl bei 10,00 zu halten, 
gewinnen Sie. SchÃ¼tteln Sie es noch einmal, um die nÃ¤chste Runde des Spiels zu starten.

**Code**

.. note::

    Sie kÃ¶nnen den folgenden Code **Ã„ndern/ZurÃ¼cksetzen/Kopieren/AusfÃ¼hren/Stoppen** . Zuvor mÃ¼ssen Sie jedoch zu einem Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python`` gehen.
  
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    sensorPin = 26

    SDI = 24
    RCLK = 23
    SRCLK = 18

    placePin = (10, 22, 27, 17)
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    counter = 0
    timer =0
    gameState =0

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)    

    def hc595_shift(data): 
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

    def display():
        global counter                    
        clearDisplay() 
        pickDigit(0)  
        hc595_shift(number[counter % 10])

        clearDisplay()
        pickDigit(1)
        hc595_shift(number[counter % 100//10])

        clearDisplay()
        pickDigit(2)
        hc595_shift(number[counter % 1000//100]-0x80)

        clearDisplay()
        pickDigit(3)
        hc595_shift(number[counter % 10000//1000])

    def stateChange():
        global gameState
        global counter
        global timer1
        if gameState == 0:
            counter = 0
            time.sleep(1)
            timer() 
        elif gameState ==1:
            timer1.cancel()
            time.sleep(1)
        gameState = (gameState+1)%2

    def loop():
        global counter
        currentState = 0
        lastState = 0
        while True:
            display()
            currentState=GPIO.input(sensorPin)
            if (currentState == 0) and (lastState == 1):
                stateChange()
            lastState=currentState

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for i in placePin:
            GPIO.setup(i, GPIO.OUT)
        GPIO.setup(sensorPin, GPIO.IN)

    def destroy():   # When \"Ctrl+C\" is pressed, the function is executed.
        GPIO.cleanup()
        global timer1
        timer1.cancel()

    if __name__ == '__main__':  # Program starting from here
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()

**Code ErklÃ¤rung**

.. code-block:: python

    defÂ stateChange():
    Â Â Â Â globalÂ gameState
    Â Â Â Â globalÂ counter
    Â Â Â Â globalÂ timer1
    Â Â Â Â ifÂ gameStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â counterÂ =Â 0
    Â Â Â Â Â Â Â Â time.sleep(1)
    Â Â Â Â Â Â Â Â timer()Â 
    Â Â Â Â elifÂ gameStateÂ ==1:
    Â Â Â Â Â Â Â Â timer1.cancel()
    Â Â Â Â Â Â Â Â time.sleep(1)
    Â Â Â Â gameStateÂ =Â (gameState+1)%2

Das Spiel ist in zwei Modi unterteilt:

``gameState=0`` ist der â€žstartâ€œ -Modus, in dem die Zeit zeitlich festgelegt und auf der Segmentanzeige angezeigt wird und der Kippschalter geschÃ¼ttelt wird, um in den â€žShowâ€œ -Modus zu wechseln.

``gameState=1`` ist der â€žshowâ€œ -Modus, der das Timing stoppt und die Zeit auf der Segmentanzeige anzeigt. Durch erneutes SchÃ¼tteln des Neigungsschalters wird der Timer zurÃ¼ckgesetzt und das Spiel neu gestartet.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ counter
    Â Â Â Â currentStateÂ =Â 0
    Â Â Â Â lastStateÂ =Â 0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â display()
    Â Â Â Â Â Â Â Â currentState=GPIO.input(sensorPin)
    Â Â Â Â Â Â Â Â ifÂ (currentStateÂ ==Â 0)Â andÂ (lastStateÂ ==Â 1):
    Â Â Â Â Â Â Â Â Â Â Â Â stateChange()
    Â Â Â Â Â Â Â Â lastState=currentState


``loop()`` ist die Hauptfunktion. ZunÃ¤chst wird die Zeit auf der 4-Bit-Segmentanzeige angezeigt und der Wert des Neigungsschalters gelesen. 
Wenn sich der Status des Neigungsschalters geÃ¤ndert hat, wird ``stateChange()`` aufgerufen.

.. code-block:: python

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

Nachdem das Intervall 0,01 s erreicht hat, wird die Timerfunktion aufgerufen. 
Addiere 1 zum ZÃ¤hler und der Timer wird erneut verwendet, 
um sich alle 0,01 Sekunden wiederholt auszufÃ¼hren.

PhÃ¤nomen Bild
-----------------------

.. image:: media/image278.jpeg
   :align: center



