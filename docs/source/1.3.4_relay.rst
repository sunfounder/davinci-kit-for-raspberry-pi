.. note::

    ¬°Hola! Bienvenido a la comunidad de entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. √önete para profundizar en Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **¬øPor qu√© unirse?**

    - **Soporte de expertos**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Acceso exclusivo**: Obt√©n primicias sobre nuevos productos y adelantos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones de temporada.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo.

1.3.4 Rel√©
============

Introducci√≥n
---------------

En esta lecci√≥n, aprenderemos a utilizar un rel√©. Es uno de los componentes 
com√∫nmente usados en sistemas de control autom√°tico. Cuando el voltaje, 
corriente, temperatura, presi√≥n, etc., alcanza, supera o se encuentra por 
debajo de un valor predeterminado, el rel√© conectar√° o interrumpir√° el circuito 
para controlar y proteger el equipo.

Componentes
--------------

.. image:: img/list_1.3.4.png

Principio
------------

**Diodo**

Un diodo es un componente electr√≥nico de dos terminales que permite el flujo 
de corriente en una sola direcci√≥n. Ofrece baja resistencia en la direcci√≥n 
de flujo de corriente y alta resistencia en la direcci√≥n opuesta. Los diodos 
se utilizan principalmente para prevenir da√±os a componentes, especialmente 
debido a fuerzas electromotrices en circuitos polarizados.

.. image:: img/image344.png

Los dos terminales de un diodo est√°n polarizados, con el extremo positivo 
denominado √°nodo y el extremo negativo denominado c√°todo. El c√°todo suele 
estar marcado con una banda de color o en plata. Controlar la direcci√≥n del 
flujo de corriente es una de las caracter√≠sticas clave de los diodos: 
la corriente en un diodo fluye del √°nodo al c√°todo. El comportamiento de un 
diodo es similar al de una v√°lvula de retenci√≥n. Una de las caracter√≠sticas m√°s 
importantes de un diodo es su voltaje de corriente no lineal. Si se conecta un 
voltaje mayor al √°nodo, entonces la corriente fluye del √°nodo al c√°todo; a este 
proceso se le conoce como polarizaci√≥n directa. Sin embargo, si el voltaje mayor 
se conecta al c√°todo, el diodo no conduce electricidad, y el proceso se llama 
polarizaci√≥n inversa.

**Rel√©**

Como sabemos, el rel√© es un dispositivo utilizado para proporcionar conexi√≥n 
entre dos o m√°s puntos o dispositivos en respuesta a la se√±al de entrada aplicada. 
En otras palabras, los rel√©s proporcionan aislamiento entre el controlador y el 
dispositivo, ya que los dispositivos pueden funcionar tanto en CA como en CC. 
Sin embargo, reciben se√±ales de un microcontrolador que funciona en CC, por lo 
que se requiere un rel√© para cerrar esa brecha. El rel√© es extremadamente √∫til 
cuando se necesita controlar una gran cantidad de corriente o voltaje con una 
se√±al el√©ctrica peque√±a.

Un rel√© tiene 5 partes:

**Electroim√°n** - Consiste en un n√∫cleo de hierro envuelto en una bobina de 
alambre. Cuando pasa electricidad, se vuelve magn√©tico, por lo que se le llama 
electroim√°n.

**Armadura** - La tira magn√©tica m√≥vil se conoce como armadura. Cuando la 
corriente fluye a trav√©s de ella, la bobina se energiza, produciendo un 
campo magn√©tico que se utiliza para abrir o cerrar los puntos normalmente 
abiertos (N/O) o normalmente cerrados (N/C). La armadura puede ser accionada 
tanto por corriente continua (CC) como por corriente alterna (CA).

**Resorte** - Cuando no hay corriente en la bobina del electroim√°n, el resorte 
aleja la armadura, evitando que el circuito se complete.

Conjunto de **contactos el√©ctricos** - Existen dos puntos de contacto:

- Normalmente abierto: conectado cuando el rel√© est√° activado, y desconectado cuando est√° inactivo.

- Normalmente cerrado: no conectado cuando el rel√© est√° activado, y conectado cuando est√° inactivo.

**Marco moldeado** - Los rel√©s est√°n cubiertos con pl√°stico para protecci√≥n.

**Funcionamiento del Rel√©**

El principio de funcionamiento del rel√© es sencillo. Cuando se alimenta el rel√©, 
la corriente comienza a fluir a trav√©s de la bobina de control; como resultado, 
el electroim√°n se energiza. Entonces, la armadura es atra√≠da hacia la bobina, 
uniendo el contacto m√≥vil con los contactos normalmente abiertos, energizando 
el circuito de carga. Para interrumpir el circuito, el contacto m√≥vil se mueve 
hacia los contactos normalmente cerrados por la fuerza del resorte. De esta forma, 
el encendido y apagado del rel√© puede controlar el estado de un circuito de carga.

.. image:: img/image142.jpeg

Diagrama Esquem√°tico
---------------------------

.. image:: img/image345.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image144.png
    :width: 800

    

Para Usuarios de Lenguaje C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2**: Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.4

**Paso 3:** Compila el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.4_Relay.c -lwiringPi

**Paso 4:** Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu√©s de ejecutar el c√≥digo, el LED se encender√°. Adem√°s, puedes
escuchar un "tic-tac" causado por la apertura del contacto normalmente cerrado y 
el cierre del contacto normalmente abierto.

.. note::

    Si no funciona despu√©s de ejecutarlo, o aparece un mensaje de error: "wiringPi.h: No such file or directory", consulta :ref:`c code is not working?`.

**C√≥digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define RelayPin 0

    int main(void){
        if(wiringPiSetup() == -1){ //si la inicializaci√≥n de wiring falla, imprime mensaje en pantalla
            printf("setup wiringPi failed !");
            return 1;
        }
        pinMode(RelayPin, OUTPUT);   //configura GPIO17 (GPIO0) como salida
        while(1){
            // Tick
            printf("Relay Open......\n");
            delay(100);
            digitalWrite(RelayPin, LOW);
            delay(1000);
            // Tock
            printf("......Relay Close\n");
            delay(100);
            digitalWrite(RelayPin, HIGH);
            delay(1000);
        }

        return 0;
    }

**Explicaci√≥n del C√≥digo**

.. code-block:: c

    digitalWrite(RelayPin, LOW);

Configura el puerto I/O a nivel bajo (0V), por lo que el transistor no se energiza
y la bobina no recibe energ√≠a. No hay fuerza electromagn√©tica, por lo que
el rel√© se abre y el LED no se enciende.

.. code-block:: c

    digitalWrite(RelayPin, HIGH);

Configura el puerto I/O a nivel alto (5V) para energizar el transistor. La bobina
del rel√© recibe energ√≠a y genera fuerza electromagn√©tica; el rel√© se cierra y el LED se enciende.

Para Usuarios de Lenguaje Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.4_Relay.py

Mientras el c√≥digo se ejecuta, el LED se enciende. Adem√°s, puedes escuchar
un "tic-tac" causado por la apertura del contacto normalmente cerrado y el cierre del
contacto normalmente abierto.

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Antes de eso, necesitas dirigirte a la ruta del c√≥digo fuente como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # Configurar GPIO17 como pin de control
    relayPin = 17

    # Definir una funci√≥n de configuraci√≥n inicial
    def setup():
        # Configurar los modos de GPIO al sistema de numeraci√≥n BCM
        GPIO.setmode(GPIO.BCM)
        # Configurar el modo de relayPin a salida,
        # y el nivel inicial en alto (3.3V)
        GPIO.setup(relayPin, GPIO.OUT, initial=GPIO.HIGH)

    # Definir la funci√≥n principal para el proceso principal
    def main():
        while True:
            print ('Relay open...')
            # Tick
            GPIO.output(relayPin, GPIO.LOW)
            time.sleep(1)
            print ('...Relay close')
            # Tock
            GPIO.output(relayPin, GPIO.HIGH)
            time.sleep(1)

    # Definir una funci√≥n destroy para limpiar todo al
    # terminar el script
    def destroy():
        # Apagar el LED
        GPIO.output(relayPin, GPIO.HIGH)
        # Liberar recursos
        GPIO.cleanup()                    

    # Si ejecutas este script directamente, haz:
    if __name__ == '__main__':
        setup()
        try:
            main()
        # Cuando se presiona 'Ctrl+C', el programa secundario
        # destroy() se ejecutar√°.
        except KeyboardInterrupt:
            destroy()

**Explicaci√≥n del C√≥digo**

.. code-block:: python

    GPIO.output(relayPin, GPIO.LOW)

Configura los pines del transistor a nivel bajo para abrir el rel√©, y el LED no se enciende.

.. code-block:: python

    time.sleep(1)

Espera durante 1 segundo.

.. code-block:: python

    GPIO.output(relayPin, GPIO.HIGH)

Configura los pines del transistor a nivel alto para activar el rel√©; el LED
se enciende.

Imagen del Fen√≥meno
------------------------

.. image:: img/image145.jpeg