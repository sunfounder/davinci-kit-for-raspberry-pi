.. note::

    Hello, welcome to the SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community on Facebook! Dive deeper into Raspberry Pi, Arduino, and ESP32 with fellow enthusiasts.

    **Why Join?**

    - **Expert Support**: Solve post-sale issues and technical challenges with help from our community and team.
    - **Learn & Share**: Exchange tips and tutorials to enhance your skills.
    - **Exclusive Previews**: Get early access to new product announcements and sneak peeks.
    - **Special Discounts**: Enjoy exclusive discounts on our newest products.
    - **Festive Promotions and Giveaways**: Take part in giveaways and holiday promotions.

    ðŸ‘‰ Ready to explore and create with us? Click [|link_sf_facebook|] and join today!

3.1.8 Overheat Monitor
========================

Introduction
-------------------

You may want to make an overheat monitoring device that applies to
various situations, ex., in the factory, if we want to have an alarm and
the timely automatic turning off of the machine when there is a circuit
overheating. In this lesson, we will use thermistor, joystick, buzzer,
LED and LCD to make an smart temperature monitoring device whose
threshold is adjustable.

Components
-----------------

.. image:: img/list_Overheat_Monitor.png
    :align: center

.. image:: img/list_Overheat_Monitor2.png
    :align: center

Schematic Diagram
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one8.png
   :width: 700
   :align: center

Experimental Procedures
-----------------------------

**Step 1:** Build the circuit.

.. image:: img/image258.png
   :alt: Overheat Monitor_bb
   :width: 800

**For C Language Users**
^^^^^^^^^^^^^^^^^^^^^^^^^^

**Step 2**: Go to the folder of the code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.8/

**Step 3**: Compile the code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

**Step 4**: Run the executable file.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

.. note::

    If it does not work after running, or there is an error prompt: \"wiringPi.h: No such file or directory\", please refer to :ref:`C code is not working?`.


**Joystick** here is for your pressing to adjust the high-temperature
threshold. Toggling the **Joystick** in the direction of X-axis and
Y-axis can adjust (turn up or down) the current high-temperature
threshold. Press the **Joystick** once again to reset the threshold to
initial value.

**Code Explanation**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

This function reads values of X and Y. If **X>200**, there will return
\"**1**\"; **X<50**, return \"**-1**\"; **y>200**, return
\"**-10**\", and **y<50**, return \"**10**\".

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

This function is for adjusting the threshold and displaying it on the
I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Read the analog value of the **CH0** (thermistor) of **ADC0834** and
then convert it to temperature value.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

The function main() contains the whole program process as shown:

1) When the program starts, the initial value of **stage** is **0**, and
   the current temperature and the high-temperature threshold **40** are
   displayed on **I2C LCD1602**. If the current temperature is larger
   than the threshold, the buzzer and the LED are started to alarm you.

2) Press the Joystick, and **stage** will be **1** and you can adjust
   the high-temperature threshold. Toggling the Joystick in the
   direction of X-axis and Y-axis can adjust (turn up or down) the
   current threshold. Press the Joystick once again to reset the
   threshold to initial value.

**For Python Language Users**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Step 2**: Go to the folder of the code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**Step 3**: Run the executable file.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.8_OverheatMonitor.py

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

**Joystick** here is for your pressing to adjust the high-temperature
threshold. Toggling the **Joystick** in the direction of X-axis and
Y-axis can adjust (turn up or down) the current high-temperature
threshold. Press the **Joystick** once again to reset the threshold to
initial value.

**Code**

.. note::

    You can **Modify/Reset/Copy/Run/Stop** the code below. But before that, you need to go to  source code path like ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24


    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Code Explanation**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

This function reads values of X and Y. If **X>200**, there will return
\"**1**\"; **X<50**, return \"**-1**\"; **y>200**, return
\"**-10**\", and **y<50**, return \"**10**\".

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

This function is for adjusting the threshold and displaying it on the
I2C LCD1602.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Read the analog value of the **CH0** (thermistor) of **ADC0834** and
then convert it to temperature value.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

As the code runs, the current temperature and the high-temperature
threshold **40** are displayed on **I2C LCD1602**. If the current
temperature is larger than the threshold, the buzzer and LED are started
to alarm you.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

The function main() contains the whole program process as shown:

1) When the program starts, the initial value of **stage** is **0**, and
   the current temperature and the high-temperature threshold **40** are
   displayed on **I2C LCD1602**. If the current temperature is larger
   than the threshold, the buzzer and the LED are started to alarm you.

2) Press the Joystick, and **stage** will be **1** and you can adjust
   the high-temperature threshold. Toggling the Joystick in the
   direction of X-axis and Y-axis can adjust (turn up or down) the
   current high-temperature threshold. Press the Joystick once again to
   reset the threshold to initial value.

Phenomenon Picture
-------------------------

.. image:: img/image259.jpeg
   :align: center