.. note::

    Bonjour et bienvenue dans la communautÃ© des passionnÃ©s de SunFounder Raspberry Pi & Arduino & ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, d'Arduino et de l'ESP32 avec d'autres passionnÃ©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & Partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : Recevez des annonces anticipÃ©es sur les nouveaux produits et des avant-premiÃ¨res.
    - **RÃ©ductions spÃ©ciales** : BÃ©nÃ©ficiez de rÃ©ductions exclusives sur nos produits les plus rÃ©cents.
    - **Promotions festives et tirages au sort** : Participez Ã  des concours et promotions lors des pÃ©riodes festives.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.1 Dispositif de comptage
=================================

Introduction
----------------

Ici, nous allons crÃ©er un systÃ¨me de comptage avec affichage numÃ©rique, 
composÃ© d'un capteur PIR et d'un affichage Ã  4 segments. Lorsque le capteur 
PIR dÃ©tecte qu'une personne passe, le nombre sur l'affichage 4 segments 
s'incrÃ©mentera de 1. Vous pouvez utiliser ce compteur pour compter le nombre 
de personnes passant dans un couloir.

Composants
-------------

.. image:: img/list_Counting_Device1.png
    :align: center

.. image:: img/list_Counting_Device2.png
    :align: center

SchÃ©ma
---------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one1.png
   :align: center

ProcÃ©dures expÃ©rimentales
--------------------------------

**Ã‰tape 1** : Construisez le circuit.

.. image:: img/image235.png
   :alt: è®¡æ•°å™¨_bb
   :width: 800

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2** : AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.1/

**Ã‰tape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.1_CountingDevice.c -lwiringPi

**Ã‰tape 4** : ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

    <run></run>

.. code-block:: 
 
    sudo ./a.out
 
Une fois le code exÃ©cutÃ©, lorsque le capteur PIR dÃ©tecte le passage de quelqu'un, 
le nombre sur l'affichage Ã  4 segments s'incrÃ©mentera de 1.

Il y a deux potentiomÃ¨tres sur le module PIR : l'un ajuste la sensibilitÃ© et l'autre 
ajuste la distance de dÃ©tection. Pour un meilleur fonctionnement du module PIR, vous 
devez tourner les deux Ã  fond dans le sens antihoraire.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution, ou si un message d'erreur apparaÃ®t : \"wiringPi.h: No such file or directory\", veuillez consulter :ref:`C code is not working?`.

**Explication du code**

.. code-block:: c

    voidÂ display()
    {
        clearDisplay();
        pickDigit(0);
    Â Â Â Â hc595_shift(number[counterÂ %Â 10]);

        clearDisplay();
        pickDigit(1);
    Â Â Â Â hc595_shift(number[counterÂ %Â 100Â /Â 10]);

        clearDisplay();
        pickDigit(2);
    Â Â Â Â hc595_shift(number[counterÂ %Â 1000Â /Â 100]);
     
        clearDisplay();
        pickDigit(3);
    Â Â Â Â hc595_shift(number[counterÂ %Â 10000Â /Â 1000]);
    }

D'abord, le quatriÃ¨me segment de l'affichage est activÃ© et affiche le chiffre des 
unitÃ©s. Ensuite, le troisiÃ¨me segment affiche le chiffre des dizaines ; aprÃ¨s cela, 
le deuxiÃ¨me et le premier segment affichent respectivement les centaines et les milliers. 
GrÃ¢ce Ã  une vitesse de rafraÃ®chissement trÃ¨s rapide, nous voyons un affichage complet 
Ã  quatre chiffres.
.. code-block:: c

    voidÂ loop(){
    Â Â Â Â intÂ currentStateÂ =0;
    Â Â Â Â intÂ lastState=0;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â display();
    Â Â Â Â Â Â Â Â currentState=digitalRead(sensorPin);
    Â Â Â Â Â Â Â Â if((currentState==0)&&(lastState==1)){
    Â Â Â Â Â Â Â Â Â Â Â Â counterÂ +=1;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â }
    }

Il s'agit de la fonction principale : elle affiche le nombre sur l'afficheur Ã  4 segments et lit la valeur du capteur PIR. Lorsque le PIR dÃ©tecte qu'une personne passe, le nombre sur l'afficheur Ã  4 segments s'incrÃ©mente de 1.

**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2** : Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Ã‰tape 3** : ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.1_CountingDevice.py

AprÃ¨s l'exÃ©cution du code, lorsque le PIR dÃ©tecte le passage de quelqu'un, 
le nombre sur l'afficheur Ã  4 segments s'incrÃ©mentera de 1.


**Code**

.. note::

    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant cela, vous devez aller au chemin du code source tel que ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    sensorPin = 26

    SDI = 24
    RCLK = 23
    SRCLK = 18

    placePin = (10, 22, 27, 17)
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    counter = 0

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)    

    def hc595_shift(data): 
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

    def display():
        global counter                    
        clearDisplay() 
        pickDigit(0)  
        hc595_shift(number[counter % 10])

        clearDisplay()
        pickDigit(1)
        hc595_shift(number[counter % 100//10])

        clearDisplay()
        pickDigit(2)
        hc595_shift(number[counter % 1000//100])

        clearDisplay()
        pickDigit(3)
        hc595_shift(number[counter % 10000//1000])

    def loop():
        global counter
        currentState = 0
        lastState = 0
        while True:
            display()
            currentState=GPIO.input(sensorPin)
            if (currentState == 0) and (lastState == 1):
                counter +=1
            lastState=currentState

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for i in placePin:
            GPIO.setup(i, GPIO.OUT)
        GPIO.setup(sensorPin, GPIO.IN)

    def destroy():   # When "Ctrl+C" is pressed, the function is executed.
        GPIO.cleanup()

    if __name__ == '__main__':  # Program starting from here
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()

**Explication du code**

BasÃ© sur **1.1.5 Afficheur 7 segments Ã  4 chiffres**, cette leÃ§on ajoute le **module PIR** 
pour transformer le comptage automatique de la leÃ§on 1.1.5 en dÃ©tection de comptage. Lorsque 
le PIR dÃ©tecte qu'une personne passe, le nombre sur l'afficheur Ã  4 segments s'incrÃ©mentera de 1.

.. code-block:: python

    defÂ display():
    Â Â Â Â globalÂ counterÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
    Â Â Â Â clearDisplay()Â 
    Â Â Â Â pickDigit(0)Â Â 
    Â Â Â Â hc595_shift(number[counterÂ %Â 10])

    Â Â Â Â clearDisplay()
    Â Â Â Â pickDigit(1)
    Â Â Â Â hc595_shift(number[counterÂ %Â 100//10])

    Â Â Â Â clearDisplay()
    Â Â Â Â pickDigit(2)
    Â Â Â Â hc595_shift(number[counterÂ %Â 1000//100])

    Â Â Â Â clearDisplay()
    Â Â Â Â pickDigit(3)
    Â Â Â Â hc595_shift(number[counterÂ %Â 10000//1000])

D'abord, activez le quatriÃ¨me segment de l'affichage et Ã©crivez le chiffre des unitÃ©s. 
Ensuite, activez le troisiÃ¨me segment et entrez le chiffre des dizaines ; aprÃ¨s cela, 
activez successivement le deuxiÃ¨me et le premier segment pour afficher respectivement 
les centaines et les milliers. GrÃ¢ce Ã  une vitesse de rafraÃ®chissement trÃ¨s rapide, 
nous voyons un affichage complet Ã  quatre chiffres.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ counter
    Â Â Â Â currentStateÂ =Â 0
    Â Â Â Â lastStateÂ =Â 0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â display()
    Â Â Â Â Â Â Â Â currentState=GPIO.input(sensorPin)
    Â Â Â Â Â Â Â Â ifÂ (currentStateÂ ==Â 0)Â andÂ (lastStateÂ ==Â 1):
    Â Â Â Â Â Â Â Â Â Â Â Â counterÂ +=1
    Â Â Â Â Â Â Â Â lastState=currentStateÂ 

Il s'agit de la fonction principale : elle affiche le nombre sur l'afficheur Ã  4 segments 
et lit la valeur du PIR. Lorsque le PIR dÃ©tecte qu'une personne passe, le nombre sur 
l'afficheur Ã  4 segments s'incrÃ©mente de 1.

Image du phÃ©nomÃ¨ne
-------------------------

.. image:: img/image236.jpeg
