.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte Experto**: Resuelve problemas post-venta y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y Compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas Exclusivas**: Obt√©n acceso anticipado a anuncios de nuevos productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s nuevos.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones navide√±as.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy.

2.2.2 Thermistor
==================

Introducci√≥n
---------------

Al igual que el fotoresistor puede detectar la luz, el termistor es un 
dispositivo electr√≥nico sensible a la temperatura que se puede utilizar 
para realizar funciones de control de temperatura, como la activaci√≥n de 
una alarma de calor.

Componentes
-------------

.. image:: img/list_2.2.2_thermistor.png

Principio
------------

Un termistor es un resistor t√©rmicamente sensible que presenta un cambio 
preciso y predecible en su resistencia proporcional a peque√±as variaciones 
de temperatura. El grado de cambio en su resistencia depende de su composici√≥n 
√∫nica. Los termistores son parte de un grupo m√°s amplio de componentes pasivos. 
A diferencia de sus contrapartes activas, los dispositivos pasivos no son capaces 
de proporcionar ganancia de potencia o amplificaci√≥n a un circuito.

El termistor es un elemento sensible y tiene dos tipos: Coeficiente de Temperatura 
Negativo (NTC) y Coeficiente de Temperatura Positivo (PTC), tambi√©n conocidos como NTC y PTC. 
Su resistencia var√≠a significativamente con la temperatura. La resistencia del termistor PTC aumenta 
con la temperatura, mientras que en el caso del NTC es lo contrario. En este experimento utilizamos NTC.

.. image:: img/image325.png

El principio es que la resistencia del termistor NTC cambia con la temperatura del entorno. 
Detecta la temperatura en tiempo real del ambiente. Cuando la temperatura aumenta, la resistencia 
del termistor disminuye. Luego, los datos de voltaje se convierten en cantidades digitales mediante 
el adaptador A/D. La temperatura en grados Celsius o Fahrenheit se presenta a trav√©s de la programaci√≥n.

En este experimento, se utiliza un termistor y un resistor pull-up de 10k. Cada termistor tiene una resistencia 
normal. En este caso, es de 10k ohmios, medida a 25 grados Celsius.

Aqu√≠ est√° la relaci√≥n entre la resistencia y la temperatura:

R\ :sub:`T` =R\ :sub:`N` exp\ :sup:`B(1/TK ‚Äì 1/TN)`

**R\ T** es la resistencia del termistor NTC cuando la temperatura es **T\ K**.

**R\ N** es la resistencia del termistor NTC a la temperatura nominal **T\ N**. Aqu√≠, el valor num√©rico de **R\ N** es 10k.

**T\ K** es la temperatura en Kelvin y la unidad es K. Aqu√≠, el valor num√©rico de **T\ K** es 273.15 + grados Celsius.

**T\ N** es una temperatura nominal en Kelvin; la unidad tambi√©n es K. Aqu√≠, el valor num√©rico de **T\ N** es 273.15 + 25.

Y **B** (beta), la constante material del termistor NTC, tambi√©n se conoce como √≠ndice de sensibilidad t√©rmica, con un valor num√©rico de 3950.

**exp** es la abreviatura de exponencial, y el n√∫mero base e es un n√∫mero natural que es aproximadamente igual a 2.7.

Convierte esta f√≥rmula T\ :sub:`K`\ =1/(ln(R\ :sub:`T`/R\ :sub:`N`)/B+1/T\ :sub:`N`) para obtener la temperatura en Kelvin que menos 273.15 es igual a grados Celsius.

Esta relaci√≥n es una f√≥rmula emp√≠rica. Es precisa solo cuando la temperatura 
y la resistencia est√°n dentro del rango efectivo.

Diagrama Esquem√°tico
----------------------

.. image:: img/image323.png

.. image:: img/image324.png


Procedimientos Experimentales
--------------------------------

**Paso 1:** Construir el circuito.

.. image:: img/image202.png
    :width: 800

**Paso 2:** Acceder a la carpeta del c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.2/

**Paso 3:** Compilar el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.2_Thermistor.c -lwiringPi -lm

.. note::
    -lm se usa para cargar la biblioteca de matem√°ticas. No lo omitas, o se generar√° un error.


    **Paso 4:** Ejecuta el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Al ejecutar el c√≥digo, el termistor detectar√° la temperatura ambiente, 
que se imprimir√° en la pantalla una vez que termine el c√°lculo del programa.

.. note::

    Si no funciona despu√©s de ejecutar, o aparece un mensaje de error: \"wiringPi.h: No such file or directory", consulta :ref:`C code is not working?`.


**C√≥digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <math.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de extremo √∫nico
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // IMPAR
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci√≥n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        unsigned char analogVal;
        double Vr, Rt, temp, cel, Fah;
        if(wiringPiSetup() == -1){ // cuando la inicializaci√≥n de wiring falla, imprime mensaje en la pantalla
            printf("setup wiringPi failed !");
            return 1;
        }
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            Vr = 5 * (double)(analogVal) / 255;
            Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
            temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
            cel = temp - 273.15;
            Fah = cel * 1.8 +32;
            printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);
            delay(100);
        }
        return 0;
    }

**Explicaci√≥n del C√≥digo**

.. code-block:: c

    #include <math.h>

Aqu√≠ se incluye una biblioteca num√©rica de C que declara un conjunto de 
funciones para calcular operaciones y transformaciones matem√°ticas comunes.

.. code-block:: c

    analogVal = get_ADC_Result(0);

Esta funci√≥n se utiliza para leer el valor del termistor.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
    cel = temp - 273.15;
    Fah = cel * 1.8 +32;
    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Estos c√°lculos convierten los valores del termistor en valores en grados Celsius.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));

Estas dos l√≠neas de c√≥digo calculan la distribuci√≥n de voltaje con el valor 
anal√≥gico le√≠do para obtener Rt (resistencia del termistor).

.. code-block:: c

    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));

Este c√≥digo se refiere a la inserci√≥n de Rt en la f√≥rmula 
**T\ K\ =1/(ln(R\ T/R\ N)/B+1/T\ N)** para obtener la temperatura en Kelvin.

.. code-block:: c

    temp = temp - 273.15;

Convierte la temperatura en Kelvin a grados Celsius.

.. code-block:: c

    Fah = cel * 1.8 +32;

Convierte los grados Celsius a Fahrenheit.

.. code-block:: c

    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Imprime el grado cent√≠grado, el grado Fahrenheit y sus unidades en la pantalla.
