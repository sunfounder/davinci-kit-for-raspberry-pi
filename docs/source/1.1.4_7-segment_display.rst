.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez plus profond√©ment dans Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et vos d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des conseils et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions exclusives** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions saisonni√®res.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.1.4 Affichage 7 segments
==============================

Introduction
---------------

Essayons de piloter un afficheur 7 segments pour afficher des chiffres de 0 √† 9 et des lettres de A √† F.

Composants
-------------

.. image:: img/list_7_segment.png

Principe
-----------

**Afficheur 7 segments**

Un afficheur 7 segments est un composant en forme de 8 qui regroupe 7 LEDs. Chaque 
LED est appel√©e un segment. Lorsqu'un segment est aliment√©, il forme une partie du 
chiffre ou de la lettre √† afficher.

Il existe deux types de connexions de broches : cathode commune (CC) et anode commune 
(CA). Comme leur nom l'indique, un afficheur CC a toutes les cathodes des 7 LEDs 
connect√©es ensemble, tandis qu'un afficheur CA a toutes les anodes connect√©es ensemble. 
Dans ce kit, nous utilisons le mod√®le √† cathode commune.

.. image:: img/image70.jpeg
   :width: 3.89514in
   :height: 3.32222in
   :align: center

Chaque LED de l'afficheur est associ√©e √† un segment positionnel, avec une broche de 
connexion correspondante. Ces broches sont √©tiquet√©es de "a" √† "g", repr√©sentant chaque 
LED individuelle. Les autres broches sont connect√©es ensemble pour former une broche 
commune. En polarisant les broches appropri√©es dans un ordre particulier, certains 
segments s'illumineront tandis que d'autres resteront √©teints, affichant ainsi le 
chiffre ou la lettre d√©sir√©e.

**Codes d'affichage**

Pour mieux comprendre comment les afficheurs 7 segments (cathode commune) affichent les 
chiffres, nous avons dress√© le tableau suivant. Les chiffres de 0 √† F sont repr√©sent√©s 
sur l'afficheur 7 segments. Le tableau GFEDCBA se r√©f√®re aux LED correspondantes qui sont 
activ√©es (0 ou 1). Par exemple, 00111111 signifie que DP et G sont r√©gl√©s √† 0, tandis que 
les autres sont √† 1. Cela affiche le chiffre 0 sur l'afficheur 7 segments, tandis que le 
code HEX correspond au nombre en hexad√©cimal.

.. image:: img/common_cathode.png

**74HC595**

Le 74HC595 est compos√© d'un registre √† d√©calage de 8 bits et d'un registre de stockage avec 
sorties parall√®les √† trois √©tats. Il convertit l'entr√©e s√©rie en sortie parall√®le, permettant 
ainsi d'√©conomiser les ports d'E/S d'un microcontr√¥leur.

Lorsque MR (broche 10) est √† niveau haut et que OE (broche 13) est √† niveau bas, les donn√©es 
sont saisies sur le front montant de SHcp et vont dans le registre de m√©moire via le front 
montant de SHcp. Si les deux horloges sont connect√©es ensemble, le registre √† d√©calage est 
toujours un impulsion en avance par rapport au registre de m√©moire. Il y a une broche 
d'entr√©e s√©rie (Ds), une broche de sortie s√©rie (Q) et un bouton de r√©initialisation 
asynchrone (niveau bas) dans le registre de m√©moire. Le registre de m√©moire fournit 
une sortie parall√®le 8 bits en trois √©tats. Lorsque OE est activ√© (niveau bas), les 
donn√©es du registre de m√©moire sont envoy√©es sur le bus.

.. image:: img/74hc595_sche.png
    :width: 400
    :align: center

**Broches du 74HC595 et leurs fonctions** :

* **Q0-Q7** : Broches de sortie de donn√©es parall√®les 8 bits, capables de contr√¥ler directement 8 LEDs ou 8 segments d'un afficheur 7 segments.
* **Q7'** : Broche de sortie s√©rie, connect√©e √† DS d'un autre 74HC595 pour les connecter en s√©rie.
* **MR** : Broche de r√©initialisation, active √† niveau bas.
* **SHcp** : Entr√©e de s√©quence temporelle du registre √† d√©calage. Sur le front montant, les donn√©es du registre √† d√©calage se d√©placent successivement d'un bit, par exemple, les donn√©es en Q1 se d√©placent vers Q2, et ainsi de suite. Sur le front descendant, les donn√©es du registre √† d√©calage restent inchang√©es.

* **STcp** : Entr√©e de s√©quence temporelle du registre de stockage. Sur le front montant, les donn√©es du registre √† d√©calage se d√©placent dans le registre de m√©moire.

* **CE** : Broche d'activation de sortie, active √† niveau bas.
* **DS** : Broche d'entr√©e de donn√©es s√©rie.
* **VCC** : Tension d'alimentation positive.
* **GND** : Masse.

Sch√©ma de montage
-------------------

Connectez la broche ST_CP du 74HC595 au GPIO18 du Raspberry Pi, SH_CP au GPIO27, DS 
au GPIO17, et les ports de sortie parall√®les aux 8 segments de l'afficheur √† 7 segments. 
Les donn√©es sont saisies via la broche DS dans le registre √† d√©calage lorsque SH_CP 
(l'entr√©e d'horloge du registre √† d√©calage) est au front montant, et dans le registre de 
m√©moire lorsque ST_CP (l'entr√©e d'horloge du registre de m√©moire) est au front montant. 
Vous pouvez ensuite contr√¥ler les √©tats de SH_CP et ST_CP via les GPIOs du Raspberry Pi 
pour convertir les donn√©es d'entr√©e s√©rie en sortie parall√®le, √©conomisant ainsi des GPIOs 
du Raspberry Pi et pilotant l'affichage.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: img/schematic_7_segment.png
    :width: 800

Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image73.png
    :width: 800

Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

√âtape 2 : Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.1.4/

√âtape 3 : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.4_7-Segment.c -lwiringPi

√âtape 4 : Ex√©cutez le fichier ex√©cutable ci-dessus.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, vous verrez l'affichage 7 segments afficher les chiffres de 0 √† 9, puis les lettres de A √† F.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou si un message d'erreur appara√Æt : "wiringPi.h: No such file or directory", veuillez consulter :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define   SDI   0   //entr√©e de donn√©es s√©rie
    #define   RCLK  1   //entr√©e d'horloge m√©moire (STCP)
    #define   SRCLK 2   //entr√©e d'horloge registre √† d√©calage (SHCP)
    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

    void hc595_shift(unsigned char dat){
        int i;
        for(i=0;i<8;i++){
            digitalWrite(SDI, 0x80 & (dat << i));
            digitalWrite(SRCLK, 1);
            delay(1);
            digitalWrite(SRCLK, 0);
        }
            digitalWrite(RCLK, 1);
            delay(1);
            digitalWrite(RCLK, 0);
    }

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //en cas d'√©chec de l'initialisation de wiring, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        init();
        while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }
        return 0;
    }


**Explication du Code**

unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
Un tableau de codes de segments de 0 √† F en Hexad√©cimal (cathode commune).

.. code-block:: c

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT); 
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

Configurer les trois broches ds, st_cp, sh_cp comme des sorties, et d√©finir 
l'√©tat initial √† 0.

.. code-block:: c

    digitalWrite(SDI, 0x80 & (dat << i));

Assigner les donn√©es dat √† SDI(DS) bit par bit. Si dat=0x3f(0011 1111), quand i=2, 
0x3f se d√©calera de 2 bits vers la gauche. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) 
= 1000 0000, est vrai.

.. code-block:: c

    digitalWrite(SRCLK, 1);

La valeur initiale de SRCLK √©tait √† 0, et ici elle est mise √† 1, ce qui g√©n√®re une impulsion montante, puis d√©place la donn√©e DS vers le registre √† d√©calage.

.. code-block:: c
        
    digitalWrite(RCLK, 1);

La valeur initiale de RCLK √©tait √† 0, et ici elle est mise √† 1, ce qui g√©n√®re une impulsion montante, puis d√©place les donn√©es du registre √† d√©calage vers le registre de stockage.

.. code-block:: c

    while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }

Dans cette boucle for, nous utilisons \"%1X\" pour afficher i en tant que nombre hexad√©cimal. Appliquez i pour trouver le code de segment correspondant dans le tableau SegCode[], et utilisez hc595_shift() pour passer le code SegCode au registre √† d√©calage du 74HC595.

Pour les utilisateurs du langage Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

√âtape 2 : Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

√âtape 3 : Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.4_7-Segment.py

Apr√®s l'ex√©cution du code, l'affichage 7 segments affichera 0-9, A-F.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source du code comme ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # D√©finir les broches
    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    # D√©finir un code de segment de 0 √† F en Hexad√©cimal
    # Cathode commune
    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

    # Transf√©rer les donn√©es au 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8):    
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            time.sleep(0.001)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(RCLK, GPIO.LOW)

    def main():
        while True:
            # Transf√©rer le code un par un depuis la liste segCode
            for code in segCode:
                hc595_shift(code)
                print ("segCode[%s]: 0x%02X"%(segCode.index(code), code)) # %02X means double digit HEX to print
                time.sleep(0.5)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

Un tableau de codes de segments de 0 √† F en Hexad√©cimal (cathode commune). 

.. code-block:: python

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

Configurer les trois broches ds, st_cp, sh_cp comme des sorties, et d√©finir l'√©tat initial √† bas niveau.

.. code-block:: python

    GPIO.output(SDI, 0x80 & (dat << bit))

Assigner les donn√©es dat √† SDI(DS) bit par bit. Ici, si dat=0x3f (0011 1111), lorsque bit=2, 0x3f sera d√©cal√© de 2 bits vers la gauche. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, ce qui est vrai.

.. code-block:: python

    GPIO.output(SRCLK, GPIO.HIGH)

La valeur initiale de SRCLK √©tait √† LOW, et ici elle est d√©finie √† HIGH, ce qui g√©n√®re une impulsion montante, d√©pla√ßant ensuite la donn√©e DS vers le registre √† d√©calage.

.. code-block:: python

    GPIO.output(RCLK, GPIO.HIGH)

La valeur initiale de RCLK √©tait √† LOW, et ici elle est d√©finie √† HIGH, ce qui g√©n√®re une impulsion montante, puis transf√®re les donn√©es du registre √† d√©calage vers le registre de stockage.

.. note::
    Le format hexad√©cimal des nombres de 0 √† 15 est (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

Image du ph√©nom√®ne
-------------------------

.. image:: img/image74.jpeg

