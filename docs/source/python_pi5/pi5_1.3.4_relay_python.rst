.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum√©rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances Exclusivos**: Accede anticipadamente a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Aprovecha descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo.

.. _1.3.4_py_pi5:

1.3.4 Rel√©
=============

Introducci√≥n
---------------

En este proyecto, aprenderemos a utilizar un rel√©, uno de los componentes 
m√°s comunes en los sistemas de control autom√°tico. Cuando la tensi√≥n, corriente, 
temperatura, presi√≥n, etc., alcanza, supera o est√° por debajo de un valor 
predeterminado, el rel√© conecta o interrumpe el circuito para controlar y proteger 
el equipo.

Componentes Necesarios
---------------------------

En este proyecto, necesitamos los siguientes componentes. 

.. image:: ../python_pi5/img/1.3.4_relay_list.png

.. raw:: html

   <br/>

Diagrama de Conexiones
--------------------------

.. image:: ../python_pi5/img/1.3.4_relay_schematic.png


Procedimientos del Experimento
----------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../python_pi5/img/1.3.4_relay_circuit.png

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5


**Paso 3:** Ejecuta el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.4_Relay.py

Al ejecutar el c√≥digo, el LED se encender√°. Adem√°s, podr√°s escuchar un 
tic-tac producido por la apertura del contacto normalmente cerrado y el 
cierre del contacto normalmente abierto.

.. warning::

    Si aparece el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulta :ref:`faq_soc` 

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Antes de eso, aseg√∫rate de estar en la ruta del c√≥digo fuente, como ``davinci-kit-for-raspberry-pi/python-pi5``. Despu√©s de modificar el c√≥digo, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice  # Importa la clase para controlar pines GPIO
   from time import sleep  # Importa la funci√≥n sleep para a√±adir retardo

   # Inicializa el rel√© conectado al pin GPIO 17
   relay = OutputDevice(17)

   try:
       # Bucle para alternar continuamente el estado del rel√© cada segundo
       while True:
           print('Relay open...')  # Informa que el rel√© est√° activado
           relay.on()  # Enciende el rel√© (suponiendo configuraci√≥n activa baja)
           sleep(1)   # Mant√©n el rel√© encendido durante 1 segundo

           print('...Relay close')  # Informa que el rel√© est√° desactivado
           relay.off()  # Apaga el rel√©
           sleep(1)   # Mant√©n el rel√© apagado durante 1 segundo

   except KeyboardInterrupt:
       # Maneja una interrupci√≥n de teclado (Ctrl+C) para salir del bucle
       relay.off()  # Asegura que el rel√© est√© apagado antes de salir
       pass


**Explicaci√≥n del C√≥digo**

#. Se importan ``OutputDevice`` de ``gpiozero`` para el control de pines GPIO y ``sleep`` de ``time`` para a√±adir retardos.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice  # Importa la clase para controlar pines GPIO
       from time import sleep  # Importa la funci√≥n sleep para a√±adir retardo

#. Inicializa un objeto ``OutputDevice`` para el rel√© conectado al pin GPIO 17. 

   .. code-block:: python

       # Inicializa el rel√© conectado al pin GPIO 17
       relay = OutputDevice(17)

#. Dentro del bloque ``try``, un bucle ``while True`` alterna continuamente el estado del rel√©. El rel√© se enciende y apaga con un retardo de 1 segundo entre cada estado, acompa√±ado de mensajes en la consola.

   .. code-block:: python

       try:
           # Bucle para alternar continuamente el estado del rel√© cada segundo
           while True:
               print('Relay open...')  # Informa que el rel√© est√° activado
               relay.on()  # Enciende el rel√© (suponiendo configuraci√≥n activa baja)
               sleep(1)   # Mant√©n el rel√© encendido durante 1 segundo

               print('...Relay close')  # Informa que el rel√© est√° desactivado
               relay.off()  # Apaga el rel√©
               sleep(1)   # Mant√©n el rel√© apagado durante 1 segundo

#. Captura una interrupci√≥n de teclado (como Ctrl+C) para permitir una finalizaci√≥n del script de forma segura. El rel√© se apaga antes de salir del script.

   .. code-block:: python
      
      except KeyboardInterrupt:
      # Maneja una interrupci√≥n de teclado (Ctrl+C) para salir del bucle
      relay.off()  # Asegura que el rel√© est√© apagado antes de salir
      pass

