.. note::

    Bonjour, bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, d'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et concours** : Participez √† des concours et promotions pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.4 Capteur PIR
===================

Introduction
---------------

Dans ce projet, nous allons fabriquer un dispositif √† l'aide de capteurs 
pyroelectriques infrarouges pour le corps humain. Lorsque quelqu'un s'approche, 
la LED s'allumera automatiquement. Sinon, la lumi√®re s'√©teindra. Ce capteur de 
mouvement infrarouge est un type de capteur capable de d√©tecter l'infrarouge √©mis 
par les humains et les animaux.

Composants
-----------

.. image:: img/list_2.2.4_pir.png


Principe
--------

Le capteur PIR d√©tecte la radiation thermique infrarouge √©mise par des organismes et 
peut √™tre utilis√© pour d√©tecter la pr√©sence d'√™tres vivants qui √©mettent cette radiation.

Le capteur PIR est divis√© en deux emplacements reli√©s √† un amplificateur diff√©rentiel. 
Lorsque qu'un objet immobile se trouve devant le capteur, les deux emplacements re√ßoivent 
la m√™me quantit√© de radiation, et la sortie est nulle. Lorsqu'un objet en mouvement 
passe devant le capteur, l'un des emplacements re√ßoit plus de radiation que l'autre, 
provoquant une variation de la sortie en tension. Cette variation est le r√©sultat de 
la d√©tection du mouvement.

.. image:: img/image211.png
    :width: 200



Apr√®s le c√¢blage du module, une phase d'initialisation d'une minute commence. Pendant 
cette phase, le module √©mettra de 0 √† 3 impulsions √† intervalles r√©guliers. Ensuite, 
le module passe en mode veille. Veillez √† √©loigner les sources lumineuses et autres 
interf√©rences de la surface du module pour √©viter les erreurs caus√©es par des signaux 
parasites. Il est pr√©f√©rable d'utiliser le module dans un environnement sans trop de vent, 
car cela peut aussi affecter le capteur.

.. image:: img/image212.png
    :width: 400



**R√©glage de la distance**


En tournant le bouton du potentiom√®tre de r√©glage de la distance dans le sens des aiguilles 
d'une montre, la port√©e de d√©tection augmente, la port√©e maximale de d√©tection est d'environ 
0 √† 7 m√®tres. Si vous tournez le bouton dans le sens inverse, la port√©e de d√©tection diminue, 
avec une port√©e minimale d'environ 0 √† 3 m√®tres.

**R√©glage du d√©lai**


En tournant le bouton du potentiom√®tre de r√©glage du d√©lai dans le sens des aiguilles 
d'une montre, vous pouvez augmenter le d√©lai de d√©tection, qui peut atteindre un maximum 
de 300 secondes. Inversement, en le tournant dans le sens inverse, vous pouvez r√©duire le 
d√©lai avec un minimum de 5 secondes.

Deux modes de d√©clenchement : (choix du mode via un cavalier).

-  **H : Mode de d√©clenchement r√©p√©titif**, apr√®s d√©tection d'une pr√©sence humaine, le 
module √©met un signal de niveau haut. Pendant la p√©riode de d√©lai suivante, si quelqu'un 
entre dans la zone de d√©tection, la sortie restera √† un niveau haut.

-  **L : Mode de d√©clenchement non r√©p√©titif**, √©met un signal de niveau haut lorsque la 
pr√©sence d'une personne est d√©tect√©e. Apr√®s le d√©lai, la sortie revient automatiquement √† 
un niveau bas.



Sch√©ma de c√¢blage
--------------------

.. image:: img/image327.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image214.png
    :width: 800



Pour les utilisateurs de langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.4/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.4_PIR.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s ex√©cution du code, le PIR d√©tecte les mouvements et fait briller la LED RGB en 
jaune s'il d√©tecte quelqu'un qui passe. Il y a deux potentiom√®tres sur le module PIR : 
l'un pour r√©gler la sensibilit√© et l'autre pour ajuster la distance de d√©tection. Pour 
optimiser le fonctionnement du module PIR, tournez-les tous les deux dans le sens inverse 
des aiguilles d'une montre jusqu'√† la but√©e.

.. image:: img/PIR_TTE.png

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou si une erreur appara√Æt: \"wiringPi.h: 
     Aucun fichier ou r√©pertoire de ce type", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softPwm.h>
    #include <stdio.h>
    #define uchar unsigned char

    #define pirPin    0     // le capteur PIR est connect√© au GPIO0
    #define redPin    1
    #define greenPin  2
    #define bluePin   3

    void ledInit(void){
        softPwmCreate(redPin,  0, 100);
        softPwmCreate(greenPin,0, 100);
        softPwmCreate(bluePin, 0, 100);
    }
    void ledColorSet(uchar r_val, uchar g_val, uchar b_val){
        softPwmWrite(redPin,   r_val);
        softPwmWrite(greenPin, g_val);
        softPwmWrite(bluePin,  b_val);
    }
    int main(void)
    {
        int pir_val;
        if(wiringPiSetup() == -1){ // Si l'initialisation de wiringPi √©choue, affiche un message
            printf("setup wiringPi failed !");
            return 1;
        }
        ledInit();
        pinMode(pirPin, INPUT);
        while(1){
            pir_val = digitalRead(pirPin);
            if(pir_val== 1){ // si la lecture du PIR est de niveau haut
                ledColorSet(0xff,0xff,0x00); // Allume la LED en jaune
            }
            else {
                ledColorSet(0x00,0x00,0xff); // Allume la LED en bleu
            }
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    void ledInit(void);
    void ledColorSet(uchar r_val, uchar g_val, uchar b_val);

Ces fonctions sont utilis√©es pour d√©finir la couleur de la LED RGB. Veuillez vous 
r√©f√©rer √† la section :ref:`1.1.2 RGB LED` pour plus de d√©tails.

.. code-block:: c

    int main(void)
    {
        int pir_val;
        //‚Ä¶‚Ä¶
        pinMode(pirPin, INPUT);
        while(1){
            pir_val = digitalRead(pirPin);
            if(pir_val== 1){ // si la lecture du PIR est de niveau haut
                ledColorSet(0xff,0xff,0x00); // Allume la LED en jaune
            }
            else {
                ledColorSet(0x00,0x00,0xff); // Allume la LED en bleu
            }
        }
        return 0;
    }

Lorsque le capteur PIR d√©tecte un spectre infrarouge humain, la LED RGB s'allume en jaune ; sinon, elle s'allume en bleu.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Allez dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.4_PIR.py

Apr√®s l'ex√©cution du code, le capteur PIR d√©tecte les mouvements et fait briller 
la LED RGB en jaune lorsqu'il d√©tecte quelqu'un. Il y a deux potentiom√®tres sur le 
module PIR : l'un pour ajuster la sensibilit√© et l'autre pour r√©gler la distance de 
d√©tection. Pour un meilleur fonctionnement du module PIR, tournez-les tous les deux 
dans le sens inverse des aiguilles d'une montre jusqu'√† la fin.

.. image:: img/PIR_TTE.png

**Code**
.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le r√©pertoire source du code, tel que ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    rgbPins = {'Red':18, 'Green':27, 'Blue':22}
    pirPin = 17    # le pir est connect√© √† la broche 17

    def setup():
        global p_R, p_G, p_B
        GPIO.setmode(GPIO.BCM)    # Configuration du mode GPIO en num√©rotation BCM
        GPIO.setup(pirPin, GPIO.IN)    # Configuration de pirPin en entr√©e
        # Configuration des broches LED en sortie et initialisation √† un niveau haut (3,3v)
        for i in rgbPins:
            GPIO.setup(rgbPins[i], GPIO.OUT, initial=GPIO.HIGH)

        # Configuration de la PWM pour chaque LED avec une fr√©quence de 2 kHz
        p_R = GPIO.PWM(rgbPins['Red'], 2000)
        p_G = GPIO.PWM(rgbPins['Green'], 2000)
        p_B = GPIO.PWM(rgbPins['Blue'], 2000)

        # Initialisation des PWM √† 0
        p_R.start(0)
        p_G.start(0)
        p_B.start(0)

    # D√©finition d'une fonction MAP pour convertir les valeurs de 0~255 √† 0~100
    def MAP(x, in_min, in_max, out_min, out_max):
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

    # D√©finition d'une fonction pour r√©gler les couleurs
    def setColor(color):
    # Configure la luminance des trois LEDs en fonction de la valeur de couleur
        # Extraction des valeurs RVB de la variable 'color'
        R_val = (color & 0xFF0000) >> 16
        G_val = (color & 0x00FF00) >> 8
        B_val = (color & 0x0000FF)
        # Conversion des valeurs de 0~255 √† 0~100
        R_val = MAP(R_val, 0, 255, 0, 100)
        G_val = MAP(G_val, 0, 255, 0, 100)
        B_val = MAP(B_val, 0, 255, 0, 100)
        
        # Modification du cycle de fonctionnement de la PWM en fonction de la luminance calcul√©e
        p_R.ChangeDutyCycle(R_val)
        p_G.ChangeDutyCycle(G_val)
        p_B.ChangeDutyCycle(B_val)

    def loop():
        while True:
            pir_val = GPIO.input(pirPin)
            if pir_val == GPIO.HIGH:
                setColor(0xFFFF00)  # Couleur jaune si mouvement d√©tect√©
            else :
                setColor(0x0000FF)  # Couleur bleue sinon

    def destroy():
        p_R.stop()
        p_G.stop()
        p_B.stop()
        GPIO.cleanup()  # Lib√©ration des ressources

    if __name__ == '__main__':  # Programme principal
        setup()
        try:
            loop()
        except KeyboardInterrupt:  # Ex√©cution de la fonction destroy en cas d'interruption
            destroy()

**Explication du code**

.. code-block:: python

    rgbPins = {'Red':18, 'Green':27, 'Blue':22}

    def setup():
        global p_R, p_G, p_B
        GPIO.setmode(GPIO.BCM)
        # ‚Ä¶
        for i in rgbPins:
            GPIO.setup(rgbPins[i], GPIO.OUT, initial=GPIO.HIGH)
        p_R = GPIO.PWM(rgbPins['Red'], 2000)
        p_G = GPIO.PWM(rgbPins['Green'], 2000)
        p_B = GPIO.PWM(rgbPins['Blue'], 2000)
        p_R.start(0)
        p_G.start(0)
        p_B.start(0)

    def MAP(x, in_min, in_max, out_min, out_max):
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min

    def setColor(color):
    ...

Ces lignes de code sont utilis√©es pour r√©gler la couleur de la LED RVB, veuillez consulter :ref:`1.1.2 LED RVB` pour plus de d√©tails.

.. code-block:: python

    def loop():
        while True:
            pir_val = GPIO.input(pirPin)
            if pir_val==GPIO.HIGH:
                setColor(0xFFFF00)
            else :
                setColor(0x0000FF)

Lorsque le PIR d√©tecte le spectre infrarouge d'un humain, la LED RVB √©met une lumi√®re jaune ; sinon, elle √©met une lumi√®re bleue.

Image du ph√©nom√®ne
---------------------

.. image:: img/image215.jpeg