.. note::

    ¬°Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **¬øPor qu√© unirte?**

    - **Soporte experto**: Resuelve problemas post-venta y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances exclusivos**: Accede anticipadamente a anuncios de nuevos productos y vistas previas.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones navide√±as.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy.

2.1.4 Potenci√≥metro
======================

Introducci√≥n
----------------

La funci√≥n ADC se puede utilizar para convertir se√±ales anal√≥gicas en 
se√±ales digitales, y en este experimento, se utiliza el ADC0834 para 
obtener la funci√≥n que involucra ADC. Aqu√≠, implementamos este proceso 
utilizando un potenci√≥metro. El potenci√≥metro cambia la magnitud f√≠sica 
‚Äî voltaje, que es convertido por la funci√≥n ADC.

Componentes
----------------

.. image:: img/list_2.1.4_potentiometer.png


Principio
------------

**ADC0834**

El ADC0834 es un convertidor anal√≥gico a digital de 8 bits de `successive
approximation <https://cn.bing.com/dict/search?q=successive approximations&FORM=BDVSP6&mkt=zh-cn>`__ 
que est√° equipado con un multiplexor multicanal configurable en entrada y con entrada/salida en serie. 
La entrada/salida en serie est√° configurada para conectarse con registros de desplazamiento est√°ndar o microprocesadores.

.. image:: img/image309.png


**Secuencia de Operaci√≥n**

La conversi√≥n se inicia configurando CS en bajo, lo que activa todos 
los circuitos l√≥gicos. CS debe mantenerse en bajo durante todo el proceso 
de conversi√≥n. Luego, se recibe una entrada de reloj del procesador. 
En cada transici√≥n de bajo a alto del reloj, los datos en DI se cargan 
en el registro de desplazamiento de la direcci√≥n del multiplexor. 
El primer nivel alto en la entrada es el bit de inicio. A continuaci√≥n, 
se env√≠a una palabra de asignaci√≥n de 3 a 4 bits despu√©s del bit de inicio. 
En cada transici√≥n sucesiva de bajo a alto del reloj, el bit de inicio y la 
palabra de asignaci√≥n se desplazan a trav√©s del registro de desplazamiento. 
Cuando el bit de inicio se desplaza a la ubicaci√≥n de inicio del registro 
del multiplexor, se selecciona el canal de entrada y comienza la conversi√≥n. 
La salida del estado del SAR (SARS) se eleva para indicar que una conversi√≥n 
est√° en curso, y DI al registro de desplazamiento del multiplexor se desactiva 
durante la duraci√≥n de la conversi√≥n.

Se inserta autom√°ticamente un intervalo de un per√≠odo de reloj para permitir 
que el canal multiplexado seleccionado se estabilice. La salida de datos DO 
sale del estado de alta impedancia y proporciona un nivel bajo durante este 
per√≠odo de tiempo de estabilizaci√≥n del multiplexor. El comparador SAR compara 
las salidas sucesivas de la escalera resistiva con la se√±al anal√≥gica entrante. 
La salida del comparador indica si la entrada anal√≥gica es mayor o menor que la 
salida de la escalera resistiva. A medida que avanza la conversi√≥n, los datos de 
conversi√≥n se env√≠an simult√°neamente desde el pin de salida DO, siendo el bit m√°s 
significativo (MSB) el primero.

Despu√©s de ocho per√≠odos de reloj, la conversi√≥n est√° completa y la salida SARS 
baja. Finalmente, se env√≠an primero los datos del bit menos significativo tras 
la transmisi√≥n de datos del bit m√°s significativo.

.. image:: img/image175.png
    :width: 800
    :align: center


**TABLA DE L√ìGICA DE CONTROL DE DIRECCI√ìN MUX DEL ADC0834**

.. image:: img/image176.png
    :width: 800
    :align: center


**Potenci√≥metro**

El potenci√≥metro es tambi√©n un componente resistivo con 3 terminales y su valor 
de resistencia puede ajustarse seg√∫n alguna variaci√≥n regular. El potenci√≥metro 
generalmente consiste en un resistor y un cepillo m√≥vil. Cuando el cepillo se 
desplaza a lo largo del resistor, hay una cierta resistencia o voltaje de salida 
dependiendo del desplazamiento.

.. image:: img/image310.png
    :width: 300
    :align: center


Las funciones del potenci√≥metro en el circuito son las siguientes:

1. Servir como divisor de voltaje

El potenci√≥metro es un resistor ajustable de forma continua. Cuando ajustas 
el eje o el mango deslizante del potenci√≥metro, el contacto m√≥vil se desliza 
sobre el resistor. En este punto, se puede obtener un voltaje dependiendo del 
voltaje aplicado al potenci√≥metro y del √°ngulo que ha rotado el brazo m√≥vil o 
la distancia que ha recorrido.

Diagrama Esquem√°tico
------------------------

.. image:: img/image311.png


.. image:: img/image312.png


Procedimientos Experimentales
------------------------------------

**Paso 1:** Construir el circuito.

.. image:: img/image180.png
    :width: 800

.. note::
    Por favor, coloca el chip en la posici√≥n correspondiente indicada en 
    la imagen. Ten en cuenta que las ranuras en el chip deben estar a la 
    izquierda cuando se coloque.

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.4/

**Paso 3:** Compila el c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.4_Potentiometer.c -lwiringPi

**Paso 4:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu√©s de que el c√≥digo se ejecute, gira el knob en el potenci√≥metro, la 
intensidad del LED cambiar√° en consecuencia.

.. note::

    Si no funciona despu√©s de ejecutarlo, o si aparece un mensaje de error: \"wiringPi.h: No such file or directory", consulta :ref:`C code is not working?`.
**C√≥digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de extremo √∫nico
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // IMPAR
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci√≥n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        uchar analogVal;
        if(wiringPiSetup() == -1){ // si la inicializaci√≥n de wiring falla, imprime un mensaje en pantalla
            printf("setup wiringPi failed !");
            return 1;
        }
        softPwmCreate(LedPin,  0, 100);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            delay(100);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }
        return 0;
    }

**Explicaci√≥n del c√≥digo**

.. code-block:: c

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

Define CS, CLK y DIO del ADC0834, y con√©ctalos a GPIO0, GPIO1 y GPIO2 
respectivamente. Luego conecta el LED a GPIO3.

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de inicio
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Modo de extremo √∫nico
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // IMPAR
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Selecci√≥n
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

Hay una funci√≥n de ADC0834 para realizar la conversi√≥n de anal√≥gico a digital. 
El flujo de trabajo espec√≠fico es el siguiente:

.. code-block:: c

    digitalWrite(ADC_CS, 0);

Establece CS en nivel bajo y comienza a habilitar la conversi√≥n AD.

.. code-block:: c

    // Bit de inicio
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
Cuando ocurre la transici√≥n de bajo a alto del reloj por primera vez, se 
establece DIO en 1 como bit de inicio. En los siguientes tres pasos, hay 
3 palabras de asignaci√≥n.

.. code-block:: c

    // Modo de extremo √∫nico
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Tan pronto como la transici√≥n de bajo a alto del reloj ocurre por segunda vez, 
se establece DIO en 1 y se elige el modo SGL.

.. code-block:: c

    // IMPAR
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Cuando ocurre por tercera vez, el valor de DIO es controlado por la variable **odd**.

.. code-block:: c

    // Selecci√≥n
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);

La pulso de CLK convertida de bajo a alto por cuarta vez, el valor de DIO 
es controlado por la variable **sel**.

Bajo la condici√≥n de que channel=0, sel=0, odd=0, las f√≥rmulas operativas 
relativas a **sel** y **odd** son las siguientes:

.. code-block:: c

    int sel = channel > 1 & 1;
    int odd = channel & 1;

Cuando se cumple la condici√≥n de que channel=1, sel=0, odd=1, consulta la 
siguiente tabla de l√≥gica de control de direcci√≥n. Aqu√≠ se elige CH1, y el 
bit de inicio se desplaza a la ubicaci√≥n de inicio del registro del multiplexor 
y comienza la conversi√≥n.

.. image:: img/image313.png


.. code-block:: c

    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

Aqu√≠, se establece DIO en 1 dos veces, por favor ign√≥ralo.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

En la primera declaraci√≥n for(), tan pronto como el quinto pulso de CLK 
se convierte de alto a bajo, se establece DIO en modo de entrada. Luego, 
comienza la conversi√≥n y el valor convertido se almacena en la variable dat1. 
Despu√©s de ocho per√≠odos de reloj, la conversi√≥n est√° completa.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

En la segunda declaraci√≥n for(), se env√≠an los valores convertidos a trav√©s 
de DO despu√©s de otros ocho per√≠odos de reloj y se almacenan en la variable dat2.

.. code-block:: c

    digitalWrite(ADC_CS,1);
    pinMode(ADC_DIO, OUTPUT);
    return(dat1==dat2) ? dat1 : 0;

return(dat1==dat2) ? dat1 : 0 se utiliza para comparar el valor obtenido 
durante la conversi√≥n y el valor de salida. Si son iguales, se devuelve el 
valor convertido dat1; de lo contrario, se devuelve 0. Aqu√≠, el flujo de 
trabajo del ADC0834 se completa.

.. code-block:: c

    softPwmCreate(LedPin,  0, 100);

La funci√≥n es utilizar software para crear un pin PWM, LedPin, luego se 
establece el ancho de pulso inicial en 0 y el per√≠odo de PWM en 100 x 100us.

.. code-block:: c

    while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }

En el programa principal, se lee el valor del canal 0 que ha sido conectado 
a un potenci√≥metro. Y se almacena el valor en la variable analogVal y luego 
se escribe en LedPin. Ahora puedes ver c√≥mo cambia el brillo del LED con el 
valor del potenci√≥metro.
