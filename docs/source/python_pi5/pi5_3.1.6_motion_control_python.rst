.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder d√©di√©e aux passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions et tirages au sort festifs** : Participez √† des tirages au sort et des promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

.. _3.1.6_py_pi5:

3.1.6 Contr√¥le de Mouvement
==============================

Introduction
---------------

Dans cette le√ßon, nous allons cr√©er un dispositif simple de d√©tection et de 
contr√¥le de mouvement. Le capteur MPU6050 sera utilis√© comme d√©tecteur et le 
moteur pas √† pas comme appareil contr√¥l√©. Avec le MPU6050 mont√© sur un gant, 
vous pouvez contr√¥ler le moteur pas √† pas en tournant votre poignet.

Composants N√©cessaires
---------------------------

Dans ce projet, nous aurons besoin des composants suivants :

.. image:: ../python_pi5/img/3.1.6_motion_list.png
    :width: 800
    :align: center

Sch√©ma de Connexion
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/3.1.6_motion_schematic.png
   :align: center


Proc√©dures Exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/3.1.6_motion_control_circuit.png

**√âtape 2 :** Ouvrez le fichier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3 :** Ex√©cutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.6_MotionControl.py

Lorsque le programme est ex√©cut√©, si l'angle d'inclinaison du **mpu6050** sur l'axe 
`Y <https://cn.bing.com/dict/search?q=Y&FORM=BDVSP6&mkt=zh-cn>`_ `axis <https://cn.bing.com/dict/search?q=axis&FORM=BDVSP6&mkt=zh-cn>`_ est sup√©rieur √† **45** ‚ÑÉ, le moteur pas √† pas tourne dans le sens antihoraire ; s'il est inf√©rieur √† **-45** ‚ÑÉ, le moteur pas √† pas tourne dans le sens horaire.

.. warning::

    Si le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address`` s'affiche, veuillez vous r√©f√©rer √† :ref:`faq_soc`

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin source du code tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice
   import smbus
   import math
   import time

   # Initialisation des registres de gestion de l'alimentation pour le MPU6050
   power_mgmt_1 = 0x6b
   power_mgmt_2 = 0x6c

   # Configuration de la communication I2C avec le MPU6050
   bus = smbus.SMBus(1)  # Initialiser le bus SMBus
   address = 0x68        # Adresse I2C du MPU6050
   bus.write_byte_data(address, power_mgmt_1, 0)  # R√©veiller le MPU6050

   # Initialisation des broches du moteur sur les broches GPIO 18, 23, 24, 25
   motorPin = [OutputDevice(pin) pour pin dans (18, 23, 24, 25)]

   # Param√®tres de vitesse de rotation du moteur
   rolePerMinute = 15
   stepsPerRevolution = 2048
   # Calcul du d√©lai entre les √©tapes pour atteindre la vitesse souhait√©e
   stepSpeed = (60 / rolePerMinute) / stepsPerRevolution

   # Lecture d'un octet depuis l'adresse I2C sp√©cifi√©e
   def read_byte(adr):
       return bus.read_byte_data(address, adr)

   # Lecture d'un mot (2 octets) depuis l'adresse I2C sp√©cifi√©e
   def read_word(adr):
       high = bus.read_byte_data(address, adr)
       low = bus.read_byte_data(address, adr + 1)
       val = (high << 8) + low
       return val

   # Lecture d'un mot en format de compl√©ment √† 2
   def read_word_2c(adr):
       val = read_word(adr)
       if val >= 0x8000:
           return -((65535 - val) + 1)
       else:
           return val

   # Calcul de la distance euclidienne entre deux points
   def dist(a, b):
       return math.sqrt((a * a) + (b * b))

   # Calcul de la rotation autour de l'axe Y
   def get_y_rotation(x, y, z):
       radians = math.atan2(x, dist(y, z))
       return -math.degrees(radians)

   # Calcul de la rotation autour de l'axe X
   def get_x_rotation(x, y, z):
       radians = math.atan2(y, dist(x, z))
       return math.degrees(radians)

   # R√©cup√©ration de l'angle d'inclinaison depuis le MPU6050
   def mpu6050():
       accel_xout = read_word_2c(0x3b)
       accel_yout = read_word_2c(0x3d)
       accel_zout = read_word_2c(0x3f)
       accel_xout_scaled = accel_xout / 16384.0
       accel_yout_scaled = accel_yout / 16384.0
       accel_zout_scaled = accel_zout / 16384.0
       angle = get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled)
       return angle

   # Contr√¥le de la rotation du moteur pas √† pas
   def rotary(direction):
       if direction == 'c':
           # S√©quence de rotation dans le sens horaire
           for j in range(4):
               for i in range(4):
                   if 0x99 >> j & (0x08 >> i):
                       motorPin[i].on()
                   else:
                       motorPin[i].off()
                   time.sleep(stepSpeed)
       elif direction == 'a':
           # S√©quence de rotation dans le sens antihoraire
           for j in range(4):
               for i in range(4):
                   if 0x99 << j & (0x08 >> i):
                       motorPin[i].on()
                   else:
                       motorPin[i].off()
                   time.sleep(stepSpeed)

   # Boucle principale pour la lecture continue de l'angle et le contr√¥le du moteur
   try:
       while True:
           angle = mpu6050()
           if angle >= 45:
               rotary('a')  # Rotation antihoraire pour une inclinaison positive
           elif angle <= -45:
               rotary('c')  # Rotation horaire pour une inclinaison n√©gative
   except KeyboardInterrupt:
       # √âteindre toutes les broches du moteur lors d'une interruption clavier
       for pin in motorPin:
           pin.off()


**Explication du Code**

#. Le script commence par importer les biblioth√®ques n√©cessaires. ``gpiozero`` pour contr√¥ler les broches GPIO, ``smbus`` pour la communication I2C, ``math`` pour les op√©rations math√©matiques, et ``time`` pour g√©rer les d√©lais.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice
       import smbus
       import math
       import time

#. Configure la communication I2C avec le capteur MPU6050. Les registres ``power_mgmt_1`` et ``power_mgmt_2`` g√®rent l'alimentation du capteur. Le capteur est "r√©veill√©" en √©crivant dans ``power_mgmt_1``.

   .. code-block:: python

       # Initialisation des registres de gestion de l'alimentation pour le MPU6050
       power_mgmt_1 = 0x6b
       power_mgmt_2 = 0x6c

       # Configuration de la communication I2C avec le MPU6050
       bus = smbus.SMBus(1)  # Initialisation du SMBus
       address = 0x68        # Adresse I2C du MPU6050
       bus.write_byte_data(address, power_mgmt_1, 0)  # R√©veil du MPU6050

#. Initialise les broches GPIO (18, 23, 24, 25) du Raspberry Pi pour contr√¥ler le moteur pas √† pas. Chaque broche est associ√©e √† une bobine du moteur.

   .. code-block:: python

       # Initialisation des broches du moteur sur les broches GPIO 18, 23, 24, 25
       motorPin = [OutputDevice(pin) pour pin dans (18, 23, 24, 25)]

#. D√©finit les param√®tres de rotation du moteur (tours par minute) et le nombre de pas par r√©volution. ``stepSpeed`` calcule le d√©lai entre chaque pas pour atteindre la vitesse souhait√©e, garantissant ainsi un fonctionnement fluide du moteur.

   .. code-block:: python

       # Param√®tres de vitesse de rotation du moteur
       rolePerMinute = 15
       stepsPerRevolution = 2048
       # Calcul du d√©lai entre les pas pour atteindre la vitesse souhait√©e
       stepSpeed = (60 / rolePerMinute) / stepsPerRevolution

#. Ces fonctions sont utilis√©es pour la communication I2C. ``read_byte`` lit un octet √† partir d'une adresse donn√©e, tandis que ``read_word`` lit deux octets (un mot), les combinant en une seule valeur avec des op√©rations sur les bits (``<<`` et ``+``).

   .. code-block:: python

       # Lire un octet depuis l'adresse I2C sp√©cifi√©e
       def read_byte(adr):
           return bus.read_byte_data(address, adr)

       # Lire un mot (2 octets) depuis l'adresse I2C sp√©cifi√©e
       def read_word(adr):
           high = bus.read_byte_data(address, adr)
           low = bus.read_byte_data(address, adr + 1)
           val = (high << 8) + low
           return val

#. Cette fonction convertit le mot lu en compl√©ment √† 2, utile pour interpr√©ter les valeurs sign√©es des donn√©es du capteur. Cette conversion est n√©cessaire pour g√©rer les lectures n√©gatives du capteur.

   .. code-block:: python

       # Lire un mot en format compl√©ment √† 2
       def read_word_2c(adr):
           val = read_word(adr)
           if val >= 0x8000:
               return -((65535 - val) + 1)
           else:
               return val

#. ``dist`` calcule la distance euclidienne entre deux points, utilis√©e dans les calculs de rotation. ``get_y_rotation`` et ``get_x_rotation`` calculent les angles de rotation le long des axes Y et X respectivement, en utilisant la fonction ``atan2`` de la biblioth√®que ``math`` et en convertissant le r√©sultat en degr√©s.

   .. code-block:: python

       # Calcul de la distance euclidienne entre deux points
       def dist(a, b):
           return math.sqrt((a * a) + (b * b))

       # Calcul de la rotation sur l'axe Y
       def get_y_rotation(x, y, z):
           radians = math.atan2(x, dist(y, z))
           return -math.degrees(radians)

       # Calcul de la rotation sur l'axe X
       def get_x_rotation(x, y, z):
           radians = math.atan2(y, dist(x, z))
           return math.degrees(radians)

#. Cette fonction lit les donn√©es de l'acc√©l√©rom√®tre du capteur MPU6050, les met √† l'√©chelle, et calcule l'angle d'inclinaison en utilisant la fonction ``get_y_rotation``. La fonction ``read_word_2c`` lit les donn√©es du capteur en format compl√©ment √† 2 pour g√©rer les valeurs n√©gatives.

   .. code-block:: python

       # R√©cup√©ration de l'angle d'inclinaison depuis le MPU6050
       def mpu6050():
           accel_xout = read_word_2c(0x3b)
           accel_yout = read_word_2c(0x3d)
           accel_zout = read_word_2c(0x3f)
           accel_xout_scaled = accel_xout / 16384.0
           accel_yout_scaled = accel_yout / 16384.0
           accel_zout_scaled = accel_zout / 16384.0
           angle = get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled)
           return angle

#. La fonction ``rotary`` contr√¥le la rotation du moteur pas √† pas. Elle ex√©cute une s√©quence de pas pour une rotation horaire ou antihoraire, selon le param√®tre ``direction``. La s√©quence implique l'activation ou la d√©sactivation de broches sp√©cifiques du moteur dans un certain ordre.

   .. code-block:: python

       # Contr√¥le de la rotation du moteur pas √† pas
       def rotary(direction):
           if direction == 'c':
               # S√©quence de rotation horaire
               for j in range(4):
                   for i in range(4):
                       if 0x99 >> j & (0x08 >> i):
                           motorPin[i].on()
                       else:
                           motorPin[i].off()
                       time.sleep(stepSpeed)
           elif direction == 'a':
               # S√©quence de rotation antihoraire
               for j in range(4):
                   for i in range(4):
                       if 0x99 << j & (0x08 >> i):
                           motorPin[i].on()
                       else:
                           motorPin[i].off()
                       time.sleep(stepSpeed)

#. La boucle principale lit continuellement l'angle d'inclinaison depuis le capteur MPU6050 et contr√¥le la direction de rotation du moteur en fonction de l'angle. Si le programme est interrompu (par ex., via un clavier), il d√©sactive toutes les broches du moteur par s√©curit√©.

   .. code-block:: python

       # Boucle principale pour la lecture continue de l'angle et le contr√¥le du moteur
       try:
           while True:
               angle = mpu6050()
               if angle >= 45:
                   rotary('a')  # Rotation antihoraire pour une inclinaison positive
               elif angle <= -45:
                   rotary('c')  # Rotation horaire pour une inclinaison n√©gative
       except KeyboardInterrupt:
           # D√©sactiver toutes les broches du moteur en cas d'interruption
           for pin in motorPin:
               pin.off()


