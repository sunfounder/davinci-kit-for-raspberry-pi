.. note::

    Â¡Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. SumÃ©rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **Â¿Por quÃ© unirte?**

    - **Soporte Experto**: Resuelve problemas postventa y desafÃ­os tÃ©cnicos con ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos Exclusivos**: Accede anticipadamente a anuncios de nuevos productos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales.

    ğŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy.

3.1.12 JUEGO - Adivina el NÃºmero
====================================

IntroducciÃ³n
----------------

"Adivina el NÃºmero" es un juego divertido en el que tÃº y tus amigos turnan 
para ingresar un nÃºmero (0~99). El rango se reducirÃ¡ con cada intento hasta 
que uno de los jugadores adivine el nÃºmero correcto y, al hacerlo, pierde el 
juego y recibe una â€œpenalizaciÃ³nâ€. Por ejemplo, si el nÃºmero oculto es 51 y 
el jugador â‘  introduce 50, el rango cambia a 50~99; si el jugador â‘¡ introduce 
70, el rango cambia a 50~70; si el jugador â‘¢ introduce 51, es el jugador 
desafortunado. En este proyecto, utilizamos un teclado para introducir los 
nÃºmeros y una pantalla LCD para mostrar los resultados.

Componentes
-------------

.. image:: img/list_GAME_Guess_Number.png
    :align: center

Diagrama de EsquemÃ¡tico
---------------------------

============ ======== ======== =======
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: img/Schematic_three_one12.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image273.png
   :alt: Guess Number_bb
   :width: 800

**Paso 2**: Configura I2C (consulta el ApÃ©ndice. Si ya lo has configurado, 
omite este paso).

**Paso 3**: Cambia de directorio.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.12/

**Paso 4**: Compila el cÃ³digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.12_GAME_GuessNumber.c -lwiringPi

**Paso 5**: Ejecuta el archivo compilado.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

DespuÃ©s de ejecutar el programa, se mostrarÃ¡ la pÃ¡gina inicial en la pantalla LCD:

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

Presiona 'A' para iniciar el juego, y la pantalla LCD mostrarÃ¡ la pÃ¡gina del juego.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

.. note::

   Si no funciona tras ejecutarse o aparece un mensaje de error como : \"wiringPi.h: No such file or directory\", consulta :ref:`C code is not working?`.


Cuando comienza el juego, se genera un nÃºmero aleatorio \'**point**\', 
que no se muestra en la pantalla LCD. Debes adivinarlo. El nÃºmero ingresado 
aparecerÃ¡ al final de la primera lÃ­nea hasta que se realice el cÃ¡lculo final. 
(Presiona 'D' para iniciar la comparaciÃ³n y, si el nÃºmero ingresado es mayor 
de **10**, la comparaciÃ³n se iniciarÃ¡ automÃ¡ticamente).

El rango del nÃºmero \'point\' se muestra en la segunda lÃ­nea, y debes ingresar 
un nÃºmero dentro de este rango. Cada vez que introduces un nÃºmero, el rango se 
reduce; si adivinas el nÃºmero por suerte (o por mala suerte), aparecerÃ¡ el mensaje \"You've got it!\"

**ExplicaciÃ³n del CÃ³digo**

La primera parte del cÃ³digo contiene las funciones de 
**teclado** y **LCD I2C 1602**. Para conocer mÃ¡s detalles, 
consulta **1.1.7 LCD I2C 1602** y **2.1.5 Teclado**.

AquÃ­ lo que necesitamos saber es lo siguiente:

.. code-block:: c

    /****************************************/
    //Inicio desde aquÃ­
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
        lcd_init();
        lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
        }
        lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }
    
Esta funciÃ³n define inicialmente **LCD I2C 1602** y **Teclado**, 
y muestra "Welcome!" y "Press A to go!".

.. code-block:: c

    voidÂ init_new_value(void){
        srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }

La funciÃ³n produce el nÃºmero aleatorio \'**point**\' y restablece el 
rango de sugerencia del punto.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
            }
        }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
            }
        }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
        }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

detect_point() compara el nÃºmero introducido con el \"point\" generado. 
Si el resultado de la comparaciÃ³n indica que no son iguales, **count** 
asignarÃ¡ valores a **upper** y **lower** y retornarÃ¡ \'**0**\'; en caso 
contrario, si son iguales, retornarÃ¡ \'**1**\'.

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
        lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
            delay(5000);
            init_new_value();
            lcd_show_input(0);
            return;
        }
    Â Â Â Â write(0,0,"EnterÂ number:");
        Int2Str(str,count);
        write(13,0,str);
        Int2Str(str,lower);
        write(0,1,str);
    Â Â Â Â write(3,1,"<Point<");
        Int2Str(str,upper);
        write(12,1,str);
    }

Esta funciÃ³n muestra la pÃ¡gina del juego. Presta atenciÃ³n a la funciÃ³n **Int2Str(str,count)**, que convierte las variables **count**, **lower** y **upper** de **entero** a **cadena de caracteres** para una visualizaciÃ³n correcta en **lcd**.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){ //si la inicializaciÃ³n de wiring falla, muestra mensaje en pantalla
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
        }
        init();
        init_new_value();
        while(1){
            keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
                        init_new_value();
                        lcd_show_input(0);
                    }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
                        lcd_show_input(result);
                    }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
                        }
                        lcd_show_input(result);
                    }
                }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
            }
            delay(100);
        }
    Â Â Â Â returnÂ 0;Â Â Â 
    }

Main() contiene el proceso completo del programa, como se muestra a continuaciÃ³n:

1) Inicializa **LCD I2C 1602** y **Teclado**.

2) Usa **init_new_value()** para crear un nÃºmero aleatorio entre **0-99**.

3) Verifica si se ha presionado algÃºn botÃ³n y obtiene la lectura.

4) Si se presiona el botÃ³n \'**A**\', aparecerÃ¡ un nÃºmero aleatorio entre **0-99** y comenzarÃ¡ el juego.

5) Si se detecta que se presionÃ³ el botÃ³n \'**D**\', el programa ingresarÃ¡ al 
   proceso de verificaciÃ³n y mostrarÃ¡ el resultado en la pantalla LCD. Esto permite 
   verificar el resultado incluso si se introduce solo un nÃºmero y luego se presiona 
   el botÃ³n \'**D**\'.

6) Si se presiona un botÃ³n entre **0-9**, el valor de **count** cambiarÃ¡; 
   si **count** es mayor que **10**, comenzarÃ¡ la verificaciÃ³n.

7) Los cambios del juego y sus valores se muestran en **LCD1602**.

