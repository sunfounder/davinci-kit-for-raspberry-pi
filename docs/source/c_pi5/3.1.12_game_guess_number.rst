.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

3.1.12 SPIEL â€“ Nummer Vermutung
=================================

EinfÃ¼hrung
------------------

Nummer Vermutung ist ein lustiges Partyspiel, 
bei dem Sie und Ihre Freunde abwechselnd eine Nummer eingeben (0~99). 
Die Reichweite wird mit der Eingabe der Nummer kleiner, bis ein Spieler das RÃ¤tsel richtig beantwortet. 
Dann wird der Spieler besiegt und bestraft. Wenn zum Beispiel die GlÃ¼cksnummer 51 ist, 
die die Spieler nicht sehen kÃ¶nnen, und der Spieler â‘  50 eingibt, 
Ã¤ndert sich die Eingabeaufforderung des Nummernbereichs auf 50~99; 
Wenn der Spieler â‘¡ 70 eingibt, kann der Nummerbereich zwischen 50 und 70 liegen. 
Wenn der Spieler â‘¢ 51 eingibt, ist dieser Spieler der UnglÃ¼ckliche. 
Hier verwenden wir die Tastatur zur Eingabe von Nummer und das LCD zur Ausgabe der Ergebnisse.

Komponenten
-----------------

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Schematische Darstellung
-----------------------------------------

============ ======== ======== =======
T-Karte Name physisch wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

Experimentelle Verfahren
-----------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: ../img/image273.png
   :alt: Guess Number_bb
   :width: 800

Schritt 2: I2C einrichten (siehe Anhang. Wenn Sie :ref:`i2c_config`  eingestellt haben, Ã¼berspringen Sie diesen Schritt.)

Schritt 3: Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block::

    cd /home/pi/davinci-kit-for-raspberry-pi/c/3.1.12/

Schritt 4: Kompilieren.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.12_GAME_GuessNumber.c -lwiringPi

Schritt 5: AusfÃ¼hren.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Nachdem das Programm ausgefÃ¼hrt wurde, wird die erste Seite auf dem LCD angezeigt:

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

DrÃ¼cken Sie â€šAâ€˜ und das Spiel startet und die Spieleseite erscheint auf dem LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

Zu Beginn des Spiels wird eine Zufallsnummer â€šPunktâ€˜ erzeugt, die jedoch nicht auf dem LCD angezeigt wird. Sie mÃ¼ssen sie nur erraten. Die eingegebene Nummer wird am Ende der ersten Zeile angezeigt, bis die endgÃ¼ltige Berechnung abgeschlossen ist. (DrÃ¼cken Sie â€šDâ€˜, um den Vergleich zu starten. Wenn die Eingangsnummer grÃ¶ÃŸer als 10 ist, wird der automatische Vergleich gestartet.)

Der Nummernkreis von â€šPunktâ€˜ wird in der zweiten Zeile angezeigt. Und Sie mÃ¼ssen die Nummer innerhalb des Bereichs eingeben. Wenn Sie eine Nummer eingeben, wird der Bereich enger. Wenn Sie die GlÃ¼cksnummer glÃ¼cklicherweise oder unglÃ¼cklicherweise erhalten haben, wird â€žYou'veÂ gotÂ it!â€œ angezeigt.

**Code ErklÃ¤rung**

Am Anfang des Codes stehen die Funktionsfunktionen der Tastatur und des I2C LCD1602. 
Weitere Informationen hierzu finden Sie in den Tasten :ref:`py_lcd` und :ref:`py_keypad` .

Hier mÃ¼ssen wir Folgendes wissen:

.. code-block:: c

    /****************************************/
    //StartÂ fromÂ here
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
    Â Â Â Â lcd_init();
    Â Â Â Â lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
    Â Â Â Â }
    Â Â Â Â lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }
    

Diese Funktion wird verwendet, um zunÃ¤chst I2C LCD1602 und Tastatur 
zu definieren und â€žWelcome!â€œ und â€žPressÂ AÂ toÂ go!â€œ anzuzeigen.

.. code-block:: c

    voidÂ init_new_value(void){
    Â Â Â Â srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }

Die Funktion erzeugt die Zufallsnummer ``pointValue`` und setzt den Bereichshinweis des Punktes zurÃ¼ck.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

``detect_point()`` vergleicht die Eingabenummer mit dem erzeugten â€žpointâ€œ. 
Wenn das Ergebnis des Vergleichs ist, dass sie nicht gleich sind, weist ``count`` ``upper`` und ``lower`` Werte zu und gibt â€ž0â€œ zurÃ¼ck; andernfalls, wenn das Ergebnis anzeigt, dass sie gleich sind, wird â€ž1â€œ zurÃ¼ckgegeben.

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
    Â Â Â Â lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
    Â Â Â Â Â Â Â Â delay(5000);
    Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â return;
    Â Â Â Â }
    Â Â Â Â write(0,0,"EnterÂ number:");
    Â Â Â Â Int2Str(str,count);
    Â Â Â Â write(13,0,str);
    Â Â Â Â Int2Str(str,lower);
    Â Â Â Â write(0,1,str);
    Â Â Â Â write(3,1,"<Point<");
    Â Â Â Â Int2Str(str,upper);
    Â Â Â Â write(12,1,str);
    }


Diese Funktion dient zum Anzeigen der Spieleseite. 
Beachten Sie die Funktion ``Int2Str(str,count)`` , 
die diese Variablen ``count`` , ``lower`` und ``upper`` von Integer in Character String konvertiert, 
um die korrekte Anzeige von lcd zu gewÃ¤hrleisten.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){Â //whenÂ initializeÂ wiringÂ failed,printÂ messagetoÂ screen
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
    Â Â Â Â }
    Â Â Â Â init();
    Â Â Â Â init_new_value();
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;Â Â Â 
    }

``main()`` enthÃ¤lt den gesamten Prozess des Programms, wie unten gezeigt:

1. Initialisieren Sie I2C LCD1602 und Tastatur.

#. Verwenden Sie ``init_new_value()`` , um eine Zufallsnummer 0-99 zu erstellen.

#. Beurteilen Sie, ob die Taste gedrÃ¼ckt wurde, und lassen Sie die Taste ablesen.

#. Wenn die Taste â€žAâ€œ gedrÃ¼ckt wird, erscheint eine Zufallsnummer 0-99 und das Spiel beginnt.

#. Wenn festgestellt wird, dass die Taste â€žDâ€œ gedrÃ¼ckt wurde, geht das Programm in die Ergebnisbeurteilung ein und zeigt das Ergebnis auf dem LCD an. Dieser Schritt hilft Ihnen, das Ergebnis auch zu beurteilen, wenn Sie nur eine Nummer und dann die Taste â€žDâ€œ drÃ¼cken.

#. Wenn die Taste 0-9 gedrÃ¼ckt wird, wird der ZÃ¤hlwert geÃ¤ndert. Wenn die Anzahl grÃ¶ÃŸer als 10 ist, beginnt das Urteil.

#. Die Ã„nderungen des Spiels und seiner Werte werden auf dem LCD1602 angezeigt.
