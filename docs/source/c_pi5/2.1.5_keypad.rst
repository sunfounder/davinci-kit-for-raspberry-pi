.. note::

    Bonjour, bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi & Arduino & ESP32 ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et tirages au sort** : Participez √† des tirages au sort et b√©n√©ficiez de promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.1.5 Clavier
================

Introduction
---------------

Un clavier est un tableau rectangulaire de boutons. Dans ce projet, nous allons 
l'utiliser pour saisir des caract√®res.

Composants
-----------

.. image:: img/list_2.1.5_keypad.png


Principe
------------

**Clavier**

Un clavier est un tableau rectangulaire de 12 ou 16 boutons de type OFF-(ON). 
Leurs contacts sont accessibles via un connecteur adapt√© pour une connexion 
par c√¢ble plat ou pour √™tre ins√©r√© dans une carte de circuit imprim√©. Dans 
certains claviers, chaque bouton est connect√© √† un contact distinct dans le 
connecteur, tandis que tous les boutons partagent une masse commune.

.. image:: img/image314.png


Le plus souvent, les boutons sont cod√©s en matrice, ce qui signifie que chacun 
d'eux connecte une paire unique de conducteurs dans une matrice. Cette configuration 
est adapt√©e √† un microcontr√¥leur, qui peut √™tre programm√© pour envoyer une impulsion 
de sortie sur chacun des quatre fils horizontaux √† tour de r√¥le. Pendant chaque impulsion, 
il v√©rifie les quatre fils verticaux restants en s√©quence, afin de d√©terminer lequel, 
le cas √©ch√©ant, transporte un signal. Des r√©sistances pullup ou pulldown doivent √™tre 
ajout√©es aux fils d'entr√©e pour √©viter que les entr√©es du microcontr√¥leur ne se 
comportent de mani√®re impr√©visible en l'absence de signal.

Sch√©ma de c√¢blage
---------------------

.. image:: img/image315.png


.. image:: img/image316.png


Proc√©dure exp√©rimentale
----------------------------

**√âtape 1** : Construisez le circuit.

.. image:: img/image186.png
    :width: 800


**√âtape 2** : Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.5/

**√âtape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.5_Keypad.cpp -lwiringPi

**√âtape 4** : Ex√©cutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, les valeurs des boutons press√©s sur le clavier 
(valeur du bouton) seront affich√©es √† l'√©cran.

.. note::

    Si le programme ne fonctionne pas apr√®s ex√©cution, ou si un message d'erreur 
    s'affiche : \"wiringPi.h: No such file or directory\", veuillez vous r√©f√©rer √† 
    :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }


**Explication du Code**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

D√©clarez chaque touche du clavier matriciel dans le tableau `KEYS[]` et d√©finissez les broches correspondant √† chaque ligne et colonne.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Cette partie de la fonction principale lit et affiche la valeur de la touche press√©e.

La fonction `keyRead()` lit l'√©tat de chaque touche.

`keyCompare()` et `keyCopy()` sont utilis√©es pour v√©rifier si l'√©tat de la touche a chang√© (c'est-√†-dire, si une touche a √©t√© press√©e ou rel√¢ch√©e).

`keyPrint()` affiche la valeur de la touche dont le niveau actuel est un niveau haut (la touche est press√©e).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Cette fonction assigne successivement un niveau haut √† chaque ligne. Lorsque 
la touche correspondante dans la colonne est press√©e, la colonne concern√©e 
re√ßoit un niveau haut. Apr√®s la boucle √† deux niveaux, l'√©tat des touches est 
compil√© pour g√©n√©rer un tableau `result[]`.

Lorsque le bouton 3 est press√© :

.. image:: img/image187.png


RowPin [0] writes in the high level, and colPin[2] gets the high level.
ColPin [0], colPin[1], colPin[3] get the low level.

This gives us 0,0,1,0. When rowPin[1], rowPin[2] and rowPin[3] are
written in high level, colPin[0]~colPin[4] will get low level.

Apr√®s la boucle de v√©rification, un tableau est g√©n√©r√© :

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Ces deux fonctions sont utilis√©es pour v√©rifier si l'√©tat d'une touche a chang√©, 
par exemple si vous rel√¢chez le bouton "3" ou si vous appuyez sur "2", `keyCompare()` 
renvoie `false`.

`keyCopy()` est utilis√©e pour r√©√©crire la valeur actuelle du bouton dans le 
tableau `a` (`last_key_pressed[BUTTON_NUM]`) apr√®s chaque comparaison. Cela permet 
de les comparer √† nouveau lors de la prochaine boucle.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Cette fonction est utilis√©e pour afficher la valeur de la touche actuellement press√©e. 
Si la touche '1' est press√©e, '1' sera affich√©. Si la touche '1' et ensuite la touche '3' 
sont press√©es, alors '1, 3' sera affich√©.

