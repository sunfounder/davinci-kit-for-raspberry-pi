.. note::

    隆Hola! Bienvenidos a la comunidad de entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum茅rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros apasionados.

    **驴Por qu茅 unirse?**

    - **Soporte de Expertos**: Resuelve problemas postventa y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos Exclusivos**: Accede anticipadamente a nuevos lanzamientos de productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy mismo.

1.1.5 4-Digit 7-Segment Display
=================================================

Introducci贸n
-----------------

A continuaci贸n, te invito a probar el control de una pantalla de 7 segmentos de 4 d铆gitos.

Componentes
---------------

.. image:: img/list_4_digit.png


Principio
--------------

**Pantalla de 7 Segmentos de 4 D铆gitos**

La pantalla de 7 segmentos de 4 d铆gitos consta de cuatro displays de 7 segmentos que funcionan juntos.

.. image:: img/4-digit-sche.png

Cada display de 7 segmentos funciona de manera independiente, utilizando 
el principio de persistencia visual humana para mostrar r谩pidamente los 
caracteres en cada segmento de forma secuencial, creando la ilusi贸n de 
una cadena continua.

Por ejemplo, cuando en la pantalla se muestra "1234", primero se visualiza 
el "1" en el primer display, mientras que los dem谩s segmentos no muestran 
nada. Luego, el segundo segmento muestra el "2", y el resto permanece apagado, 
y as铆 sucesivamente. Este proceso ocurre muy r谩pidamente (aproximadamente cada 
5 ms), y debido al efecto de posimagen 贸ptica y la persistencia visual, percibimos 
los cuatro caracteres simult谩neamente.

.. image:: img/image78.png


**C贸digos de Visualizaci贸n**

Para ayudarte a entender c贸mo las pantallas de 7 segmentos (nodo Com煤n) 
muestran n煤meros, hemos creado la siguiente tabla. En ella, se muestran 
los n煤meros 0-F en la pantalla de 7 segmentos. (DP) GFEDCBA se refiere a 
los LEDs correspondientes configurados en 0 o 1. Por ejemplo, 11000000 
significa que DP y G est谩n en 1, mientras que el resto est谩n en 0. De 
esta forma, el n煤mero 0 se visualiza en la pantalla de 7 segmentos, mientras 
que el C贸digo HEX corresponde al n煤mero en hexadecimal.

.. image:: img/common_anode.png


Diagrama de Conexi贸n
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
============ ======== ======== ===

.. image:: img/schmatic_4_digit.png


Procedimientos Experimentales
-----------------------------------

**Paso 1**: Constrye el circuito.

.. image:: img/image80.png
    :width: 800

Para Usuarios del Lenguaje C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Paso 2: Accede a la carpeta del c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.1.5/

Paso 3: Compila el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.5_4-Digit.c -lwiringPi

Paso 4: Ejecuta el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu茅s de ejecutar el c贸digo, el programa realiza un conteo, aumentando en 1 cada segundo, y la pantalla de 7 segmentos de 4 d铆gitos muestra el conteo.

.. note::

    Si no funciona despu茅s de ejecutarlo o aparece un mensaje de error: \"wiringPi.h: No such file or directory\", consulta la referencia :ref:`c code is not working?`.
**C贸digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <wiringShift.h>
    #include <signal.h>
    #include <unistd.h>

    #define SDI 5
    #define RCLK 4
    #define SRCLK 1

    const int placePin[] = {12, 3, 2, 0};
    unsigned char number[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90};

    int counter = 0;

    void pickDigit(int digit)
    {
        for (int i = 0; i < 4; i++)
        {
            digitalWrite(placePin[i], 0);
        }
        digitalWrite(placePin[digit], 1);
    }

    void hc595_shift(int8_t data)
    {
        int i;
        for (i = 0; i < 8; i++)
        {
            digitalWrite(SDI, 0x80 & (data << i));
            digitalWrite(SRCLK, 1);
            delayMicroseconds(1);
            digitalWrite(SRCLK, 0);
        }
        digitalWrite(RCLK, 1);
        delayMicroseconds(1);
        digitalWrite(RCLK, 0);
    }

    void clearDisplay()
    {
        int i;
        for (i = 0; i < 8; i++)
        {
            digitalWrite(SDI, 1);
            digitalWrite(SRCLK, 1);
            delayMicroseconds(1);
            digitalWrite(SRCLK, 0);
        }
        digitalWrite(RCLK, 1);
        delayMicroseconds(1);
        digitalWrite(RCLK, 0);
    }

    void loop()
    {
        while(1){
        clearDisplay();
        pickDigit(0);
        hc595_shift(number[counter % 10]);

        clearDisplay();
        pickDigit(1);
        hc595_shift(number[counter % 100 / 10]);

        clearDisplay();
        pickDigit(2);
        hc595_shift(number[counter % 1000 / 100]);
    
        clearDisplay();
        pickDigit(3);
        hc595_shift(number[counter % 10000 / 1000]);
        }
    }

    void timer(int timer1)
    { 
        if (timer1 == SIGALRM)
        { 
            counter++;
            alarm(1); 
            printf("%d\n", counter);
        }
    }

    void main(void)
    {
        if (wiringPiSetup() == -1)
        { 
            printf("setup wiringPi failed !");
            return;
        }
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT);
        
        for (int i = 0; i < 4; i++)
        {
            pinMode(placePin[i], OUTPUT);
            digitalWrite(placePin[i], HIGH);
        }
        signal(SIGALRM, timer); 
        alarm(1);               
        loop(); 
    }

**Explicaci贸n del C贸digo**

.. code-block:: c

    const int placePin[] = {12, 3, 2, 0};

Estos cuatro pines controlan los pines de 谩nodo com煤n de las pantallas de 7 segmentos de cuatro d铆gitos.

.. code-block:: c

    unsigned char number[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90};

Un arreglo de c贸digos de segmento de 0 a 9 en hexadecimal (谩nodo com煤n).

.. code-block:: c

    void pickDigit(int digit)
    {
        for (int i = 0; i < 4; i++)
        {
            digitalWrite(placePin[i], 0);
        }
        digitalWrite(placePin[digit], 1);
    }

Selecciona el lugar del valor. Cada vez debe activarse un solo lugar. El lugar activado se escribe en alto.

.. code-block:: c

    void loop()
    {
        while(1){
        clearDisplay();
        pickDigit(0);
        hc595_shift(number[counter % 10]);

        clearDisplay();
        pickDigit(1);
        hc595_shift(number[counter % 100 / 10]);

        clearDisplay();
        pickDigit(2);
        hc595_shift(number[counter % 1000 / 100]);
    
        clearDisplay();
        pickDigit(3);
        hc595_shift(number[counter % 10000 / 1000]);
        }
    }

La funci贸n se utiliza para configurar el n煤mero que se muestra en la pantalla de 7 segmentos de cuatro d铆gitos.

* ``clearDisplay()``: escribe 11111111 para apagar estos ocho LED en la pantalla de 7 segmentos, limpiando el contenido mostrado.
* ``pickDigit(0)``: selecciona el cuarto display de 7 segmentos.
* ``hc595_shift(number[counter%10])``: el n煤mero en la unidad de contador se mostrar谩 en el cuarto segmento.

.. code-block:: c

    signal(SIGALRM, timer); 

Esta es una funci贸n proporcionada por el sistema, cuyo prototipo es:

.. code-block:: c

    sig_t signal(int signum,sig_t handler);

Despu茅s de ejecutar signal(), una vez que el proceso recibe el signum correspondiente (en este caso SIGALRM), inmediatamente pausa la tarea existente y procesa la funci贸n establecida (en este caso timer(sig)).

.. code-block:: c

    alarm(1);

Esta tambi茅n es una funci贸n proporcionada por el sistema. El prototipo del c贸digo es:

.. code-block:: c

    unsigned int alarm (unsigned int seconds);

Genera una se帽al SIGALRM despu茅s de un cierto n煤mero de segundos.

.. code-block:: c

    void timer(int timer1)
    { 
        if (timer1 == SIGALRM)
        { 
            counter++;
            alarm(1); 
            printf("%d\n", counter);
        }
    }

Usamos las funciones anteriores para implementar la funci贸n de temporizador.
Despu茅s de que ``alarm()`` genera la se帽al SIGALRM, se llama a la funci贸n timer. Se suma 1 al contador, y la funci贸n ``alarm(1)`` se llama repetidamente despu茅s de 1 segundo.

Para Usuarios de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Paso 2: Ir a la carpeta del c贸digo. 

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

Paso 3: Ejecutar el archivo.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.5_4-Digit.py

Despu茅s de ejecutar el c贸digo, el programa empieza a contar, aumentando en 1 cada segundo, y el display de cuatro d铆gitos muestra el conteo.

**C贸digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c贸digo de abajo. Pero antes de hacerlo, debes estar en la ruta de c贸digo fuente como ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    SDI = 24
    RCLK = 23
    SRCLK = 18

    placePin = (10, 22, 27, 17)
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    counter = 0
    timer1 = 0

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)    

    def hc595_shift(data): 
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)


    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(1.0, timer) 
        timer1.start()  
        counter += 1
        print("%d" % counter)


    def loop():
        global counter                    
        while True:
            clearDisplay() 
            pickDigit(0)  
            hc595_shift(number[counter % 10])
            
            clearDisplay()
            pickDigit(1)
            hc595_shift(number[counter % 100//10])

            clearDisplay()
            pickDigit(2)
            hc595_shift(number[counter % 1000//100])

            clearDisplay()
            pickDigit(3)
            hc595_shift(number[counter % 10000//1000])


    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for i in placePin:
            GPIO.setup(i, GPIO.OUT)
        global timer1
        timer1 = threading.Timer(1.0, timer)  
        timer1.start()       

    def destroy():   # Cuando se presiona "Ctrl+C", se ejecuta esta funci贸n.
        global timer1
        GPIO.cleanup()
        timer1.cancel()  # cancela el temporizador

    if __name__ == '__main__':  # Programa inicia aqu铆
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()
**Explicaci贸n del C贸digo**

.. code-block:: python

    placePin = (10, 22, 27, 17)

Estos cuatro pines controlan los pines de 谩nodo com煤n de las pantallas de 7 segmentos de cuatro d铆gitos.

.. code-block:: python

    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

Un arreglo de c贸digos de segmento de 0 a 9 en hexadecimal (谩nodo com煤n).

.. code-block:: python

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
    GPIO.output(RCLK, GPIO.HIGH)
    GPIO.output(RCLK, GPIO.LOW) 

Escribe "1" ocho veces en SDI, de modo que los ocho LEDs de la pantalla de 7 segmentos se apaguen, limpiando as铆 el contenido mostrado.

.. code-block:: python

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

Selecciona la posici贸n del valor. Solo se debe habilitar una posici贸n cada vez. La posici贸n habilitada se establece en alto. 

.. code-block:: python

    def loop():
        global counter                    
        while True:
            clearDisplay() 
            pickDigit(0)  
            hc595_shift(number[counter % 10])

            clearDisplay()
            pickDigit(1)
            hc595_shift(number[counter % 100//10])

            clearDisplay()
            pickDigit(2)
            hc595_shift(number[counter % 1000//100])

            clearDisplay()
            pickDigit(3)
            hc595_shift(number[counter % 10000//1000])

La funci贸n se utiliza para configurar el n煤mero que se muestra en la pantalla de 7 segmentos de cuatro d铆gitos.

Primero, activa el cuarto d铆gito y escribe el n煤mero de una sola cifra. Luego activa el tercer d铆gito y escribe la decena; despu茅s, activa el segundo y el primer d铆gito respectivamente y escribe las centenas y las unidades de mil. Debido a la alta velocidad de actualizaci贸n, se percibe como una pantalla completa de cuatro d铆gitos.

.. code-block:: python

    timer1 = threading.Timer(1.0, timer)  
    timer1.start()  

El m贸dulo threading es el m贸dulo com煤n de subprocesos en Python, y Timer es una subclase de este.
El prototipo de c贸digo es:

.. code-block:: python

    class threading.Timer(interval, function, args=[], kwargs={})

Despu茅s del intervalo, se ejecuta la funci贸n. Aqu铆, el intervalo es 1.0 y la funci贸n es timer().
start() indica que el temporizador comenzar谩 en este punto.

.. code-block:: python

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(1.0, timer) 
        timer1.start()  
        counter += 1
        print("%d" % counter)

Despu茅s de que el temporizador alcanza los 1.0 s, se llama a la funci贸n timer; se suma 1 al contador, y el temporizador se usa nuevamente para ejecutarse a s铆 mismo cada segundo de forma repetida.

Imagen del Fen贸meno
-----------------------

.. image:: img/image81.jpeg