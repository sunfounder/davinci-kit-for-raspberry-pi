.. note::

    Bonjour et bienvenue dans la communautÃ© Facebook des passionnÃ©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez plus profondÃ©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez vos problÃ¨mes techniques et aprÃ¨s-vente avec l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et Partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits.
    - **RÃ©ductions spÃ©ciales** : BÃ©nÃ©ficiez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des concours et promotions pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.12 JEU - Devinez le nombre
==================================

Introduction
----------------

Â« Devinez le Nombre Â» est un jeu amusant oÃ¹ vous et vos amis tour Ã  tour entrez 
un nombre (0~99). La plage de nombres possibles se rÃ©duit progressivement jusqu'Ã  
ce qu'un joueur devine le bon chiffre. Celui qui trouve le bon nombre perd et subit 
une pÃ©nalitÃ©. Par exemple, si le nombre secret est 51 (invisible pour les joueurs) 
et que le joueur â‘  entre 50, la plage passe Ã  50~99 ; si le joueur â‘¡ entre 70, la 
plage se rÃ©duit Ã  50~70 ; si le joueur â‘¢ entre 51, ce joueur est le perdant. Ici, 
nous utilisons un clavier pour saisir les nombres et un Ã©cran LCD pour afficher les rÃ©sultats.

Composants
-----------------

.. image:: img/list_GAME_Guess_Number.png
    :align: center

SchÃ©ma de cÃ¢blage
--------------------

============ ======== ======== =======
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: img/Schematic_three_one12.png
   :align: center

ProcÃ©dures expÃ©rimentales
------------------------------

**Ã‰tape 1 :** Construire le circuit.

.. image:: img/image273.png
   :alt: Guess Number_bb
   :width: 800

**Ã‰tape 2 :** Configurer I2C (voir l'Annexe. Si I2C est dÃ©jÃ  configurÃ©, passez cette Ã©tape.)

**Ã‰tape 3 :** Changer de rÃ©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.12/

**Ã‰tape 4 :** Compiler.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.12_GAME_GuessNumber.c -lwiringPi

**Ã‰tape 5 :** ExÃ©cuter.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Lorsque le programme dÃ©marre, la page initiale s'affiche sur le LCD :

.. code-block:: 

   Welcome!
   PressÂ AÂ toÂ go!

Appuyez sur 'A' et le jeu commence. La page de jeu apparaÃ®t alors sur lâ€™Ã©cran LCD.

.. code-block:: 

   Enter number:
   0 â€¹pointâ€¹ 99

.. note::

   Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution, ou s'il y a un message d'erreur: \"wiringPi.h: Aucun fichier ou rÃ©pertoire de ce type", veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.

Un nombre alÃ©atoire Â« **point** Â» est gÃ©nÃ©rÃ© mais n'est pas affichÃ© sur le 
LCD au dÃ©but du jeu. Votre objectif est de le deviner. Le nombre que vous 
saisissez s'affiche en bas de la premiÃ¨re ligne jusqu'Ã  la fin du calcul. 
(Appuyez sur 'D' pour lancer la comparaison. Si le nombre saisi est supÃ©rieur 
Ã  **10**, la comparaison automatique commence.)

La plage de nombres de Â« point Â» s'affiche sur la deuxiÃ¨me ligne. Vous devez 
entrer un nombre dans cette plage. Ã€ chaque saisie, la plage se rÃ©duit ; si 
vous devinez le nombre secret, le message Â« Vous avez gagnÃ© ! Â» apparaÃ®tra.

**Explication du code**

La premiÃ¨re partie du code contient les fonctions essentielles pour le **clavier** 
et le **LCD1602 I2C**. Vous pouvez consulter les sections **1.1.7 I2C LCD1602** et 
**2.1.5 Keypad** pour plus de dÃ©tails.

Voici ce que nous devons savoir :

.. code-block:: c

    /****************************************/
    //DÃ©but du programme
    /****************************************/
    voidÂ init(void){
    Â Â Â Â fdÂ =Â wiringPiI2CSetup(LCDAddr);
    Â Â Â Â lcd_init();
    Â Â Â Â lcd_clear();
    Â Â Â Â for(intÂ i=0Â ;Â i<4Â ;Â i++)Â {
    Â Â Â Â Â Â Â Â pinMode(rowPins[i],Â OUTPUT);
    Â Â Â Â Â Â Â Â pinMode(colPins[i],Â INPUT);
    Â Â Â Â }
    Â Â Â Â lcd_clear();
    Â Â Â Â write(0,Â 0,Â "Welcome!");
    Â Â Â Â write(0,Â 1,Â "PressÂ AÂ toÂ go!");
    }

Cette fonction est utilisÃ©e pour dÃ©finir initialement le **LCD1602 I2C** et le **clavier**, et pour afficher Â« Bienvenue ! Â» et Â« Appuyez sur A ! Â».

.. code-block:: c

    voidÂ init_new_value(void){
    Â Â Â Â srand(time(0));
    Â Â Â Â pointValueÂ =Â rand()%100;
    Â Â Â Â upperÂ =Â 99;
    Â Â Â Â lowerÂ =Â 0;
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â printf("pointÂ isÂ %d\n",pointValue);
    }

Cette fonction gÃ©nÃ¨re un nombre alÃ©atoire nommÃ© Â« **point** Â» et rÃ©initialise la plage d'affichage.

.. code-block:: c

    boolÂ detect_point(void){
    Â Â Â Â if(countÂ >Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ <Â upper){
    Â Â Â Â Â Â Â Â Â Â Â Â upperÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ <Â pointValue){
    Â Â Â Â Â Â Â Â if(countÂ >Â lower){
    Â Â Â Â Â Â Â Â Â Â Â Â lowerÂ =Â count;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â elseÂ if(countÂ =Â pointValue){
    Â Â Â Â Â Â Â Â countÂ =Â 0;
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â countÂ =Â 0;
    Â Â Â Â returnÂ 0;
    }

La fonction detect_point() compare le nombre saisi avec le nombre secret Â« point Â». 
Si les valeurs ne correspondent pas, **count** ajuste les valeurs de **upper** et 
**lower** et renvoie Â« **0** Â» ; sinon, si elles correspondent, la fonction retourne Â« **1** Â».

.. code-block:: c

    voidÂ lcd_show_input(boolÂ result){
    Â Â Â Â charÂ *str=NULL;
    Â Â Â Â strÂ =(char*)malloc(sizeof(char)*3);
    Â Â Â Â lcd_clear();
    Â Â Â Â ifÂ (resultÂ ==Â 1){
    Â Â Â Â Â Â Â Â write(0,1,"You'veÂ gotÂ it!");
    Â Â Â Â Â Â Â Â delay(5000);
    Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â return;
    Â Â Â Â }
    Â Â Â Â write(0,0,"EnterÂ number:");
    Â Â Â Â Int2Str(str,count);
    Â Â Â Â write(13,0,str);
    Â Â Â Â Int2Str(str,lower);
    Â Â Â Â write(0,1,str);
    Â Â Â Â write(3,1,"<Point<");
    Â Â Â Â Int2Str(str,upper);
    Â Â Â Â write(12,1,str);
    }

Cette fonction affiche les entrÃ©es de l'utilisateur sur le LCD. Si le nombre est correct, elle affiche Â« Vous avez gagnÃ© ! Â» et redÃ©marre le jeu. Sinon, elle met Ã  jour la plage des nombres possibles et affiche les valeurs actuelles de **lower** et **upper**.

Cette fonction est utilisÃ©e pour afficher la page de jeu. Remarquez la fonction 
**Int2Str(str,count)**, qui convertit les variables **count**, **lower** et **upper** 
de **entier** en **chaÃ®ne de caractÃ¨res** afin d'assurer leur affichage correct sur le **LCD**.

.. code-block:: c

    intÂ main(){
    Â Â Â Â unsignedÂ charÂ pressed_keys[BUTTON_NUM];
    Â Â Â Â unsignedÂ charÂ last_key_pressed[BUTTON_NUM];
    Â Â Â Â if(wiringPiSetup()Â ==Â -1){Â //whenÂ initializeÂ wiringÂ failed,printÂ messagetoÂ screen
    Â Â Â Â Â Â Â Â printf("setupÂ wiringPiÂ failedÂ !");
    Â Â Â Â Â Â Â Â returnÂ 1;Â 
    Â Â Â Â }
    Â Â Â Â init();
    Â Â Â Â init_new_value();
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â keyRead(pressed_keys);
    Â Â Â Â Â Â Â Â boolÂ compÂ =Â keyCompare(pressed_keys,Â last_key_pressed);
    Â Â Â Â Â Â Â Â ifÂ (!comp){
    Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â !=Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â boolÂ resultÂ =Â 0;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if(pressed_keys[0]Â ==Â 'A'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â init_new_value();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(0);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â ==Â 'D'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elseÂ if(pressed_keys[0]Â >='0'Â &&Â pressed_keys[0]Â <=Â '9'){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ *Â 10;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â countÂ =Â countÂ +Â (pressed_keys[0]Â -Â 48);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (count>=10){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resultÂ =Â detect_point();
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lcd_show_input(result);
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â keyCopy(last_key_pressed,Â pressed_keys);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;Â Â Â 
    }

**main()** contient l'ensemble du processus du programme, comme dÃ©crit ci-dessous :

1) Initialiser le **LCD1602 I2C** et le **clavier**.

2) Utiliser **init_new_value()** pour gÃ©nÃ©rer un nombre alÃ©atoire compris entre **0 et 99**.

3) DÃ©tecter si un bouton est pressÃ© et lire l'entrÃ©e du clavier.

4) Si le bouton '**A**' est pressÃ©, un nombre alÃ©atoire compris entre **0 et 99** est 
   gÃ©nÃ©rÃ© et le jeu commence.

5) Si le bouton '**D**' est dÃ©tectÃ©, le programme entre dans la phase de jugement et 
   affiche le rÃ©sultat sur le LCD. Cette Ã©tape permet de juger le rÃ©sultat mÃªme si un 
   seul chiffre est entrÃ©, puis le bouton '**D**' est pressÃ©.

6) Si un bouton entre **0 et 9** est pressÃ©, la valeur de **count** est modifiÃ©e ; si 
   **count** est supÃ©rieur Ã  **10**, le jugement est dÃ©clenchÃ©.

7) Les changements du jeu et les valeurs associÃ©es sont affichÃ©s sur le **LCD1602**.
