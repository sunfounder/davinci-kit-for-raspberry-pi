# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, SunFounder
# This file is distributed under the same license as the SunFounder Davinci
# Kit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: SunFounder Davinci Kit\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-19 18:22+0800\n"
"PO-Revision-Date: 2021-05-31 20:59+0800\n"
"Last-Translator: \n"
"Language: de\n"
"Language-Team: \n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../1.1.4_7-segment_display.rst:2
msgid "1.1.4 7-segment Display"
msgstr "1.1.4 7-Segment-Anzeige"

#: ../1.1.4_7-segment_display.rst:5
msgid "Introduction"
msgstr "Einführung"

#: ../1.1.4_7-segment_display.rst:7
msgid ""
"Let's try to drive a 7-segment display to show a figure from 0 to 9 and A"
" to F."
msgstr ""
"Versuchen wir, eine 7-Segment-Anzeige anzutreiben, um eine Nummer von 0 "
"bis 9 und von A bis F anzuzeigen."

#: ../1.1.4_7-segment_display.rst:11
msgid "Components"
msgstr "Komponenten"

#: ../1.1.4_7-segment_display.rst:16
msgid "Principle"
msgstr "Prinzip"

#: ../1.1.4_7-segment_display.rst:18
msgid "**7-Segment Display**"
msgstr "**7-Segment-Anzeige**"

#: ../1.1.4_7-segment_display.rst:20
msgid ""
"A 7-segment display is an 8-shaped component which packages 7 LEDs. Each "
"LED is called a segment - when energized, one segment forms part of a "
"numeral to be displayed."
msgstr ""
"Ein 7-Segment-Display ist eine 8-förmige Komponente, die 7 LEDs enthält. "
"Jede LED wird als Segment bezeichnet. Bei Erregung ist ein Segment Teil "
"einer anzuzeigenden Ziffer."

#: ../1.1.4_7-segment_display.rst:24
msgid ""
"There are two types of pin connection: Common Cathode (CC) and Common "
"Anode (CA). As the name suggests, a CC display has all the cathodes of "
"the 7 LEDs connected when a CA display has all the anodes of the 7 "
"segments connected. In this kit, we use the former."
msgstr ""
"Es gibt zwei Typen von Pin-Verbindungen: Common Cathode (CC) und Common "
"Anode (CA). Wie der Name schon sagt, sind an einer CC-Anzeige alle "
"Kathoden der 7 LEDs angeschlossen, wenn an einer CA-Anzeige alle Anoden "
"der 7 Segmente angeschlossen sind. In diesem Kit verwenden wir der "
"erstere."

#: ../1.1.4_7-segment_display.rst:34
msgid ""
"Each of the LEDs in the display is given a positional segment with one of"
" its connection pins led out from the rectangular plastic package. These "
"LED pins are labeled from \"a\" through to \"g\" representing each "
"individual LED. The other LED pins are connected together forming a "
"common pin. So by forward biasing the appropriate pins of the LED "
"segments in a particular order, some segments will brighten and others "
"stay dim, thus showing the corresponding character on the display."
msgstr ""
"Jede der LEDs im Display erhält ein Positionssegment, wobei einer der "
"Verbindungsstifte aus dem rechteckigen Kunststoffgehäuse herausgeführt "
"wird. Diese LED-Pins sind von \"a\" bis \"g\" bezeichnet und "
"repräsentieren jede einzelne LED. Die anderen LED-Pins sind miteinander "
"verbunden und bilden einen gemeinsamen Pin. Wenn Sie also die "
"entsprechenden Pins der LED-Segmente in einer bestimmten Reihenfolge nach"
" vorne vorspannen, werden einige Segmente heller und andere dunkel "
"bleiben, wodurch das entsprechende Zeichen auf dem Display angezeigt "
"wird."

#: ../1.1.4_7-segment_display.rst:42
msgid "**Display Codes**"
msgstr "**Koden anzeigen**"

#: ../1.1.4_7-segment_display.rst:44
msgid ""
"To help you get to know how 7-segment displays(Common Cathode) display "
"Numbers, we have drawn the following table. Numbers are the number 0-F "
"displayed on the 7-segment display; (DP) GFEDCBA refers to the "
"corresponding LED set to 0 or 1, For example, 00111111 means that DP and "
"G are set to 0, while others are set to 1. Therefore, the number 0 is "
"displayed on the 7-segment display, while HEX Code corresponds to "
"hexadecimal number."
msgstr ""
"Damit Sie wissen können, wie 7-Segment-Anzeigen (Common Cathode) Numbers "
"anzeigen, haben wir die folgende Tabelle gezeichnet. Nummer sind die "
"Nummer 0-F, die auf der 7-Segment-Anzeige angezeigt werden. (DP) GFEDCBA "
"bezieht sich auf die entsprechende LED, die auf 0 oder 1 gesetzt ist. "
"Beispielsweise bedeutet 00111111, dass DP und G auf 0 gesetzt sind, "
"während andere auf 1 gesetzt sind. Daher wird die Nummer 0 auf dem 7"
"-Segment-Display angezeigt, während der HEX-Kode der Hexadezimalzahl "
"entspricht."

#: ../1.1.4_7-segment_display.rst:55
msgid "**74HC595**"
msgstr "**74HC595**"

#: ../1.1.4_7-segment_display.rst:57
msgid ""
"The 74HC595 consists of an 8−bit shift register and a storage register "
"with three−state parallel outputs. It converts serial input into parallel"
" output so you can save IO ports of an MCU."
msgstr ""
"Der 74HC595 besteht aus einem 8-Bit-Schieberegister und einem "
"Speicherregister mit parallelen Ausgängen mit drei Zuständen. Es wandelt "
"den seriellen Eingang in einen parallelen Ausgang um, sodass Sie E / "
"A-Ports einer MCU speichern können."

#: ../1.1.4_7-segment_display.rst:61
msgid ""
"When MR (pin10) is high level and OE (pin13) is low level, data is input "
"in the rising edge of SHcp and goes to the memory register through the "
"rising edge of SHcp. If the two clocks are connected together, the shift "
"register is always one pulse earlier than the memory register. There is a"
" serial shift input pin (Ds), a serial output pin (Q) and an asynchronous"
" reset button (low level) in the memory register. The memory register "
"outputs a Bus with a parallel 8-bit and in three states. When OE is "
"enabled (low level), the data in memory register is output to the bus."
msgstr ""
"Wenn MR (Pin 10) einen hohen Niveaul und OE (Pin 13) einen niedrigen "
"Niveaul aufweist, werden Daten in die ansteigende Flanke von SHcp "
"eingegeben und gehen über die ansteigende Flanke von SHcp in das "
"Speicherregister. Wenn die beiden Takte miteinander verbunden sind, ist "
"das Schieberegister immer einen Impuls früher als das Speicherregister. "
"Es gibt einen seriellen Verschiebungseingangspin (Ds), einen seriellen "
"Ausgangspin (Q) und eine asynchrone Rücksetztaste (niedriger Niveaul) im "
"Speicherregister. Das Speicherregister gibt einen Bus mit einem "
"parallelen 8-Bit und in drei Zuständen aus. Wenn OE aktiviert ist "
"(niedriger Niveaul), werden die Daten im Speicherregister an den Bus "
"ausgegeben."

#: ../1.1.4_7-segment_display.rst:78
msgid "**Pins of 74HC595 and their functions**:"
msgstr "**Pins von 74HC595 und ihre Funktionen**:"

#: ../1.1.4_7-segment_display.rst:80
msgid ""
"**Q0-Q7**: 8-bit parallel data output pins, able to control 8 LEDs or 8 "
"pins of 7-segment display directly."
msgstr ""
"**Q0-Q7** : 8-Bit-Parallel-Datenausgangspins, die 8 LEDs oder 8 Pins der "
"7-Segment-Anzeige direkt steuern können."

#: ../1.1.4_7-segment_display.rst:82
msgid ""
"**Q7’**: Series output pin, connected to DS of another 74HC595 to connect"
" multiple 74HC595s in series."
msgstr ""
"**Q7’** : Serienausgangspin, verbunden mit DS eines anderen 74HC595, um "
"mehrere 74HC595 in Reihe zu schalten."

#: ../1.1.4_7-segment_display.rst:84
msgid "**MR**: Reset pin, active at low level;"
msgstr "**MR**: Reset-Pin, aktiv bei niedrigem Niveau;"

#: ../1.1.4_7-segment_display.rst:86
msgid ""
"**SHcp**: Time sequence input of shift register. On the rising edge, the "
"data in shift register moves successively one bit, i.e. data in Q1 moves "
"to Q2, and so forth. While on the falling edge, the data in shift "
"register remain unchanged."
msgstr ""

#: ../1.1.4_7-segment_display.rst:88
msgid ""
"**STcp**: Time sequence input of storage register. On the rising edge, "
"data in the shift register moves into memory register."
msgstr ""
"**STcp**: Zeitfolgeeingabe des Speicherregisters. Bei der steigenden "
"Flanke werden Daten im Schieberegister in das Speicherregister "
"verschoben."

#: ../1.1.4_7-segment_display.rst:90
msgid "**CE**: Output enable pin, active at low level."
msgstr "**CE**: Ausgangsfreigabepin, aktiv auf niedrigem Niveau."

#: ../1.1.4_7-segment_display.rst:92
msgid "**DS**: Serial data input pin"
msgstr "**DS**: Serieller Dateneingangspin"

#: ../1.1.4_7-segment_display.rst:94
msgid "**VCC**: Positive supply voltage"
msgstr "**VCC**: Positive Versorgungsspannung"

#: ../1.1.4_7-segment_display.rst:96
msgid "**GND**: Ground"
msgstr "**GND**: Boden"

#: ../1.1.4_7-segment_display.rst:99
msgid "Schematic Diagram"
msgstr "Schematische Darstellung"

#: ../1.1.4_7-segment_display.rst:101
msgid ""
"Connect pin ST_CP of 74HC595 to Raspberry Pi GPIO18, SH_CP to GPIO27, DS "
"to GPIO17, parallel output ports to 8 segments of the LED segment "
"display. Input data in DS pin to shift register when SH_CP (the clock "
"input of the shift register) is at the rising edge, and to the memory "
"register when ST_CP (the clock input of the memory) is at the rising "
"edge. Then you can control the states of SH_CP and ST_CP via the "
"Raspberry Pi GPIOs to transform serial data input into parallel data "
"output so as to save Raspberry Pi GPIOs and drive the display."
msgstr ""
"Verbinden Sie Pin ST_CP von 74HC595 mit Raspberry Pi GPIO18, SH_CP mit "
"GPIO27, DS mit GPIO17 und parallele Ausgangsanschlüsse mit 8 Segmenten "
"der LED-Segmentanzeige. Geben Sie Daten in den DS-Pin in das "
"Schieberegister ein, wenn sich SH_CP (der Takteingang des "
"Schieberegisters) an der ansteigenden Flanke befindet, und in das "
"Speicherregister, wenn sich ST_CP (der Takteingang des Speichers) an der "
"ansteigenden Flanke befindet. Anschließend können Sie die Zustände von "
"SH_CP und ST_CP über die Raspberry Pi-GPIOs steuern, um die serielle "
"Dateneingabe in eine parallele Datenausgabe umzuwandeln, um Raspberry Pi-"
"GPIOs zu speichern und die Anzeige zu steuern."

#: ../1.1.4_7-segment_display.rst:111
msgid "T-Board Name"
msgstr "T-Karte Name"

#: ../1.1.4_7-segment_display.rst:111
msgid "physical"
msgstr "physisch"

#: ../1.1.4_7-segment_display.rst:111
msgid "wiringPi"
msgstr "wiringPi"

#: ../1.1.4_7-segment_display.rst:111
msgid "BCM"
msgstr "BCM"

#: ../1.1.4_7-segment_display.rst:112
msgid "GPIO17"
msgstr "GPIO17"

#: ../1.1.4_7-segment_display.rst:112
msgid "Pin 11"
msgstr "Pin 11"

#: ../1.1.4_7-segment_display.rst:112
msgid "0"
msgstr "0"

#: ../1.1.4_7-segment_display.rst:112
msgid "17"
msgstr "17"

#: ../1.1.4_7-segment_display.rst:113
msgid "GPIO18"
msgstr "GPIO18"

#: ../1.1.4_7-segment_display.rst:113
msgid "Pin 12"
msgstr "Pin 12"

#: ../1.1.4_7-segment_display.rst:113
msgid "1"
msgstr "1"

#: ../1.1.4_7-segment_display.rst:113
msgid "18"
msgstr "18"

#: ../1.1.4_7-segment_display.rst:114
msgid "GPIO27"
msgstr "GPIO27"

#: ../1.1.4_7-segment_display.rst:114
msgid "Pin 13"
msgstr "Pin 13"

#: ../1.1.4_7-segment_display.rst:114
msgid "2"
msgstr "2"

#: ../1.1.4_7-segment_display.rst:114
msgid "27"
msgstr "27"

#: ../1.1.4_7-segment_display.rst:121
msgid "Experimental Procedures"
msgstr "Experimentelle Verfahren"

#: ../1.1.4_7-segment_display.rst:123
msgid "**Step 1:** Build the circuit."
msgstr "**Schritt 1:** Bauen Sie die Schaltung auf."

#: ../1.1.4_7-segment_display.rst:129
msgid "For C Language Users"
msgstr "Für Benutzer in C-Sprache"

#: ../1.1.4_7-segment_display.rst:131 ../1.1.4_7-segment_display.rst:270
msgid "Step 2: Get into the folder of the code."
msgstr "**Schritt 2:** Gehen Sie in den Ordner der Kode."

#: ../1.1.4_7-segment_display.rst:141
msgid "Step 3: Compile."
msgstr "**Schritt 3:** Kompilieren."

#: ../1.1.4_7-segment_display.rst:151
msgid "Step 4: Run the executable file above."
msgstr "**Schritt 4:** Führen Sie die obige ausführbare Datei aus."

#: ../1.1.4_7-segment_display.rst:161 ../1.1.4_7-segment_display.rst:290
msgid "After the code runs, you'll see the 7-segment display display 0-9, A-F."
msgstr ""
"Nachdem der Code ausgeführt wurde, wird die 7-Segment-Anzeige 0-9, A-F "
"angezeigt."

#: ../1.1.4_7-segment_display.rst:165
msgid ""
"If it does not work after running, please refer to :ref:`C code is not "
"working?`"
msgstr ""
"Wenn es nach dem Ausführen nicht funktioniert, lesen Sie bitte :ref:`C "
"code is not working?`"

#: ../1.1.4_7-segment_display.rst:167 ../1.1.4_7-segment_display.rst:292
msgid "**Code**"
msgstr "**Code**"

#: ../1.1.4_7-segment_display.rst:217 ../1.1.4_7-segment_display.rst:352
msgid "**Code Explanation**"
msgstr "**Code Erklärung**"

#: ../1.1.4_7-segment_display.rst:219
msgid ""
"unsigned char SegCode[16] = "
"{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};"
" A segment code array from 0 to F in Hexadecimal (Common cathode)."
msgstr ""
"unsigned char SegCode[16] = "
"{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};"
" Ein Segmentcode-Array von 0 bis F in hexadezimaler Darstellung "
"(gemeinsame Kathode)."

#: ../1.1.4_7-segment_display.rst:233
msgid ""
"Set ds, st_cp, sh_cp three pins to OUTPUT, and the initial state as 0. "
"void hc595_shift(unsigned char dat){} To assign 8 bit value to 74HC595’s "
"shift register."
msgstr ""
"Setzen Sie ds, st_cp, sh_cp drei Pins auf OUTPUT und den Anfangszustand "
"auf 0. void hc595_shift(unsigned char dat){} Zuweisen eines 8-Bit-Werts "
"zum Schieberegister des 74HC595."

#: ../1.1.4_7-segment_display.rst:241
msgid ""
"Assign the dat data to SDI(DS) by bits. Here we assume dat=0x3f(0011 "
"1111, when i=2, 0x3f will shift left(<<) 2 bits. 1111 1100 (0x3f << 2) & "
"1000 0000 (0x80) = 1000 0000, is true."
msgstr ""
"Ordnen Sie die Datendaten SDI (DS) in Bits zu. Hier nehmen wir an, dass "
"dat = 0x3f (0011 1111, wenn i = 2, 0x3f 2 Bits nach links (<<) "
"verschiebt. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000 ist "
"wahr."

#: ../1.1.4_7-segment_display.rst:247
msgid ""
"SRCLK's initial value was set to 0, and here it's set to 1, which is to "
"generate a rising edge pulse, then shift the DS date to shift register."
msgstr ""
"Der Anfangswert von SRCLK wurde auf 0 gesetzt, und hier wird er auf 1 "
"gesetzt, um einen Anstiegsflankenimpuls zu erzeugen und dann das DS-Datum"
" in das Schieberegister zu verschieben."

#: ../1.1.4_7-segment_display.rst:253
msgid ""
"RCLK's initial value was set to 0, and here it's set to 1, which is to "
"generate a rising edge, then shift data from shift register to storage "
"register."
msgstr ""
"Der Anfangswert von RCLK wurde auf 0 gesetzt, und hier wird er auf 1 "
"gesetzt, um eine ansteigende Flanke zu erzeugen und dann Daten vom "
"Schieberegister zum Speicherregister zu verschieben."

#: ../1.1.4_7-segment_display.rst:265
msgid ""
"In this for loop, we use \\\"%1X\\\" to output i as a hexadecimal number."
" Apply i to find the corresponding segment code in the SegCode[] array, "
"and employ hc595_shift() to pass the SegCode into 74HC595's shift "
"register."
msgstr ""
"In dieser for-Schleife verwenden wir \"%1X\", um i als Hexadezimalzahl "
"auszugeben. Wenden Sie i an, um den entsprechenden Segmentcode im "
"SegCode[]-Array zu finden, und verwenden Sie hc595_shift(), um den "
"SegCode in das Schieberegister des 74HC595 zu übergeben."

#: ../1.1.4_7-segment_display.rst:268
msgid "For Python Language Users"
msgstr "Für Python-Sprachbenutzer"

#: ../1.1.4_7-segment_display.rst:280
msgid "Step 3: Run."
msgstr "**Schritt 3:** Ausführen."

#: ../1.1.4_7-segment_display.rst:297
 
msgid ""
"You can **Modify/Reset/Copy/Run/Stop** the code below. But before that, "
"you need to go to  source code path like ``davinci-kit-for-raspberry-"
"pi/python``."
msgstr ""
"Sie können den folgenden Code **Ändern/Zurücksetzen/ "
"Kopieren/Ausführen/Stoppen**. Zuvor müssen Sie jedoch zu einem "
"Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python`` gehen."

#: ../1.1.4_7-segment_display.rst:358
msgid "A segment code array from 0 to F in Hexadecimal (Common cathode)."
msgstr ""
"Ein Segmentcode-Array von 0 bis F in hexadezimaler Darstellung "
"(gemeinsame Kathode)."

#: ../1.1.4_7-segment_display.rst:368
msgid ""
"Set ds, st_cp, sh_cp three pins to output and the initial state as low "
"level."
msgstr ""
"Setzen Sie ds, st_cp, sh_cp auf drei Pins und den Ausgangszustand auf "
"niedrigen Niveau."

#: ../1.1.4_7-segment_display.rst:374
msgid ""
"Assign the dat data to SDI(DS) by bits. Here we assume dat=0x3f(0011 "
"1111, when bit=2, 0x3f will shift right(<<) 2 bits. 1111 1100 (0x3f << 2)"
" & 1000 0000 (0x80) = 1000 0000, is true."
msgstr ""
"Ordnen Sie die Datendaten SDI (DS) in Bits zu. Hier nehmen wir an, dass "
"dat = 0x3f (0011 1111, wenn Bit = 2, 0x3f 2 Bits nach rechts (<<) "
"verschiebt. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000 ist "
"wahr."

#: ../1.1.4_7-segment_display.rst:380
msgid ""
"SRCLK's initial value was set to LOW, and here it's set to HIGH, which is"
" to generate a rising edge pulse, then shift the DS date to shift "
"register."
msgstr ""
"Der Anfangswert von SRCLK war auf NIEDRIG gesetzt, und hier wird er auf "
"HIGH gesetzt, um einen ansteigenden Flankenimpuls zu erzeugen und dann "
"das DS-Datum in das Schieberegister zu verschieben."

#: ../1.1.4_7-segment_display.rst:386
msgid ""
"RCLK's initial value was set to LOW, and here it's set to HIGH, which is "
"to generate a rising edge, then shift data from shift register to storage"
" register."
msgstr ""
"Der Anfangswert von RCLK wurde auf NIEDRIG gesetzt, und hier wird er auf "
"HOCH gesetzt, um eine ansteigende Flanke zu erzeugen und dann Daten vom "
"Schieberegister zum Speicherregister zu verschieben."

#: ../1.1.4_7-segment_display.rst:389
msgid ""
"The hexadecimal format of number 0~15 are (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "
"A, B, C, D, E, F)"
msgstr ""
"Das hexadezimale Format der Nummer 0 bis 15 ist (0, 1, 2, 3, 4, 5, 6, 7, "
"8, 9, A, B, C, D, E, F)."

#: ../1.1.4_7-segment_display.rst:392
msgid "Phenomenon Picture"
msgstr "Phänomen Bild"

