.. note::

    Bonjour et bienvenue dans la communautÃ© des passionnÃ©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et relevez vos dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprenez et Partagez** : Ã‰changez des astuces et des tutoriels pour perfectionner vos compÃ©tences.
    - **AperÃ§us exclusifs** : BÃ©nÃ©ficiez d'un accÃ¨s anticipÃ© aux nouvelles annonces de produits et aux avant-premiÃ¨res.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des concours et Ã  des promotions lors des fÃªtes.

    ğŸ‘‰ PrÃªt Ã  explorer et Ã  crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.8 Moniteur de Surchauffe
===============================

Introduction
--------------

Vous souhaitez peut-Ãªtre crÃ©er un dispositif de surveillance de la surchauffe adaptÃ© 
Ã  diverses situations, par exemple, dans une usine, si vous souhaitez activer une alarme 
et Ã©teindre automatiquement une machine en cas de surchauffe d'un circuit. Dans cette leÃ§on,
nous allons utiliser un thermistor, un joystick, un buzzer, une LED et un afficheur LCD 
pour rÃ©aliser un appareil intelligent de surveillance de tempÃ©rature dont le seuil est 
ajustable.

Composants
------------

.. image:: img/list_Overheat_Monitor.png
    :align: center

.. image:: img/list_Overheat_Monitor2.png
    :align: center


SchÃ©ma de cÃ¢blage
-------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one8.png
   :width: 700
   :align: center


ProcÃ©dures expÃ©rimentales
----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: img/image258.png
   :alt: Overheat Monitor_bb
   :width: 800


**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.8/

**Ã‰tape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

**Ã‰tape 4 :** ExÃ©cutez le fichier compilÃ©.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le programme est lancÃ©, la tempÃ©rature actuelle et le seuil de 
tempÃ©rature Ã©levÃ© **40** sont affichÃ©s sur l'Ã©cran **I2C LCD1602**. Si 
la tempÃ©rature actuelle dÃ©passe le seuil, le buzzer et la LED se dÃ©clenchent 
pour vous alerter.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou s'il y a un message d'erreur indiquant: \"wiringPi.h: Aucun fichier ou rÃ©pertoire de ce type Â», veuillez consulter :ref:`C code is not working?`.


Le **Joystick** vous permet d'ajuster le seuil de tempÃ©rature Ã©levÃ©. En le 
basculant dans la direction des axes X et Y, vous pouvez augmenter ou diminuer 
la valeur actuelle du seuil. Appuyez Ã  nouveau sur le **Joystick** pour rÃ©initialiser 
le seuil Ã  sa valeur initiale.


**Explication du Code**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
        }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
        }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
        }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
        }
        else{
    Â Â Â Â Â Â Â Â returnÂ 0;
        }
    }

Cette fonction lit les valeurs des axes X et Y du joystick. Si **X>200**, 
la fonction renvoie **1** ; si **X<50**, elle renvoie **-1** ; si **Y>200**, 
elle renvoie **-10** ; et si **Y<50**, elle renvoie **10**.

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
        delay(100);
    }

Cette fonction ajuste le seuil de tempÃ©rature et l'affiche sur l'Ã©cran LCD I2C1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Cette fonction lit la valeur analogique du **CH0** (thermistor) de l'**ADC0834** et la convertit en valeur de tempÃ©rature.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
        delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
        }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
        }
    }

Cette fonction affiche la tempÃ©rature actuelle et le seuil de tempÃ©rature Ã©levÃ© 
sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe le seuil, le buzzer 
et la LED se dÃ©clenchent.

.. code-block:: c

    intÂ main(void)
    {
        setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
        {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
                delay(100);
                lcd_clear();
            }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
                upper_tem_setting();
            }
            else{
                monitoring_temp();
            }
        }
    Â Â Â Â returnÂ 0;
    }

La fonction **main()** contient le processus global du programme comme suit :


1) Lorsque le programme dÃ©marre, la valeur initiale de **stage** est **0**. 
La tempÃ©rature actuelle et le seuil de tempÃ©rature Ã©levÃ© **40** sont affichÃ©s 
sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe le seuil, le 
buzzer et la LED se dÃ©clenchent.

2) En appuyant sur le joystick, **stage** passe Ã  **1** et vous pouvez ajuster 
le seuil de tempÃ©rature Ã©levÃ©. En basculant le joystick dans la direction des axes 
X et Y, vous pouvez augmenter ou diminuer la valeur actuelle du seuil. Appuyez Ã  
nouveau sur le joystick pour rÃ©initialiser le seuil Ã  sa valeur initiale.

