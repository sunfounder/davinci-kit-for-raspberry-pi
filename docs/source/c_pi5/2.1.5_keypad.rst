.. note::

    隆Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **驴Por qu茅 unirse?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y Compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas Exclusivas**: Obt茅n acceso anticipado a anuncios de nuevos productos y avances.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy.

2.1.5 Teclado
=================

Introducci贸n
----------------

Un teclado es una matriz rectangular de botones. En este proyecto, lo utilizaremos para ingresar caracteres.

Componentes
-----------------

.. image:: img/list_2.1.5_keypad.png


Principio
--------------

**Teclado**

Un teclado es una matriz rectangular de 12 o 16 botones ON-OFF. 
Sus contactos se acceden a trav茅s de un conector adecuado para 
su conexi贸n a un cable plano o para su inserci贸n en una placa 
de circuito impreso. En algunos teclados, cada bot贸n conecta con 
un contacto separado en el conector, mientras que todos los botones 
comparten un terreno com煤n.

.. image:: img/image314.png


M谩s com煤nmente, los botones est谩n codificados en matriz, lo que significa 
que cada uno de ellos conecta un par 煤nico de conductores en una matriz. 
Esta configuraci贸n es adecuada para el sondeo por parte de un microcontrolador, 
que puede ser programado para enviar un pulso de salida a cada uno de los cuatro 
cables horizontales a su vez. Durante cada pulso, se verifica secuencialmente 
los cuatro cables verticales restantes para determinar cu谩l de ellos, si acaso, 
est谩 transportando una se帽al. Se deben agregar resistencias pull-up o pull-down 
a los cables de entrada para evitar que las entradas del microcontrolador se 
comporten de manera impredecible cuando no hay se帽al presente.

Diagrama Esquem谩tico
-------------------------

.. image:: img/image315.png


.. image:: img/image316.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: img/image186.png
    :width: 800



**Paso 2:** Abre el archivo de c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.5/

**Paso 3:** Compilar el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.5_Keypad.cpp -lwiringPi

**Paso 4:** Ejecutar.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Despu茅s de ejecutar el c贸digo, se imprimir谩n en pantalla los valores 
de los botones presionados en el teclado (valor del bot贸n).

.. note::

    Si no funciona despu茅s de ejecutarse, o si aparece un mensaje de error: \"wiringPi.h: No such file or directory\", consulta :ref:`C code is not working?`.

**C贸digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ // si la inicializaci贸n de wiring falla, imprime un mensaje en pantalla
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }

**Code Explanation**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

Declara cada tecla del teclado matricial en el arreglo keys[] y define los 
pines en cada fila y columna.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Esta es la parte de la funci贸n principal que lee e imprime el valor del bot贸n.

La funci贸n keyRead() leer谩 el estado de cada bot贸n.

Las funciones keyCompare() y keyCopy() se utilizan para determinar si el 
estado de un bot贸n ha cambiado (es decir, si se ha presionado o liberado un bot贸n).

keyPrint() imprimir谩 el valor del bot贸n cuyo nivel actual es alto (el bot贸n est谩 presionado).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Esta funci贸n asigna un nivel alto a cada fila por turno, y cuando se presiona 
una tecla en la columna, la columna en la que se encuentra la tecla recibe un 
nivel alto. Despu茅s del juicio de los bucles anidados, la compilaci贸n del estado 
de la tecla generar谩 un arreglo (result[]).

Al presionar el bot贸n 3:

.. image:: img/image187.png


RowPin [0] escribe un nivel alto, y colPin[2] tambi茅n obtiene un nivel alto. 
ColPin [0], colPin[1] y colPin[3] reciben un nivel bajo.

Esto nos da 0,0,1,0. Cuando rowPin[1], rowPin[2] y rowPin[3] est谩n escritos 
en nivel alto, colPin[0]~colPin[4] recibir谩n nivel bajo.

Despu茅s de que se completa el juicio de los bucles, se generar谩 un arreglo:

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Estas dos funciones se utilizan para juzgar si el estado de la tecla ha 
cambiado; por ejemplo, cuando sueltas la mano al presionar '3' o presionando '2', 
keyCompare() devuelve false.

KeyCopy() se usa para reescribir el valor actual del bot贸n en el arreglo 
last_key_pressed[BUTTON_NUM] despu茅s de cada comparaci贸n. As铆 podemos 
compararlos la pr贸xima vez.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Esta funci贸n se utiliza para imprimir el valor del bot贸n que est谩 actualmente 
presionado. Si se presiona el bot贸n '1', se imprimir谩 '1'. Si se presionan el 
bot贸n '1' y el bot贸n '3', se imprimir谩 '1, 3'.


