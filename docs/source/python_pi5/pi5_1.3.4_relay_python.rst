.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _1.3.4_py_pi5:

1.3.4 Relais
========================================

Einf√ºhrung
------------

In diesem Projekt lernen wir, ein Relais zu verwenden. Es ist eine der h√§ufig verwendeten Komponenten in automatischen Steuersystemen. Wenn die Spannung, der Strom, die Temperatur, der Druck usw. den vordefinierten Wert erreicht, √ºberschreitet oder unterschreitet, wird das Relais den Stromkreis verbinden oder unterbrechen, um die Ger√§te zu steuern und zu sch√ºtzen.

Erforderliche Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir folgende Komponenten. 

.. image:: ../python_pi5/img/1.3.4_relay_list.png

.. raw:: html

   <br/>

Schaltplan
-----------------

.. image:: ../python_pi5/img/1.3.4_relay_schematic.png


Versuchsdurchf√ºhrung
-----------------------

**Schritt 1:** Bauen Sie die Schaltung.

.. image:: ../python_pi5/img/1.3.4_relay_circuit.png

**Schritt 2:** √ñffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5


**Schritt 3:** Ausf√ºhren.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.4_Relay_zero.py

W√§hrend der Ausf√ºhrung des Codes leuchtet die LED auf. Dar√ºber hinaus k√∂nnen Sie ein Ticken h√∂ren, verursacht durch das Unterbrechen des normalerweise geschlossenen Kontakts und das Schlie√üen des normalerweise offenen Kontakts.

.. warning::

    Wenn die Fehlermeldung ``RuntimeError: Cannot determine SOC peripheral base address`` angezeigt wird, lesen Sie bitte :ref:`faq_soc`

**Code**

.. note::

    Sie k√∂nnen den folgenden Code **√Ñndern/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen**. Bevor Sie das tun, m√ºssen Sie jedoch zum Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python-pi5`` gehen. Nach der √Ñnderung des Codes k√∂nnen Sie ihn direkt ausf√ºhren, um die Wirkung zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice  # Importieren Sie die Klasse zur Steuerung der GPIO-Pins
   from time import sleep  # Importieren Sie die Schlaffunktion f√ºr Verz√∂gerungen

   # Initialisieren Sie das Relais, das mit dem GPIO-Pin 17 verbunden ist
   relais = OutputDevice(17)

   try:
       # Schleife zum kontinuierlichen Umschalten des Zustands des Relais alle Sekunde
       while True:
           print('Relais √∂ffnet...')  # Informieren Sie, dass das Relais aktiviert wird
           relais.on()  # Schalten Sie das Relais ein (unter der Annahme einer aktiven Niedrigkonfiguration)
           sleep(1)   # Halten Sie das Relais f√ºr 1 Sekunde im eingeschalteten Zustand

           print('...Relais schlie√üt')  # Informieren Sie, dass das Relais deaktiviert wird
           relais.off()  # Schalten Sie das Relais aus
           sleep(1)   # Halten Sie das Relais f√ºr 1 Sekunde im ausgeschalteten Zustand

   except KeyboardInterrupt:
       # Behandeln Sie eine Tastaturunterbrechung (wie Ctrl+C), um aus der Schleife auszusteigen
       relais.off()  # Stellen Sie sicher, dass das Relais ausgeschaltet ist, bevor Sie den Vorgang beenden
       pass
       

**Code-Erkl√§rung**

#. Es importiert ``OutputDevice`` von ``gpiozero`` zur Steuerung der GPIO-Pins und ``sleep`` von ``time`` zur Hinzuf√ºgung von Verz√∂gerungen.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice  # Importieren Sie die Klasse zur Steuerung der GPIO-Pins
       from time import sleep  # Importieren Sie die Schlaffunktion f√ºr Verz√∂gerungen

#. Initialisiert ein ``OutputDevice``-Objekt f√ºr das Relais, das mit dem GPIO-Pin 17 verbunden ist.

   .. code-block:: python

       # Initialisieren Sie das Relais, das mit dem GPIO-Pin 17 verbunden ist
       relais = OutputDevice(17)

#. Innerhalb des ``try``-Blocks schaltet eine ``while True``-Schleife den Zustand des Relais kontinuierlich um. Das Relais wird ein- und ausgeschaltet, wobei zwischen jedem Zustand eine Verz√∂gerung von 1 Sekunde besteht, begleitet von Konsolendruckanzeigen.

   .. code-block:: python

       try:
           # Schleife zum kontinuierlichen Umschalten des Zustands des Relais alle Sekunde
           while True:
               print('Relais √∂ffnet...')  # Informieren Sie, dass das Relais aktiviert wird
               relais.on()  # Schalten Sie das Relais ein (unter der Annahme einer aktiven Niedrigkonfiguration)
               sleep(1)   # Halten Sie das Relais f√ºr 1 Sekunde im eingeschalteten Zustand

               print('...Relais schlie√üt')  # Informieren Sie, dass das Relais deaktiviert wird
               relais.off()  # Schalten Sie das Relais aus
               sleep(1)   # Halten Sie das Relais f√ºr 1 Sekunde im ausgeschalteten Zustand

#. F√§ngt eine KeyboardInterrupt (wie Ctrl+C) ab, um ein ordnungsgem√§√ües Beenden des Skripts zu erm√∂glichen. Das Relais wird ausgeschaltet, bevor das Skript beendet wird.

   .. code-block:: python
      
      except KeyboardInterrupt:
      # Behandeln Sie eine Tastaturunterbrechung (wie Ctrl+C), um aus der Schleife auszusteigen
      relais.off()  # Stellen Sie sicher, dass das Relais ausgeschaltet ist, bevor Sie den Vorgang beenden
      pass
