.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder pour les passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez au c≈ìur de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !
    
3.1.3 Avertisseur de recul
=============================

Introduction
---------------

Dans ce projet, nous utiliserons un √©cran LCD, un buzzer et des capteurs 
ultrasoniques pour cr√©er un syst√®me d'aide au stationnement en marche arri√®re. 
Nous pouvons l'installer sur un v√©hicule t√©l√©command√© pour simuler le processus 
r√©el de recul d'une voiture dans un garage.

Composants
------------

.. image:: img/list_Reversing_Alarm.png
    :align: center

Sch√©ma de c√¢blage
--------------------

Le capteur ultrasonique d√©tecte la distance entre lui-m√™me et l'obstacle, qui sera 
affich√©e sur l'√©cran LCD sous forme de code. En m√™me temps, le capteur ultrasonique 
fait √©mettre au buzzer un son d'avertissement de fr√©quence diff√©rente selon la valeur 
de la distance.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO17       Pin 11   0        17
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one3.png
    :width: 800
    :align: center

Proc√©dures exp√©rimentales
---------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image242.png
    :width: 800
    :align: center

**Pour les utilisateurs de langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

    <run></run>
 
.. code-block:: 
     
    cd ~/davinci-kit-for-raspberry-pi/c/3.1.3/
 
**√âtape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.3_ReversingAlarm.c -lwiringPi

**√âtape 4 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'ex√©cute, le module capteur ultrasonique d√©tecte la distance par 
rapport √† l'obstacle et affiche ensuite l'information sur la distance sur l'√©cran 
LCD1602 ; en outre, le buzzer √©met un signal sonore dont la fr√©quence varie en 
fonction de la distance.

.. note::

    * Si un message d'erreur appara√Æt ``wiringPi.h: Aucun fichier ou dossier de ce type``, veuillez vous r√©f√©rer √† :ref:`install_wiringpi`.
    * Si vous obtenez l'erreur ``Unable to open I2C device: No such file or directory``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer I2C et v√©rifier si le c√¢blage est correct.
    * Si le code et le c√¢blage sont corrects mais que l'√©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiom√®tre √† l'arri√®re pour augmenter le contraste.

**Code**

.. note::
    Les codes suivants sont incomplets. Si vous souhaitez consulter les codes complets, 
    il est conseill√© d'utiliser la commande ``nano 3.1.1_ReversingAlarm.c``.

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <sys/time.h>
    #include <wiringPi.h>
    #include <wiringPiI2C.h>
    #include <string.h>

    #define Trig    4
    #define Echo    5
    #define Buzzer  0

    int LCDAddr = 0x27;
    int BLEN = 1;
    int fd;

    // voici la fonction pour l'√©cran LCD
    void write_word(int data){...}

    void send_command(int comm){...}

    void send_data(int data){...}

    void lcdInit(){...}

    void clear(){...}

    void write(int x, int y, char data[]){...}

    // voici la fonction pour l'ultrasonique
    void ultraInit(void){...}

    float disMeasure(void){...}

    // voici la fonction principale
    int main(void)
    {
        float dis;
        char result[10];
        if(wiringPiSetup() == -1){ 
            printf("setup wiringPi failed !");
            return 1;
        }

        pinMode(Buzzer,OUTPUT);
        fd = wiringPiI2CSetup(LCDAddr);
        lcdInit();
        ultraInit();

        clear();
        write(0, 0, "Ultrasonic Starting"); 
        write(1, 1, "By Sunfounder");   

        while(1){
            dis = disMeasure();
            printf("%.2f cm \n",dis);
            delay(100);
            digitalWrite(Buzzer,LOW);
            if (dis > 400){
                clear();
                write(0, 0, "Error");
                write(3, 1, "Out of range");    
                delay(500);
            }
            else
            {
                clear();
                write(0, 0, "Distance is");
                sprintf(result,"%.2f cm",dis);
                write(5, 1, result);

                if(dis>=50)
                {delay(500);}
                else if(dis<50 & dis>20) {
                    for(int i=0;i<2;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(200);
                    }
                }
                else if(dis<=20){
                    for(int i=0;i<5;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(50);
                    }
                }
            }   
        }

        return 0;
    }


**Explication du code**

.. code-block:: c

    pinMode(Buzzer,OUTPUT);
    fd = wiringPiI2CSetup(LCDAddr);
    lcdInit();
    ultraInit();

Dans ce programme, nous utilisons de mani√®re synth√©tique les composants pr√©c√©demment pr√©sent√©s. Ici, nous utilisons des buzzers, un √©cran LCD et un capteur ultrasonique. Nous pouvons les initialiser de la m√™me mani√®re que pr√©c√©demment.

.. code-block:: c

    dis = disMeasure();
     printf("%.2f cm \n",dis);
    digitalWrite(Buzzer,LOW);
    if (dis > 400){
         write(0, 0, "Error");
         write(3, 1, "Out of range");    
    }
    else
    {
        write(0, 0, "Distance is");
        sprintf(result,"%.2f cm",dis);
        write(5, 1, result);
	}

Ici, nous obtenons la valeur du capteur ultrasonique et d√©terminons la distance par calcul.

Si la valeur de la distance est sup√©rieure √† la port√©e d√©tectable, un message d'erreur 
est affich√© sur l'√©cran LCD. Et si la distance se situe dans la plage acceptable, les 
r√©sultats correspondants seront affich√©s.

.. code-block:: c

    sprintf(result,"%.2f cm",dis);

Comme le mode de sortie de l'√©cran LCD ne supporte que les caract√®res, et que la variable 
`dis` stocke une valeur de type flottant, nous devons utiliser `sprintf()`. Cette fonction 
convertit la valeur flottante en un caract√®re et la stocke dans la variable cha√Æne `result[]`. 
`%.2f` signifie conserver deux chiffres apr√®s la virgule.

.. code-block:: c

    if(dis>=50)
    {delay(500);}
    else if(dis<50 & dis>20) {
        for(int i=0;i<2;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(200);
        }
    }
    else if(dis<=20){
        for(int i=0;i<5;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(50);
        }
    }

Cette condition permet de contr√¥ler le son du buzzer. Selon la distance, elle se divise 
en trois cas, chacun produisant des fr√©quences sonores diff√©rentes. Comme la valeur totale 
du d√©lai est de 500 ms, tous les cas offrent un intervalle de 500 ms pour le capteur ultrasonique.


**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

    <run></run>
 
.. code-block::
 
    cd ~/davinci-kit-for-raspberry-pi/python/
 
**√âtape 3 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.3_ReversingAlarm.py

Lorsque le code s'ex√©cute, le module capteur ultrasonique d√©tecte la distance par 
rapport √† l'obstacle et affiche ensuite l'information sur la distance sur l'√©cran 
LCD1602 ; en outre, le buzzer √©met un signal sonore dont la fr√©quence varie en 
fonction de la distance.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer le protocole I2C.
    * Si l'erreur ``ModuleNotFoundError: No module named 'smbus2'`` appara√Æt, veuillez ex√©cuter la commande ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O`` se produit, cela signifie que le module est mal c√¢bl√© ou qu'il est d√©fectueux.
    * Si le code et le c√¢blage sont corrects mais que l'√©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiom√®tre √† l'arri√®re pour augmenter le contraste.


**Code**

.. note::

    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre sur le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import time
    import RPi.GPIO as GPIO

    TRIG = 16
    ECHO = 18
    BUZZER = 11

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(adresse esclave, √©clairage de fond)
        LCD1602.clear()   
        LCD1602.write(0, 0, 'Ultrasonic Starting')
        LCD1602.write(1, 1, 'By SunFounder')
        time.sleep(2)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

    def distance():
        GPIO.output(TRIG, 0)
        time.sleep(0.000002)

        GPIO.output(TRIG, 1)
        time.sleep(0.00001)
        GPIO.output(TRIG, 0)

        while GPIO.input(ECHO) == 0:
            a = 0
        time1 = time.time()
        while GPIO.input(ECHO) == 1:
            a = 1
        time2 = time.time()

        during = time2 - time1
        return during * 340 / 2 * 100

    def destroy():
        GPIO.output(BUZZER, GPIO.LOW)
        GPIO.cleanup()
        LCD1602.clear()

    def loop():
        while True:
            dis = distance()
            print (dis, 'cm')
            print ('')
            GPIO.output(BUZZER, GPIO.LOW)
            if (dis > 400):
                LCD1602.clear()
            LCD1602.write(0, 0, 'Error')
            LCD1602.write(3, 1, 'Out of range')
                time.sleep(0.5)
            else:
                LCD1602.clear()
            LCD1602.write(0, 0, 'Distance is')
                LCD1602.write(5, 1, str(round(dis,2)) +' cm')
                if(dis>=50):
                    time.sleep(0.5)
                elif(dis<50 and dis>20):
                    for i in range(0,2,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.2)
                elif(dis<=20):
                    for i in range(0,5,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.05)


    if __name__ == "__main__":
        setup()
        try:       
            loop()
        except KeyboardInterrupt:
            destroy()



**Explication du code**

.. code-block:: python

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(adresse esclave, √©clairage de fond)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

Dans ce programme, nous utilisons de mani√®re synth√©tique les composants pr√©c√©demment 
d√©crits. Ici, nous employons des buzzers, un √©cran LCD et un capteur ultrasonique. 
Nous pouvons les initialiser de la m√™me mani√®re que pr√©c√©demment.

.. code-block:: python

    dis = distance()
    print (dis, 'cm')
    print ('')
    GPIO.output(BUZZER, GPIO.LOW)
    if (dis > 400):
        LCD1602.clear()
        LCD1602.write(0, 0, 'Error')
        LCD1602.write(3, 1, 'Out of range')
        time.sleep(0.5)
    else:
        LCD1602.clear()
        LCD1602.write(0, 0, 'Distance is')
        LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Ici, nous r√©cup√©rons les valeurs du capteur ultrasonique et calculons la distance. 
Si la valeur de la distance d√©passe la plage de d√©tection, un message d'erreur 
s'affiche sur l'√©cran LCD. Si la distance est dans la plage de fonctionnement, les 
r√©sultats correspondants seront affich√©s.

LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Comme la sortie de l'√©cran LCD ne supporte que les types de caract√®res, nous devons 
utiliser **str()** pour convertir les valeurs num√©riques en caract√®res. Nous arrondissons 
les valeurs √† deux d√©cimales.

.. code-block:: python

    if(dis>=50)
    {delay(500);}
    else if(dis<50 & dis>20) {
        for(int i=0;i<2;i++){
            digitalWrite(Buzzer,HIGH);
            delay(50);
            digitalWrite(Buzzer,LOW);
            delay(200);
            }
        }
        else if(dis<=20){
            for(int i=0;i<5;i++){
            digitalWrite(Buzzer,HIGH);
            delay(50);
            digitalWrite(Buzzer,LOW);
            delay(50);
            }
        }

Cette condition est utilis√©e pour contr√¥ler le son du buzzer. Selon les diff√©rences 
de distance, elle est divis√©e en trois cas, chacun produisant des fr√©quences sonores 
diff√©rentes. Comme la valeur totale du d√©lai est de 500 ms, chaque cas fournit un 
intervalle de 500 ms permettant au capteur ultrasonique de fonctionner.


Image du ph√©nom√®ne
---------------------

.. image:: img/image243.jpeg
   :align: center