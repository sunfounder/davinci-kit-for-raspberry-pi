.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez vos d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et Partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.6 Module MPU6050
=======================

Introduction
---------------

Le MPU-6050 est le premier et le seul dispositif de suivi de mouvement 6 axes 
au monde (gyroscope 3 axes et acc√©l√©rom√®tre 3 axes), con√ßu pour les smartphones, 
tablettes et capteurs portables. Il se distingue par ses faibles besoins √©nerg√©tiques, 
son faible co√ªt et ses performances √©lev√©es.

Dans cette exp√©rience, nous utilisons l'I2C pour obtenir les valeurs des capteurs 
d'acc√©l√©ration et de gyroscope √† trois axes du MPU6050 et les afficher √† l'√©cran.

Composants
--------------

.. image:: img/list_2.2.6.png


Principe
----------

**MPU6050**

Le MPU-6050 est un dispositif de suivi de mouvement √† 6 axes (combinant un gyroscope 
3 axes et un acc√©l√©rom√®tre 3 axes).

Ses trois syst√®mes de coordonn√©es se d√©finissent ainsi :

Placez le MPU6050 √† plat sur la table, assurez-vous que la face avec l'√©tiquette est 
orient√©e vers le haut et qu'un point se trouve dans le coin sup√©rieur gauche. La direction 
perpendiculaire vers le haut correspond √† l'axe Z du composant. La direction de gauche √† 
droite est consid√©r√©e comme l'axe X. De m√™me, la direction de l'arri√®re vers l'avant est 
d√©finie comme l'axe Y.

.. image:: img/image223.png


**Acc√©l√©rom√®tre 3 axes**

L'acc√©l√©rom√®tre fonctionne sur le principe de l'effet pi√©zo√©lectrique, la capacit√© de 
certains mat√©riaux √† g√©n√©rer une charge √©lectrique en r√©ponse √† une contrainte m√©canique 
appliqu√©e.

Imaginez ici un cube avec une petite bille √† l'int√©rieur, comme illustr√© ci-dessus. Les 
parois de ce cube sont constitu√©es de cristaux pi√©zo√©lectriques. Chaque fois que vous 
inclinez le cube, la bille est forc√©e de se d√©placer dans la direction de l'inclinaison 
sous l'effet de la gravit√©. La paroi contre laquelle la bille heurte g√©n√®re de minuscules 
courants pi√©zo√©lectriques. Il y a trois paires de parois oppos√©es dans ce cube. Chaque 
paire correspond √† un axe dans l'espace 3D : les axes X, Y et Z. En fonction du courant 
produit par les parois pi√©zo√©lectriques, on peut d√©terminer la direction de l'inclinaison 
et son intensit√©.

.. image:: img/image224.png


Nous pouvons utiliser le MPU6050 pour d√©tecter son acc√©l√©ration sur chaque axe de 
coordonn√©es (√† l'√©tat stationnaire sur un bureau, l'acc√©l√©ration de l'axe Z est de 
1 unit√© de gravit√©, tandis que celle des axes X et Y est de 0). Si le composant est 
inclin√© ou soumis √† un √©tat de pesanteur ou de surpoids, la lecture correspondante changera.

Quatre plages de mesure peuvent √™tre s√©lectionn√©es par programmation : 
+/-2g, +/-4g, +/-8g et +/-16g (2g par d√©faut) correspondant √† chaque pr√©cision. 
Les valeurs varient de -32768 √† 32767.

La lecture de l'acc√©l√©rom√®tre est convertie en valeur d'acc√©l√©ration en mappant 
la lecture de la plage de lecture √† la plage de mesure.

Acc√©l√©ration = (Donn√©es brutes de l'acc√©l√©rom√®tre / 65536 \* plage d'acc√©l√©ration maximale) g

Prenons l'axe X par exemple, lorsque les donn√©es brutes de l'axe X de l'acc√©l√©rom√®tre 
sont 16384 et que la plage s√©lectionn√©e est de +/-2g :

**Acc√©l√©ration le long de l'axe X = (16384 / 65536 \* 4) g** **=1g**

**Gyroscope 3 axes**

Les gyroscopes fonctionnent selon le principe de l'acc√©l√©ration de Coriolis. Imaginez 
une structure en forme de fourche qui oscille constamment d'avant en arri√®re. Elle est 
maintenue en place gr√¢ce √† des cristaux pi√©zo√©lectriques. Chaque fois que vous essayez 
d'incliner cette structure, les cristaux subissent une force dans la direction de 
l'inclinaison, due √† l'inertie de la fourche en mouvement. Les cristaux produisent alors 
un courant en lien avec l'effet pi√©zo√©lectrique, et ce courant est amplifi√©.

.. image:: img/image225.png
    :width: 800
    :align: center

Le gyroscope dispose √©galement de quatre plages de mesure : +/- 250, +/- 500, +/- 1000, 
et +/- 2000. La m√©thode de calcul et l'acc√©l√©ration sont globalement similaires.

La formule pour convertir la lecture en vitesse angulaire est la suivante :

Vitesse angulaire = (Donn√©es brutes du gyroscope / 65536 \* plage maximale du gyroscope) ¬∞/s

Par exemple, pour l'axe X, si les donn√©es brutes de l'axe X du gyroscope sont 16384 
et que la plage est de +/- 250¬∞/s :

**Vitesse angulaire le long de l'axe X = (16384 / 65536 \* 500)¬∞/s** **=125¬∞/s**

Sch√©ma de c√¢blage
-----------------------

Le MPU6050 communique avec le microcontr√¥leur via l'interface du bus I2C. Les broches 
SDA1 et SCL1 doivent √™tre connect√©es aux broches correspondantes.

.. image:: img/image330.png
    :width: 600
    :align: center


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image227.png
    :width: 800



**√âtape 2 :** Configurez l'I2C (voir :ref:`i2c_config`. Si l'I2C est d√©j√† configur√©, passez cette √©tape.)


**√âtape 3 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.6/

**√âtape 4 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.6_mpu6050.c -lwiringPi -lm

**√âtape 5 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le code ex√©cut√©, l'angle de d√©viation des axes X et Y ainsi que 
l'acc√©l√©ration et la vitesse angulaire de chaque axe, mesur√©s par le MPU6050, 
seront affich√©s √† l'√©cran apr√®s calcul.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur indiquant : ¬´ wiringPi.h : Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include  <wiringPiI2C.h>
    #include <wiringPi.h>
    #include  <stdio.h>
    #include  <math.h>
    int fd;
    int acclX, acclY, acclZ;
    int gyroX, gyroY, gyroZ;
    double acclX_scaled, acclY_scaled, acclZ_scaled;
    double gyroX_scaled, gyroY_scaled, gyroZ_scaled;

    int read_word_2c(int addr)
    {
        int val;
        val = wiringPiI2CReadReg8(fd, addr);
        val = val << 8;
        val += wiringPiI2CReadReg8(fd, addr+1);
        if (val >= 0x8000)
            val = -(65536 - val);
        return val;
    }

    double dist(double a, double b)
    {
        return sqrt((a*a) + (b*b));
    }

    double get_y_rotation(double x, double y, double z)
    {
        double radians;
        radians = atan2(x, dist(y, z));
        return -(radians * (180.0 / M_PI));
    }

    double get_x_rotation(double x, double y, double z)
    {
        double radians;
        radians = atan2(y, dist(x, z));
        return (radians * (180.0 / M_PI));
    }

    int main()
    {
        fd = wiringPiI2CSetup (0x68);
        wiringPiI2CWriteReg8 (fd,0x6B,0x00); // d√©sactiver le mode veille 
    printf("set 0x6B=%X\n",wiringPiI2CReadReg8 (fd,0x6B));
    
        while(1) {

            gyroX = read_word_2c(0x43);
            gyroY = read_word_2c(0x45);
            gyroZ = read_word_2c(0x47);

            gyroX_scaled = gyroX / 131.0;
            gyroY_scaled = gyroY / 131.0;
            gyroZ_scaled = gyroZ / 131.0;

            // Afficher les valeurs pour les axes X, Y et Z du capteur gyroscopique.
        printf("My gyroX_scaled: %f\n", gyroY X_scaled);
        delay(100);
        printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
        delay(100);
        printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);
            delay(100);

            acclX = read_word_2c(0x3B);
            acclY = read_word_2c(0x3D);
            acclZ = read_word_2c(0x3F);

            acclX_scaled = acclX / 16384.0;
            acclY_scaled = acclY / 16384.0;
            acclZ_scaled = acclZ / 16384.0;

            // Afficher les valeurs X, Y et Z du capteur d'acc√©l√©ration.
        printf("My acclX_scaled: %f\n", acclX_scaled);
        delay(100);
        printf("My acclY_scaled: %f\n", acclY_scaled);
        delay(100);
        printf("My acclZ_scaled: %f\n", acclZ_scaled);
        delay(100);

        printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
        delay(100);
        printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
        delay(100);

            delay(100);
        }
        return 0;
    }

**Explication du Code**

.. code-block:: c

    int read_word_2c(int addr)
    {
    int val;
    val = wiringPiI2CReadReg8(fd, addr);
    val = val << 8;
    val += wiringPiI2CReadReg8(fd, addr+1);
    if (val >= 0x8000)
        val = -(65536 - val);
    return val;
    }

Lit les donn√©es du capteur envoy√©es par le MPU6050.

.. code-block:: c

    double get_y_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(x, dist(y, z));
    return -(radians * (180.0 / M_PI));
    }

Calcule l'angle de d√©viation sur l'axe Y.

.. code-block:: c

    double get_x_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(y, dist(x, z));
    return (radians * (180.0 / M_PI));
    }

Calcule l'angle de d√©viation sur l'axe X.

.. code-block:: c

    gyroX = read_word_2c(0x43);
    gyroY = read_word_2c(0x45);
    gyroZ = read_word_2c(0x47);

    gyroX_scaled = gyroX / 131.0;
    gyroY_scaled = gyroY / 131.0;
    gyroZ_scaled = gyroZ / 131.0;

    // Affiche les valeurs des axes X, Y et Z du capteur gyroscopique.
    printf("My gyroX_scaled: %f\n", gyroY X_scaled);
    printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
    printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);

Lit les valeurs des axes X, Y et Z du capteur gyroscopique, convertit les donn√©es brutes en valeurs de vitesse angulaire, puis les affiche.

.. code-block:: c

    acclX = read_word_2c(0x3B);
    acclY = read_word_2c(0x3D);
    acclZ = read_word_2c(0x3F);

    acclX_scaled = acclX / 16384.0;
    acclY_scaled = acclY / 16384.0;
    acclZ_scaled = acclZ / 16384.0;
        
    // Affiche les valeurs X, Y et Z du capteur d'acc√©l√©ration.
    printf("My acclX_scaled: %f\n", acclX_scaled);
    printf("My acclY_scaled: %f\n", acclY_scaled);
    printf("My acclZ_scaled: %f\n", acclZ_scaled);

Lit les valeurs des axes X, Y et Z du capteur d'acc√©l√©ration, convertit les donn√©es brutes en valeurs d'acc√©l√©ration (en unit√© de gravit√©), puis les affiche.

.. code-block:: c

    printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
    printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));

Affiche les angles de d√©viation des axes X et Y.

