.. note::

    Bonjour, bienvenue dans la communautÃ© des passionnÃ©s de SunFounder Raspberry Pi, Arduino & ESP32 sur Facebook ! Plongez dans lâ€™univers du Raspberry Pi, Arduino et ESP32 avec dâ€™autres passionnÃ©s.

    **Pourquoi nous rejoindre ?**

    - **Support dâ€™experts** : RÃ©solvez les problÃ¨mes techniques post-vente avec lâ€™aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre et partager** : Ã‰changez des conseils et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez Ã  des promotions spÃ©ciales et des concours lors des fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.14 JEU â€“ Not Not
======================

Introduction
-------------

Dans cette leÃ§on, nous allons crÃ©er un appareil de jeu amusant que nous appelons Â« Not Not Â».

Pendant le jeu, la matrice de points affiche alÃ©atoirement une flÃ¨che. Votre objectif est de presser le bouton dans la direction opposÃ©e de la flÃ¨che dans un temps limitÃ©. Si le temps est Ã©coulÃ© ou si vous appuyez sur le bouton correspondant Ã  la mÃªme direction que la flÃ¨che, vous perdez.

Ce jeu permet de pratiquer votre capacitÃ© de rÃ©flexion inversÃ©e. Voulez-vous essayer ?

Composants
-----------

.. image:: img/list_GAME_Not_Not.png
    :align: center

SchÃ©ma de montage
-----------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one14.png
   :align: center

ProcÃ©dures expÃ©rimentales
----------------------------

**Ã‰tape 1 :** Construisez le circuit.

.. image:: img/image280.png
   :width: 800

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.14/

**Ã‰tape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

**Ã‰tape 4 :** ExÃ©cutez le fichier compilÃ©.

.. raw:: html

   <run></run>

.. code-block::

     sudo ./a.out

Lorsque le programme dÃ©marre, une flÃ¨che vers la gauche ou la droite sera affichÃ©e 
alÃ©atoirement sur la matrice de points. Vous devez appuyer sur le bouton correspondant 
Ã  la direction opposÃ©e de la flÃ¨che dans un temps limitÃ©. Ensuite, un symbole Â« **âˆš** Â» 
apparaÃ®tra sur la matrice. Si le temps est Ã©coulÃ© ou si vous appuyez dans la mÃªme direction 
que la flÃ¨che, vous perdez et un Â« x Â» s'affichera sur la matrice. Vous pouvez Ã©galement 
ajouter deux nouveaux boutons ou les remplacer par un joystick pour contrÃ´ler quatre 
directions (haut, bas, gauche et droite) et augmenter la difficultÃ© du jeu.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur apparaÃ®t : "wiringPi.h: Aucun fichier ou rÃ©pertoire de ce type", veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.


**Explication du code**

BasÃ© sur **1.1.6 LED Dot Matrix**, cette leÃ§on ajoute **2** boutons pour crÃ©er un appareil 
de jeu amusant. Si vous n'Ãªtes pas encore familier avec la matrice de points, veuillez 
vous rÃ©fÃ©rer Ã  :ref:`1.1.6 LED Dot Matrix`.

Le dÃ©roulement complet du programme est le suivant :

1. SÃ©lectionnez alÃ©atoirement une direction de flÃ¨che et gÃ©nÃ©rez le **timer 1**.

2. Affichez lâ€™image de la flÃ¨che sur la matrice de points.

3. DÃ©tectez lâ€™entrÃ©e du bouton. Si le bouton est pressÃ© ou si le **timer 1** indique 
que le temps est Ã©coulÃ©, la phase de jugement commence.

4. Affichez lâ€™image en fonction du rÃ©sultat du jugement, puis gÃ©nÃ©rez le **timer 2**.

5. Revenez Ã  **l'Ã©tape 1** lorsque le **timer 2** indique que le temps est Ã©coulÃ©.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
    Â Â Â Â {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
    Â Â Â Â //Â {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
    Â Â Â Â //Â {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},Â Â Â Â 
    Â Â Â Â {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
    Â Â Â Â {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
    Â Â Â Â {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

La structure **GLYPH** fonctionne comme un dictionnaire : lâ€™attribut **word** 
correspond Ã  la clÃ© dans le dictionnaire et lâ€™attribut **code** correspond Ã  la valeur.

Ici, le code stocke un tableau pour que la matrice de points affiche des images 
(tableau 8x8 bits).

Le tableau **arrow** est utilisÃ© pour afficher le motif de flÃ¨che vers la gauche ou 
la droite sur la matrice LED.

Le tableau **check** est utilisÃ© pour afficher les deux symboles : Â« **Ã—** Â» et Â« **âˆš** Â».

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }Â Â Â Â 
    }


La fonction **lookup()** permet de Â« vÃ©rifier le dictionnaire Â». Elle prend une
 **clÃ©** en entrÃ©e, recherche les mots correspondants Ã  cette **clÃ©** dans la 
 structure **GLYPH \*glyph** et renvoie les informations associÃ©es, Ã  savoir le 
 Â« **code** Â» du mot en question.

La fonction **Strcmp()** est utilisÃ©e pour comparer deux chaÃ®nes de caractÃ¨res 
**glyph[i].word** et **key**. Si elles sont identiques, la fonction renvoie 
**glyph[i].code** (comme illustrÃ© ci-dessous).

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
    Â Â Â Â Â Â Â Â hc595_in(glyphCode[i]);
    Â Â Â Â Â Â Â Â hc595_in(0x80>>i);
    Â Â Â Â Â Â Â Â hc595_out();
    Â Â Â Â }
    }

Affiche le motif spÃ©cifiÃ© sur la matrice de points.

.. code-block:: c

    voidÂ createGlyph(){
    Â Â Â Â srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â waypoint=arrow[i].word;
    Â Â Â Â stage="PLAY";
    Â Â Â Â alarm(2);
    }

La fonction **createGlyph()** est utilisÃ©e pour sÃ©lectionner alÃ©atoirement une 
direction (lâ€™attribut **word** dâ€™un Ã©lÃ©ment du tableau **arrow[]** : Â« **left** Â», 
Â« **right** Â»... ). Elle dÃ©finit ensuite lâ€™Ã©tape Ã  Â« PLAY Â» et lance une fonction 
dâ€™alarme de 2 secondes.

**srand(time(NULL)) :** Initialise la graine de gÃ©nÃ©ration alÃ©atoire Ã  partir de 
lâ€™horloge du systÃ¨me.

**(sizeof(arrow)/sizeof(arrow[0])) :** Calcule la longueur du tableau, qui est de 2.

**rand()%2 :** Le reste de la division par 2 donne **0** ou **1**.

**waypoint=arrow[i].word :** Le rÃ©sultat sera Â« right Â» ou Â« left Â».

.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
    Â Â Â Â alarm(0)==0;
    Â Â Â Â if(inputKey==waypoint||inputKey=="empty")
    Â Â Â Â {
    Â Â Â Â Â Â Â Â waypoint="wrong";
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â waypoint="right";
    Â Â Â Â }
    Â Â Â Â stage="CHECK";
    Â Â Â Â alarm(1);
    }

La fonction **checkPoint()** est utilisÃ©e pour vÃ©rifier lâ€™entrÃ©e du boutonÂ ; 
si le bouton nâ€™est pas pressÃ© ou si le bouton correspondant Ã  la mÃªme direction 
que la flÃ¨che est pressÃ©, le rÃ©sultat est Â« faux Â» et Â« **x** Â» apparaÃ®t sur la 
matrice de points. Sinon, le rÃ©sultat est Â« vrai Â» et la matrice affiche Â« **âˆš** Â». 
Lâ€™Ã©tape devient alors Â« CHECK Â», et une alarme de 1 seconde est dÃ©finie.

La fonction **alarm()** est un Â« rÃ©veil Â» qui dÃ©clenche un signal **SIGALRM** 
lorsque le temps dÃ©fini est Ã©coulÃ©.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
    Â Â Â Â {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
    Â Â Â Â {checkPoint("left");}
    }

La fonction **getKey()** lit lâ€™Ã©tat de deux boutonsÂ : si le bouton droit est pressÃ©, 
le paramÃ¨tre de **checkPoint()** est **right** ; si le bouton gauche est pressÃ©, le 
paramÃ¨tre est **left**.

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
    Â Â Â Â Â Â Â Â checkPoint("empty");
    Â Â Â Â }
    Â Â Â Â elseÂ if(stage=="CHECK"){
    Â Â Â Â Â Â Â Â createGlyph();
    Â Â Â Â }
    }

La fonction **timer()** est appelÃ©e lorsque le **timer** (dÃ©fini par **alarm()**) est 
Ã©coulÃ©. Sous le mode Â« PLAY Â», **checkPoint()** est appelÃ© pour juger le rÃ©sultat. Si 
le mode est dÃ©fini sur Â« CHECK Â», **createGlyph()** est appelÃ© pour sÃ©lectionner de 
nouveaux motifs.

.. code-block:: c

    voidÂ main(){
    Â Â Â Â setup();
    Â Â Â Â signal(SIGALRM,timer);
    Â Â Â Â createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â Â Â Â Â getKey();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
    Â Â Â Â Â Â Â Â {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
    Â Â Â Â Â Â Â Â Â Â Â Â display(code);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    }

Le fonctionnement de la fonction **signal(SIGALRM,timer)** : elle appelle la 
fonction **timer()** lorsquâ€™un signal **SIGALRM** (gÃ©nÃ©rÃ© par la fonction alarme 
**alarm()**) est reÃ§u.

Lorsque le programme dÃ©marre, il appelle dâ€™abord **createGlyph()** une fois, 
puis entre dans la boucle.

Dans la boucle : en mode Â« PLAY Â», la matrice de points affiche les motifs de 
flÃ¨che et vÃ©rifie lâ€™Ã©tat du boutonÂ ; en mode Â« CHECK Â», elle affiche Â« **x** Â» ou Â« **âˆš** Â».

