.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes post-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux avant-go√ªts.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des concours et promotions de f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.1.6 LED Dot Matrix
==========================

Introduction
----------------------

Comme son nom l'indique, une matrice √† points LED est un ensemble de LED organis√©es 
en matrice. L'allumage et l'extinction des LED permettent de former diff√©rents caract√®res 
et motifs.

Composants
------------------

.. image:: img/list_dot.png

Principe
-------------------

**Matrice √† points LED**

En g√©n√©ral, une matrice √† points LED peut √™tre class√©e en deux types : cathode commune 
(CC) et anode commune (CA). Elles se ressemblent beaucoup, mais diff√®rent √† l'int√©rieur. 
Vous pouvez les distinguer en les testant. Une matrice CA est utilis√©e dans ce kit, vous 
verrez l'√©tiquette 788BS sur le c√¥t√©.

Voyez l'image ci-dessous. Les broches sont dispos√©es aux deux extr√©mit√©s √† l'arri√®re. 
Prenez le c√¥t√© de l'√©tiquette comme r√©f√©rence : les broches de cette extr√©mit√© sont 
num√©rot√©es de 1 √† 8, et celles de l'autre extr√©mit√© de 9 √† 16.

Vue externe :

.. image:: img/image84.png

Les figures ci-dessous montrent leur structure interne. Vous pouvez voir que dans une 
matrice √† points LED CA, les lignes (ROW) repr√©sentent l'anode des LED, et les colonnes 
(COL) la cathode ; pour une matrice CC, c'est l'inverse. Une chose en commun : pour les 
deux types, les broches 13, 3, 4, 10, 6, 11, 15 et 16 sont toutes reli√©es aux colonnes 
(COL), tandis que les broches 9, 14, 8, 12, 1, 7, 2 et 5 sont reli√©es aux lignes (ROW). 
Si vous voulez allumer la premi√®re LED dans le coin sup√©rieur gauche, pour une matrice CA, 
il suffit de r√©gler la broche 9 sur High et la broche 13 sur Low, et pour une matrice CC, 
il faut r√©gler la broche 13 sur High et la broche 9 sur Low. Si vous souhaitez allumer 
toute la premi√®re colonne, pour la matrice CA, r√©glez la broche 13 sur Low et les broches 
des lignes (ROW) 9, 14, 8, 12, 1, 7, 2 et 5 sur High, tandis que pour la matrice CC, 
r√©glez la broche 13 sur High et les lignes sur Low. R√©f√©rez-vous aux figures suivantes 
pour une meilleure compr√©hension.

Vue interne :

.. image:: img/image85.png
   :width: 400
   :align: center

Num√©rotation des broches correspondant aux lignes et colonnes ci-dessus :

=========== ====== ====== ===== ====== ===== ====== ====== ======
**COL**     **1**  **2**  **3** **4**  **5** **6**  **7**  **8**
**Pin No.** **13** **3**  **4** **10** **6** **11** **15** **16**
**ROW**     **1**  **2**  **3** **4**  **5** **6**  **7**  **8**
**Pin No.** **9**  **14** **8** **12** **1** **7**  **2**  **5**
=========== ====== ====== ===== ====== ===== ====== ====== ======

De plus, deux puces 74HC595 sont utilis√©es ici. L'une sert √† contr√¥ler les lignes de la matrice √† points LED, tandis que l'autre contr√¥le les colonnes.

Sch√©ma de c√¢blage
-----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: img/schematic_dot.png
   :width: 800

Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit. Comme le c√¢blage est complexe, proc√©dons 
√©tape par √©tape. Ins√©rez d'abord le T-Cobbler, la matrice √† points LED et les 
deux puces 74HC595 dans la plaque de prototypage. Connectez le 3,3 V et la masse 
(GND) du T-Cobbler aux trous sur les deux c√¥t√©s de la plaque, puis reliez les broches 
16 et 10 des deux puces 74HC595 √† VCC, les broches 13 et 8 √† GND.

.. note::
   Dans l'image Fritzing ci-dessus, le c√¥t√© avec l'√©tiquette est en bas.

.. image:: img/image87.png
   :width: 800

**√âtape 2 :** Reliez la broche 11 des deux puces 74HC595 ensemble, puis √† GPIO27 ; 
ensuite, la broche 12 des deux puces, √† GPIO18 ; enfin, la broche 14 de la puce 74HC595 
de gauche √† GPIO17 et la broche 9 √† la broche 14 de la seconde puce 74HC595.

.. image:: img/image88.png
   :width: 800

**√âtape 3 :** La puce 74HC595 de droite contr√¥le les colonnes de la matrice √† points 
LED. Consultez le tableau ci-dessous pour la correspondance. Ainsi, les broches Q0-Q7 
de la puce 74HC595 sont reli√©es aux broches 13, 3, 4, 10, 6, 11, 15 et 16 respectivement.

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **13** | **3**  | **4**  | **10** | **6**  | **11** | **15** | **16** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

.. image:: img/image89.png
   :width: 800

**√âtape 4 :** Connectez maintenant les lignes (ROW) de la matrice √† points LED. 
La puce 74HC595 de gauche contr√¥le les lignes de la matrice √† points LED. Le 
tableau ci-dessous montre la correspondance. On peut voir que les broches Q0-Q7 
de la puce 74HC595 de gauche sont reli√©es aux broches 9, 14, 8, 12, 1, 7, 2 et 5 
respectivement.

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **9**  | **14** | **8**  | **12** | **1**  | **7**  | **2**  | **5**  |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

.. image:: img/image90.png
   :width: 800

Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 5 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

   cd ~/davinci-kit-for-raspberry-pi/c/1.1.6/

**√âtape 6 :** Compilez.

.. raw:: html

   <run></run>

.. code-block::

   gcc 1.1.6_LedMatrix.c -lwiringPi

**√âtape 7 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

   sudo ./a.out

Apr√®s avoir ex√©cut√© le code, la matrice de LED s'allume et s'√©teint ligne par ligne et colonne par colonne.

.. note::

   Si cela ne fonctionne pas apr√®s l'ex√©cution, ou si une erreur du type \"wiringPi.h: No such file or directory\" est affich√©e, veuillez consulter :ref:`C code is not working?`.

**Code**

.. code-block:: c

   #include <wiringPi.h>
   #include <stdio.h>

   #define   SDI   0   //entr√©e des donn√©es s√©rie
   #define   RCLK  1   //entr√©e de l'horloge m√©moire (STCP)
   #define   SRCLK 2   //entr√©e de l'horloge du registre de d√©calage (SHCP)

   unsigned char code_H[20] = {0x01,0xff,0x80,0xff,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
   unsigned char code_L[20] = {0x00,0x7f,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};

   void init(void){
      pinMode(SDI, OUTPUT); 
      pinMode(RCLK, OUTPUT);
      pinMode(SRCLK, OUTPUT);

      digitalWrite(SDI, 0);
      digitalWrite(RCLK, 0);
      digitalWrite(SRCLK, 0);
   }

   void hc595_in(unsigned char dat){
      int i;
      for(i=0;i<8;i++){
         digitalWrite(SDI, 0x80 & (dat << i));
         digitalWrite(SRCLK, 1);
         delay(1);
         digitalWrite(SRCLK, 0);
      }
   }

   void hc595_out(){
      digitalWrite(RCLK, 1);
      delay(1);
      digitalWrite(RCLK, 0);
   }

   int main(void){
      int i;
      if(wiringPiSetup() == -1){ //si l'initialisation de wiring √©choue, afficher un message √† l'√©cran
         printf("setup wiringPi failed !");
         return 1;
      }
      init();
      while(1){
         for(i=0;i<sizeof(code_H);i++){
               hc595_in(code_L[i]);
               hc595_in(code_H[i]);
               hc595_out();
               delay(100);
         }

         for(i=sizeof(code_H);i>=0;i--){
               hc595_in(code_L[i]);
               hc595_in(code_H[i]);
               hc595_out();
               delay(100);
         }
      }

      return 0;
   }

**Explication du code**

.. code-block:: c

   unsigned char code_H[20] = {0x01,0xff,0x80,0xff,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
   unsigned char code_L[20] = {0x00,0x7f,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};

Le tableau code_H repr√©sente les √©l√©ments des lignes de la matrice de LED, et le tableau code_L repr√©sente les √©l√©ments des colonnes. Lors de l'affichage des caract√®res, un √©l√©ment de ligne et un √©l√©ment de colonne sont r√©cup√©r√©s et attribu√©s aux deux puces HC595 respectivement. Ainsi, un motif s'affiche sur la matrice de LED.
Prenons comme exemple le premier √©l√©ment de code_H, 0x01, et le premier √©l√©ment de code_L, 0x00.

0x01 converti en binaire donne 00000001 ; 0x00 converti en binaire donne 0000 0000.

Dans ce kit, une matrice de LED √† anode commune est utilis√©e, donc seules les huit LEDs de la huiti√®me ligne s'allument.
Lorsque les conditions o√π code_H est 0xff et code_L est 0x7f sont remplies simultan√©ment, ces 8 LEDs dans la premi√®re colonne s'allument.

.. image:: img/anode_table.png

.. code-block:: c

   void hc595_in(unsigned char dat){
      int i;
      for(i=0;i<8;i++){
         digitalWrite(SDI, 0x80 & (dat << i));
         digitalWrite(SRCLK, 1);
         delay(1);
         digitalWrite(SRCLK, 0);

Cette fonction √©crit la valeur de dat dans la broche SDI du HC595, bit par bit. La valeur initiale de SRCLK est fix√©e √† 0, puis elle passe √† 1 pour g√©n√©rer une impulsion de front montant, permettant ainsi de transf√©rer les donn√©es de SDI(DS) au registre √† d√©calage.

.. code-block:: c

   void hc595_out(){
      digitalWrite(RCLK, 1);
      delay(1);
      digitalWrite(RCLK, 0);

La valeur initiale de RCLK est fix√©e √† 0, puis elle passe √† 1 pour g√©n√©rer un front montant, permettant ainsi de transf√©rer les donn√©es du registre √† d√©calage au registre de stockage.

.. code-block:: c

   while(1){
      for(i=0;i<sizeof(code_H);i++){
         hc595_in(code_L[i]);
         hc595_in(code_H[i]);
         hc595_out();
         delay(100);
      }
   }

Dans cette boucle, les 20 √©l√©ments des deux tableaux, code_L et code_H, sont charg√©s un par un dans les deux puces 74HC595. Ensuite, la fonction hc595_out() est appel√©e pour transf√©rer les donn√©es du registre √† d√©calage au registre de stockage.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 5 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

   cd ~/davinci-kit-for-raspberry-pi/python

**√âtape 6 :** Ex√©cutez le code.

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 1.1.6_LedMatrix.py

Apr√®s l'ex√©cution du code, la matrice de LED s'allume et s'√©teint ligne par ligne et colonne par colonne.

**Code**

.. note::

   Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre au chemin source du code comme ``davinci-kit-for-raspberry-pi/python``.
   
.. raw:: html

    <run></run>

.. code-block:: python

   import RPi.GPIO as GPIO
   import time

   SDI   = 17
   RCLK  = 18
   SRCLK = 27

   # Nous utilisons une matrice BX, ROW pour l'anode et COL pour la cathode
   # ROW  ++++
   code_H = [0x01,0xff,0x80,0xff,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff]
   # COL  ----
   code_L = [0x00,0x7f,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f]

   def setup():
      GPIO.setmode(GPIO.BCM)    # Num√©rotation des GPIO par leur position BCM
      GPIO.setup(SDI, GPIO.OUT)
      GPIO.setup(RCLK, GPIO.OUT)
      GPIO.setup(SRCLK, GPIO.OUT)
      GPIO.output(SDI, GPIO.LOW)
      GPIO.output(RCLK, GPIO.LOW)
      GPIO.output(SRCLK, GPIO.LOW)

   # Transf√®re les donn√©es vers le 74HC595
   def hc595_shift(dat):
      for bit in range(0, 8): 
         GPIO.output(SDI, 0x80 & (dat << bit))
         GPIO.output(SRCLK, GPIO.HIGH)
         time.sleep(0.001)
         GPIO.output(SRCLK, GPIO.LOW)
      GPIO.output(RCLK, GPIO.HIGH)
      time.sleep(0.001)
      GPIO.output(RCLK, GPIO.LOW)

   def main():
      while True:
         for i in range(0, len(code_H)):
               hc595_shift(code_L[i])
               hc595_shift(code_H[i])
               time.sleep(0.1)

         for i in range(len(code_H)-1, -1, -1):
               hc595_shift(code_L[i])
               hc595_shift(code_H[i])
               time.sleep(0.1)

   def destroy():
      GPIO.cleanup()

   if __name__ == '__main__':
      setup()
      try:
         main()
      except KeyboardInterrupt:
         destroy()

**Explication du code**

.. code-block:: python

   code_H = [0x01,0xff,0x80,0xff,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff]
   code_L = [0x00,0x7f,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f]

Le tableau code_H repr√©sente les √©l√©ments des lignes de la matrice, et le tableau code_L ceux des colonnes. Lorsqu'un caract√®re est affich√©, un √©l√©ment de ligne et un √©l√©ment de colonne sont r√©cup√©r√©s et attribu√©s respectivement aux deux puces HC595, ce qui permet d'afficher un motif sur la matrice de LED.
Prenons l'exemple du premier nombre de code_H, 0x01, et du premier nombre de code_L, 0x00.

0x01 converti en binaire devient 00000001 ; 0x00 converti en binaire devient 0000 0000.

Dans ce kit, une matrice de LED √† anode commune est utilis√©e, donc seules les huit LEDs de la huiti√®me ligne s'allument.
Lorsque code_H vaut 0xff et code_L vaut 0x7f, les 8 LEDs de la premi√®re colonne s'allument.

.. image:: img/anode_table.png

.. code-block:: python

   for i in range(0, len(code_H)):
      hc595_shift(code_L[i])
      hc595_shift(code_H[i])

Dans cette boucle, les 20 √©l√©ments des deux tableaux, code_L et code_H, sont envoy√©s un par un √† la puce HC595.

.. note::
   Si vous souhaitez afficher des caract√®res sur la matrice de LED, veuillez vous r√©f√©rer au code Python disponible ici : https://github.com/sunfounder/SunFounder_Dot_Matrix.

Image du r√©sultat
-----------------------

.. image:: img/image91.jpeg

