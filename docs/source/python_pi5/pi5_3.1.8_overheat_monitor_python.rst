.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des conseils et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux annonces de nouveaux produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales pour les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _3.1.8_py_pi5_monitor:

3.1.8 Moniteur de surchauffe
================================

Introduction
-------------------

Vous souhaitez peut-√™tre concevoir un dispositif de surveillance de la surchauffe 
applicable dans diverses situations, par exemple, dans une usine, pour d√©clencher 
une alarme et l'arr√™t automatique d'une machine en cas de surchauffe de circuit. 
Dans ce projet, nous utiliserons une thermistance, un joystick, un buzzer, une LED 
et un √©cran LCD pour fabriquer un appareil de surveillance de la temp√©rature intelligent 
dont le seuil est r√©glable.

Composants n√©cessaires
------------------------------

Pour ce projet, nous aurons besoin des composants suivants :

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_list.png
    :width: 800
    :align: center

.. Un kit complet est disponible ici :

.. .. list-table::
..     :widths: 20 20 20
..     :header-rows: 1

..     *   - Nom
..         - √âL√âMENTS DANS CE KIT
..         - LIEN
..     *   - Kit Raphael
..         - 337
..         - |link_Raphael_kit|

.. Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. .. list-table::
..     :widths: 30 20
..     :header-rows: 1

..     *   - INTRODUCTION DES COMPOSANTS
..         - LIEN D'ACHAT

..     *   - :ref:`gpio_extension_board`
..         - |link_gpio_board_buy|
..     *   - :ref:`breadboard`
..         - |link_breadboard_buy|
..     *   - :ref:`wires`
..         - |link_wires_buy|
..     *   - :ref:`resistor`
..         - |link_resistor_buy|
..     *   - :ref:`led`
..         - |link_led_buy|
..     *   - :ref:`joystick`
..         - \-
..     *   - :ref:`adc0834`
..         - \-
..     *   - :ref:`transistor`
..         - |link_transistor_buy|
..     *   - :ref:`i2c_lcd1602`
..         - |link_i2clcd1602_buy|
..     *   - :ref:`thermistor`
..         - |link_thermistor_buy|
..     *   - :ref:`buzzer`
..         - \-

Sch√©ma de c√¢blage
--------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_schematic.png
   :align: center

Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/4.1.13_overheat_monitor_circuit.png

**√âtape 2 :** Acc√©dez au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.8_OverheatMonitor.py

Lorsque le programme est ex√©cut√©, la temp√©rature actuelle et le seuil de haute 
temp√©rature **40** sont affich√©s sur **I2C LCD1602**. Si la temp√©rature actuelle 
d√©passe le seuil, le buzzer et la LED se d√©clenchent pour vous avertir.

**Le Joystick** vous permet de r√©gler le seuil de haute temp√©rature. En d√©pla√ßant 
le joystick le long des axes X et Y, vous pouvez augmenter ou diminuer le seuil actuel. 
Appuyez √† nouveau sur le joystick pour r√©initialiser le seuil √† sa valeur initiale.

.. note::

    * Si vous rencontrez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez consulter :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez ex√©cuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` appara√Æt, cela signifie que le module est mal c√¢bl√© ou qu'il est d√©fectueux.
    * Si le code et le c√¢blage sont corrects mais que l'√©cran LCD n'affiche toujours rien, vous pouvez ajuster le potentiom√®tre √† l'arri√®re pour augmenter le contraste.

.. warning::

    Si une erreur du type ``RuntimeError: Cannot determine SOC peripheral base address`` appara√Æt, veuillez vous r√©f√©rer √† :ref:`faq_soc`.

**Code**

.. note::
    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source, par exemple ``davinci-kit-for-raspberry-pi/python``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import LCD1602
   from gpiozero import LED, Buzzer, Button
   import ADC0834
   import time
   import math

   # Initialisation du bouton du joystick, du buzzer et de la LED
   Joy_BtnPin = Button(22)
   buzzPin = Buzzer(23)
   ledPin = LED(24)

   # D√©finir le seuil initial de temp√©rature sup√©rieure
   upperTem = 40

   # Configuration des modules ADC et LCD
   ADC0834.setup()
   LCD1602.init(0x27, 1)

   def get_joystick_value():
       """
       Reads the joystick values and returns a change value based on the joystick's position.
       """
       x_val = ADC0834.getResult(1)
       y_val = ADC0834.getResult(2)
       if x_val > 200:
           return 1
       elif x_val < 50:
           return -1
       elif y_val > 200:
           return -10
       elif y_val < 50:
           return 10
       else:
           return 0

   def upper_tem_setting():
       """
       Adjusts and displays the upper temperature threshold on the LCD.
       """
       global upperTem
       LCD1602.write(0, 0, 'Upper Adjust: ')
       change = int(get_joystick_value())
       upperTem += change
       strUpperTem = str(upperTem)
       LCD1602.write(0, 1, strUpperTem)
       LCD1602.write(len(strUpperTem), 1, '              ')
       time.sleep(0.1)

   def temperature():
       """
       Reads the current temperature from the sensor and returns it in Celsius.
       """
       analogVal = ADC0834.getResult()
       Vr = 5 * float(analogVal) / 255
       Rt = 10000 * Vr / (5 - Vr)
       temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
       Cel = temp - 273.15
       return round(Cel, 2)

   def monitoring_temp():
       """
       Monitors and displays the current temperature and upper temperature threshold. 
       Activates buzzer and LED if the temperature exceeds the upper limit.
       """
       global upperTem
       Cel = temperature()
       LCD1602.write(0, 0, 'Temp: ')
       LCD1602.write(0, 1, 'Upper: ')
       LCD1602.write(6, 0, str(Cel))
       LCD1602.write(7, 1, str(upperTem))
       time.sleep(0.1)
       if Cel >= upperTem:
           buzzPin.on()
           ledPin.on()
       else:
           buzzPin.off()
           ledPin.off()

   # Boucle d'ex√©cution principale
   try:
       lastState = 1
       stage = 0
       while True:
           currentState = Joy_BtnPin.value
           # Basculer entre le mode de r√©glage et le mode de surveillance
           if currentState == 1 and lastState == 0:
               stage = (stage + 1) % 2
               time.sleep(0.1)
               LCD1602.clear()
           lastState = currentState
           if stage == 1:
               upper_tem_setting()
           else:
               monitoring_temp()
   except KeyboardInterrupt:
       # Nettoyage et sortie
       LCD1602.clear()
       ADC0834.destroy()


**Explication du Code**

#. Cette section importe les biblioth√®ques n√©cessaires pour le projet. ``LCD1602`` est utilis√© pour l'affichage LCD, ``gpiozero`` fournit des classes pour contr√¥ler les LED, le Buzzer et le Bouton, ``ADC0834`` est utilis√© pour la conversion analogique-num√©rique, et ``time`` et ``math`` sont des biblioth√®ques standard de Python pour les fonctions temporelles et les calculs math√©matiques respectivement.

   .. code-block:: python

       #!/usr/bin/env python3

       import LCD1602
       from gpiozero import LED, Buzzer, Button
       import ADC0834
       import time
       import math

#. Ici, le bouton du joystick, le buzzer et la LED sont initialis√©s. ``Button(22)`` cr√©e un objet bouton connect√© √† la broche GPIO 22. ``Buzzer(23)`` et ``LED(24)`` initialisent respectivement le buzzer et la LED sur les broches GPIO 23 et 24.

   .. code-block:: python

       # Initialisation du bouton du joystick, du buzzer et de la LED
       Joy_BtnPin = Button(22)
       buzzPin = Buzzer(23)
       ledPin = LED(24)

#. D√©finit la limite de temp√©rature sup√©rieure initiale et initialise les modules ADC et LCD. L'√©cran LCD est initialis√© avec une adresse (``0x27``) et un mode (``1``).

   .. code-block:: python

       # D√©finir le seuil initial de temp√©rature sup√©rieure
       upperTem = 40

       # Configuration des modules ADC et LCD
       ADC0834.setup()
       LCD1602.init(0x27, 1)

#. Cette fonction lit les valeurs X et Y du joystick en utilisant l'ADC0834. Elle renvoie une valeur de changement bas√©e sur la position du joystick, qui sera utilis√©e pour ajuster le seuil de temp√©rature.

   .. code-block:: python

       def get_joystick_value():
           """
           Reads the joystick values and returns a change value based on the joystick's position.
           """
           x_val = ADC0834.getResult(1)
           y_val = ADC0834.getResult(2)
           if x_val > 200:
               return 1
           elif x_val < 50:
               return -1
           elif y_val > 200:
               return -10
           elif y_val < 50:
               return 10
           else:
               return 0

#. Ajuste la limite de temp√©rature sup√©rieure en utilisant l'entr√©e du joystick. La nouvelle limite est affich√©e sur l'√©cran LCD.

   .. code-block:: python

       def upper_tem_setting():
           """
           Adjusts and displays the upper temperature threshold on the LCD.
           """
           global upperTem
           LCD1602.write(0, 0, 'Upper Adjust: ')
           change = int(get_joystick_value())
           upperTem += change
           strUpperTem = str(upperTem)
           LCD1602.write(0, 1, strUpperTem)
           LCD1602.write(len(strUpperTem), 1, '              ')
           time.sleep(0.1)

#. Lit la temp√©rature actuelle du capteur √† l'aide de l'ADC0834 et la convertit en Celsius.

   .. code-block:: python

       def temperature():
           """
           Reads the current temperature from the sensor and returns it in Celsius.
           """
           analogVal = ADC0834.getResult()
           Vr = 5 * float(analogVal) / 255
           Rt = 10000 * Vr / (5 - Vr)
           temp = 1 / (((math.log(Rt / 10000)) / 3950) + (1 / (273.15 + 25)))
           Cel = temp - 273.15
           return round(Cel, 2)

#. Surveille et affiche la temp√©rature actuelle et la limite sup√©rieure. Si la temp√©rature d√©passe la limite sup√©rieure, le buzzer et la LED sont activ√©s.

   .. code-block:: python

       def monitoring_temp():
           """
           Monitors and displays the current temperature and upper temperature threshold. 
           Activates buzzer and LED if the temperature exceeds the upper limit.
           """
           global upperTem
           Cel = temperature()
           LCD1602.write(0, 0, 'Temp: ')
           LCD1602.write(0, 1, 'Upper: ')
           LCD1602.write(6, 0, str(Cel))
           LCD1602.write(7, 1, str(upperTem))
           time.sleep(0.1)
           if Cel >= upperTem:
               buzzPin.on()
               ledPin.on()
           else:
               buzzPin.off()
               ledPin.off()

#. La boucle principale alterne entre les modes de r√©glage et de surveillance en fonction des pressions sur le bouton du joystick. Elle met continuellement √† jour soit le r√©glage de la temp√©rature, soit la surveillance de la temp√©rature actuelle.

   .. code-block:: python

       # Boucle d'ex√©cution principale
       try:
           lastState = 1
           stage = 0
           while True:
               currentState = Joy_BtnPin.value
               # Basculer entre le mode de r√©glage et le mode de surveillance
               if currentState == 1 and lastState == 0:
                   stage = (stage + 1) % 2
                   time.sleep(0.1)
                   LCD1602.clear()
               lastState = currentState
               if stage == 1:
                   upper_tem_setting()
               else:
                   monitoring_temp()

#. Cette section garantit un nettoyage correct et la lib√©ration des ressources lorsque le programme est interrompu.

   .. code-block:: python

       except KeyboardInterrupt:
           # Clean up and exit
           LCD1602.clear()
           ADC0834.destroy()