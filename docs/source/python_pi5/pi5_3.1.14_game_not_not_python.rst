.. note::

    Bonjour et bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes post-achat et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts.
    - **R√©ductions sp√©ciales** : Profitez de remises exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† nos tirages au sort et √† nos promotions de saison.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _3.1.14_py_pi5:

3.1.14 JEU ‚Äì Not Not
========================

Introduction
---------------

Dans cette le√ßon, nous allons cr√©er un dispositif de jeu amusant, que nous appelons ¬´ Not Not ¬ª.

Pendant le jeu, la matrice de points affichera al√©atoirement une fl√®che. Votre objectif est d'appuyer sur le bouton oppos√© √† la direction de la fl√®che dans un temps limit√©. Si le temps est √©coul√©, ou si vous appuyez sur le bouton correspondant √† la m√™me direction que la fl√®che, vous perdez.

Ce jeu est id√©al pour entra√Æner votre pens√©e invers√©e. Alors, on essaie ?

Composants n√©cessaires
--------------------------

Pour ce projet, nous aurons besoin des composants suivants :

.. image:: ../python_pi5/img/3.1.14_game_not_not_list.png
    :width: 800
    :align: center

Sch√©ma de c√¢blage
--------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../python_pi5/img/3.1.14_game_not_not_schematic.png
   :align: center

Proc√©dures exp√©rimentales
-----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../python_pi5/img/3.1.14_game_not_not_circuit.png

**√âtape 2 :** Ouvrez le fichier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3 :** Ex√©cutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.14_MotionControl.py

Apr√®s le d√©marrage du programme, une fl√®che pointant vers la gauche ou la droite 
appara√Æt sur la matrice de points. Vous devez appuyer sur le bouton dans la direction 
oppos√©e √† la fl√®che dans un temps limit√©. Ensuite, le symbole \"**‚àö**\" s'affichera sur 
la matrice de points. Si le temps est √©coul√© ou si vous appuyez sur le bouton correspondant 
√† la m√™me direction que la fl√®che, vous √™tes √©limin√© et la matrice affichera \"x\". Vous 
pouvez √©galement ajouter deux nouveaux boutons ou les remplacer par des touches de joystick 
pour les directions haut, bas, gauche et droite afin d'augmenter la difficult√© du jeu.

.. warning::

    Si vous recevez le message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez vous r√©f√©rer √† :ref:`faq_soc`

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin source, tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir le r√©sultat.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice, Button
   import time
   import threading
   import random

   # Broches GPIO pour le registre √† d√©calage 74HC595
   SDI = OutputDevice(17)   # Entr√©e de donn√©es s√©rie
   RCLK = OutputDevice(18)  # Horloge du registre
   SRCLK = OutputDevice(27) # Horloge du registre √† d√©calage

   # Broches GPIO pour les boutons
   AButtonPin = Button(20)  # Bouton A
   BButtonPin = Button(26)  # Bouton B

   # Initialisation des variables de jeu
   timerPlay = 0
   timerCheck = 0
   waypoint = "NULL"
   stage = "NULL"

   # Glyphes des fl√®ches pour l'affichage sur la matrice LED
   arrow = {
       "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
       "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
   }

   # Glyphes de retour pour les r√©ponses correctes/incorrectes
   check = {
       "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
       "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
   }

   def hc595_shift(dat):
       """ Shift data to the 74HC595 shift register. """
       for i in range(8):
           SDI.value = 0x80 & (dat << i)
           SRCLK.on()
           SRCLK.off()

   def display(glyphCode):
       """ Display a glyph on the LED matrix. """
       for i in range(0, 8):
           hc595_shift(glyphCode[i])
           hc595_shift(0x80 >> i)
           RCLK.on()
           RCLK.off()

   def creatGlyph():
       """ Create a new glyph for the game and start the play timer. """
       global waypoint, stage, timerPlay
       waypoint = random.choice(list(arrow.keys()))
       stage = "PLAY"
       timerPlay = threading.Timer(2.0, timeOut)
       timerPlay.start()

   def checkPoint(inputKey):
       """ Check player's input and update game state. """
       global waypoint, stage, timerCheck
       if inputKey == "empty" or inputKey == waypoint:
           waypoint = "wrong"
       else:
           waypoint = "right"
       timerPlay.cancel()
       stage = "CHECK"
       timerCheck = threading.Timer(1.0, creatGlyph)
       timerCheck.start()

   def timeOut():
       """ Handle game timeout scenario. """
       checkPoint("empty")

   def getKey():
       """ Detect button press and trigger checkpoint. """
       if AButtonPin.is_pressed and not BButtonPin.is_pressed:
           checkPoint("right")
       elif not AButtonPin.is_pressed and BButtonPin.is_pressed:
           checkPoint("left")

   def main():
       """ Main game loop. """
       creatGlyph()
       while True:
           if stage == "PLAY":
               display(arrow[waypoint])
               getKey()
           elif stage == "CHECK":
               display(check[waypoint])

   def destroy():
       """ Clean up resources on program exit. """
       global timerPlay, timerCheck
       timerPlay.cancel()  # Annule le minuteur de jeu
       timerCheck.cancel()  # Annule le minuteur de v√©rification

   # Ex√©cute le jeu et g√®re l'interruption clavier pour une sortie propre
   try:
       main()
   except KeyboardInterrupt:
       destroy()

**Explication du Code**

Bas√© sur la le√ßon **1.1.6 Matrice LED**, cette activit√© ajoute **2** boutons pour cr√©er un dispositif de jeu amusant. Si vous n'√™tes pas encore tr√®s familier avec la matrice LED, veuillez vous r√©f√©rer √† :ref:`1.1.6_py_pi5`.

#. Le code commence par importer les biblioth√®ques n√©cessaires. ``gpiozero`` est utilis√© pour interagir avec les broches GPIO, comme les boutons et les dispositifs de sortie. ``time`` permet d'ajouter des d√©lais, ``threading`` permet d'ex√©cuter plusieurs t√¢ches simultan√©ment, et ``random`` est utile pour introduire de l'al√©atoire dans le projet.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice, Button
       import time
       import threading
       import random

#. Initialisation des broches GPIO pour le registre √† d√©calage (``SDI``, ``RCLK``, ``SRCLK``) et pour les boutons (``AButtonPin``, ``BButtonPin``). Le registre √† d√©calage permet de contr√¥ler plusieurs LED avec moins de broches GPIO, ce qui est essentiel pour l'affichage sur la matrice LED.

   .. code-block:: python

       # Broches GPIO pour le registre √† d√©calage 74HC595
       SDI = OutputDevice(17)   # Entr√©e de donn√©es s√©rie
       RCLK = OutputDevice(18)  # Horloge du registre
       SRCLK = OutputDevice(27) # Horloge du registre √† d√©calage

       # Broches GPIO pour les boutons
       AButtonPin = Button(20)  # Bouton A
       BButtonPin = Button(26)  # Bouton B

#. Initialisation des variables utilis√©es dans la logique du jeu, telles que les minuteurs et les indicateurs d'√©tat du jeu.

   .. code-block:: python

       # Initialisation des variables de jeu
       timerPlay = 0
       timerCheck = 0
       waypoint = "NULL"
       stage = "NULL"

#. D√©finit les motifs binaires pour afficher les fl√®ches et les retours (correct/incorrect) sur la matrice LED. Chaque √©l√©ment du tableau repr√©sente une ligne de la matrice LED, o√π ``1`` et ``0`` correspondent respectivement √† une LED allum√©e ou √©teinte.

   .. code-block:: python

       # Glyphes de fl√®ches pour l'affichage sur la matrice LED
       arrow = {
           "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
           "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
       }

       # Glyphes de retour pour les r√©ponses correctes/incorrectes
       check = {
           "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
           "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
       }

#. Cette fonction transf√®re un octet de donn√©es vers le registre √† d√©calage 74HC595. Elle parcourt chaque bit de l'octet ``dat``, r√®gle la broche ``SDI`` sur haut ou bas en cons√©quence, et bascule la broche ``SRCLK`` pour d√©placer le bit dans le registre.

   .. code-block:: python

       def hc595_shift(dat):
           """ Shift data to the 74HC595 shift register. """
           for i in range(8):
               SDI.value = 0x80 & (dat << i)
               SRCLK.on()
               SRCLK.off()

#. Cette fonction affiche un glyphe sur la matrice LED. Elle envoie chaque ligne du glyphe (repr√©sent√©e par ``glyphCode``) et l'adresse de la ligne au registre √† d√©calage en utilisant ``hc595_shift``, puis bascule la broche ``RCLK`` pour mettre √† jour l'affichage.

   .. code-block:: python

       def display(glyphCode):
           """ Display a glyph on the LED matrix. """
           for i in range(0, 8):
               hc595_shift(glyphCode[i])
               hc595_shift(0x80 >> i)
               RCLK.on()
               RCLK.off()

#. Cette fonction s√©lectionne al√©atoirement un glyphe du dictionnaire ``arrow``, d√©marre le minuteur de jeu et d√©finit l'√©tat du jeu √† "PLAY". ``threading.Timer`` est utilis√© pour le contr√¥le du temps dans le jeu.

   .. code-block:: python

       def creatGlyph():
           """ Create a new glyph for the game and start the play timer. """
           global waypoint, stage, timerPlay
           waypoint = random.choice(list(arrow.keys()))
           stage = "PLAY"
           timerPlay = threading.Timer(2.0, timeOut)
           timerPlay.start()

#. Cette fonction v√©rifie l'entr√©e du joueur par rapport au glyphe actuel. Si l'entr√©e est correcte, elle r√®gle le waypoint sur "right", sinon sur "wrong". Elle annule ensuite le minuteur de jeu actuel et d√©marre un nouveau minuteur pour le prochain glyphe.

   .. code-block:: python

       def checkPoint(inputKey):
           """ Check player's input and update game state. """
           global waypoint, stage, timerCheck
           if inputKey == "empty" or inputKey == waypoint:
               waypoint = "wrong"
           else:
               waypoint = "right"
           timerPlay.cancel()
           stage = "CHECK"
           timerCheck = threading.Timer(1.0, creatGlyph)
           timerCheck.start()

#. Cette fonction est appel√©e lorsque le temps imparti est √©coul√©. Elle invoque ``checkPoint`` avec "empty" pour indiquer qu'aucun bouton n'a √©t√© press√© √† temps.

   .. code-block:: python

       def timeOut():
           """ Handle game timeout scenario. """
           checkPoint("empty")

#. Cette fonction v√©rifie l'√©tat des boutons. Si ``AButtonPin`` est press√© (et ``BButtonPin`` ne l'est pas), elle appelle ``checkPoint`` avec "right". Si ``BButtonPin`` est press√© (et ``AButtonPin`` ne l'est pas), elle appelle ``checkPoint`` avec "left".

   .. code-block:: python

       def getKey():
           """ Detect button press and trigger checkpoint. """
           if AButtonPin.is_pressed and not BButtonPin.is_pressed:
               checkPoint("right")
           elif not AButtonPin.is_pressed and BButtonPin.is_pressed:
               checkPoint("left")

#. La fonction ``main`` contr√¥le le d√©roulement du jeu. Elle commence par cr√©er un glyphe, puis v√©rifie continuellement l'√©tat du jeu. Si l'√©tat est "PLAY", elle affiche le glyphe actuel et v√©rifie les pressions de bouton. Si l'√©tat est "CHECK", elle affiche le retour d'information en fonction de l'action du joueur.

   .. code-block:: python

       def main():
           """ Main game loop. """
           creatGlyph()
           while True:
               if stage == "PLAY":
                   display(arrow[waypoint])
                   getKey()
               elif stage == "CHECK":
                   display(check[waypoint])

#. Cette fonction annule tous les minuteurs en cours lors de la sortie du programme, assurant ainsi une fermeture propre.

   .. code-block:: python

       def destroy():
           """ Clean up resources on program exit. """
           global timerPlay, timerCheck
           timerPlay.cancel()  # Annule le minuteur de jeu
           timerCheck.cancel()  # Annule le minuteur de v√©rification

#. Le jeu est ex√©cut√© dans un bloc ``try``. Si une ``KeyboardInterrupt`` (comme en appuyant sur Ctrl+C) se produit, l'exception est intercept√©e et ``destroy`` est appel√© pour nettoyer avant de quitter.

   .. code-block:: python

       # Ex√©cute le jeu et g√®re l'interruption clavier pour une sortie propre
       try:
           main()
       except KeyboardInterrupt:
           destroy()


