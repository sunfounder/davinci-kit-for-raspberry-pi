.. note::

    Â¡Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Ãšnete para profundizar en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros aficionados.

    **Â¿Por quÃ© unirse?**

    - **Soporte Experto**: Resuelve problemas post-venta y desafÃ­os tÃ©cnicos con ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previsualizaciones Exclusivas**: Accede anticipadamente a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos mÃ¡s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales.

    ðŸ‘‰ Â¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y Ãºnete hoy mismo.

3.1.14 JUEGO â€“ Not Not
==========================

IntroducciÃ³n
--------------------

En esta lecciÃ³n, crearemos un juego divertido al que llamaremos \"Not Not\".

Durante el juego, la matriz de puntos mostrarÃ¡ una flecha de forma aleatoria. Tu tarea es presionar el botÃ³n en la direcciÃ³n opuesta a la flecha dentro de un tiempo limitado. Si el tiempo se agota o presionas el botÃ³n en la misma direcciÃ³n de la flecha, pierdes.

Este juego puede mejorar tu pensamiento inverso, Â¿te animas a intentarlo?

Componentes
---------------

.. image:: img/list_GAME_Not_Not.png
    :align: center

Diagrama EsquemÃ¡tico
----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one14.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Ensambla el circuito.

.. image:: img/image280.png
    :width: 800

**Paso 2:** Accede a la carpeta del cÃ³digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.14/

**Paso 3**: Compila.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.14_GAME_NotNot.c -lwiringPi

**Paso 4**: Ejecuta el archivo.

.. raw:: html

   <run></run>

.. code-block::

     sudo ./a.out

DespuÃ©s de iniciar el programa, una flecha (izquierda o derecha) aparecerÃ¡ 
aleatoriamente en la matriz de puntos. Debes presionar el botÃ³n en la 
direcciÃ³n opuesta a la flecha antes de que el tiempo se agote. Si aciertas, 
aparecerÃ¡ \"**âˆš**\" en la matriz. Si el tiempo se acaba o presionas el botÃ³n 
en la misma direcciÃ³n de la flecha, pierdes y se mostrarÃ¡ una \"x\" en la matriz. 
Puedes agregar dos botones nuevos o sustituirlos con los botones de un joystick 
para manejar las direcciones arriba, abajo, izquierda y derecha, aumentando la 
dificultad del juego.

.. note::

    Si el juego no funciona despuÃ©s de ejecutarlo, o aparece un mensaje de error como : \"wiringPi.h: No such file or directory\", consulta :ref:`C code is not working?`.

**ExplicaciÃ³n del CÃ³digo**

Basado en **1.1.6 Matriz de LEDs**, esta lecciÃ³n aÃ±ade **2** botones para 
hacer un dispositivo de juego entretenido. Si no estÃ¡s familiarizado con 
la matriz de puntos, consulta :ref:`1.1.6 LED Dot Matrix`.

El proceso completo del programa es el siguiente:

1. Seleccionar aleatoriamente una direcciÃ³n de flecha y generar el **temporizador 1**.

2. Mostrar la imagen de la flecha en la matriz de puntos.

3. Comprobar la entrada del botÃ³n. Si se presiona un botÃ³n o el 
   **temporizador 1** indica que el tiempo ha terminado, comienza la verificaciÃ³n.

4. Mostrar la imagen segÃºn el resultado de la verificaciÃ³n, mientras se genera 
   el **temporizador 2**.
5. Volver al **paso 1** cuando el **temporizador 2** indique que el tiempo ha terminado.

.. code-block:: c

    structÂ GLYPH{
    Â Â Â Â charÂ *word;
    Â Â Â Â unsignedÂ charÂ code[8];
    };

    structÂ GLYPHÂ arrow[2]=
    {
        {"right",{0xFF,0xEF,0xDF,0x81,0xDF,0xEF,0xFF,0xFF}},
        // {"down",{0xFF,0xEF,0xC7,0xAB,0xEF,0xEF,0xEF,0xFF}},
        // {"up",{0xFF,0xEF,0xEF,0xEF,0xAB,0xC7,0xEF,0xFF}},    
        {"left",{0xFF,0xF7,0xFB,0x81,0xFB,0xF7,0xFF,0xFF}}
    };

    structÂ GLYPHÂ check[2]=
    {
        {"wrong",{0xFF,0xBB,0xD7,0xEF,0xD7,0xBB,0xFF,0xFF}},
        {"right",{0xFF,0xFF,0xF7,0xEB,0xDF,0xBF,0xFF,0xFF}}
    };

La estructura GLYPH funciona como un diccionario: el atributo **word** 
se corresponde con la **clave** del diccionario, y el atributo **code** 
con el **valor**.

AquÃ­, el cÃ³digo se utiliza para almacenar un arreglo que permite que la matriz de puntos muestre imÃ¡genes (un arreglo de 8x8 bits).

El arreglo **arrow** se puede usar para mostrar una flecha en las direcciones arriba, abajo, izquierda y derecha en la matriz LED.

Por ahora, **down** y **up** estÃ¡n comentados, y puedes descomentarlos si es necesario.

El arreglo **check** se usa para mostrar las dos imÃ¡genes: \"**Ã—**\" y \"**âˆš**\".

.. code-block:: c

    charÂ *lookup(charÂ *key,structÂ GLYPHÂ *glyph,intÂ length){
    Â Â Â Â forÂ (intÂ i=0;i<length;i++)
        {
    Â Â Â Â Â Â Â Â if(strcmp(glyph[i].word,key)==0){
    Â Â Â Â Â Â Â Â Â Â Â Â returnÂ glyph[i].code;
            }
        }    
    }

La funciÃ³n **lookup()** funciona como un "chequeo del diccionario". Define una
**clave**, busca palabras iguales a **key** en la estructura **GLYPH
\*glyph** y devuelve la informaciÃ³n correspondienteâ€”el "cÃ³digo" (**code**)
de la palabra especÃ­fica.

La funciÃ³n **strcmp()** se utiliza para comparar la identidad de dos
cadenas de caracteres: **glyph[i].word** y **key**. Si coinciden, 
devuelve **glyph[i].code** (como se muestra).

.. code-block:: c

    voidÂ display(charÂ *glyphCode){
    Â Â Â Â for(intÂ i;i<8;i++){
            hc595_in(glyphCode[i]);
    Â Â Â Â Â Â Â Â hc595_in(0x80>>i);
            hc595_out();
        }
    }

Muestra el patrÃ³n especificado en la matriz de puntos.

.. code-block:: c

    voidÂ createGlyph(){
        srand(time(NULL));
    Â Â Â Â intÂ i=rand()%(sizeof(arrow)/sizeof(arrow[0]));
    Â Â Â Â waypoint=arrow[i].word;
    Â Â Â Â stage="PLAY";
        alarm(2);
    }

La funciÃ³n **createGlyph()** se usa para seleccionar aleatoriamente una direcciÃ³n
(el atributo word de un elemento en el arreglo **arrow[]:**
"**left**", "**right**"... ). Configura el stage como "PLAY" y empieza
una funciÃ³n de alarma de 2 segundos.

**srand(time(NULL))**: Inicializa las semillas aleatorias a partir del reloj
del sistema.

**(sizeof(arrow) / sizeof(arrow[0]))**: Obtiene la longitud del arreglo, cuyo
resultado es 2.

**rand() % 2**: El resultado es **0** o **1**, obtenido al dividir un nÃºmero
aleatorio generado por 2.

**waypoint=arrow[i].word**: El resultado debe ser "right" o "left".

.. code-block:: c

    voidÂ checkPoint(charÂ *inputKey){
    Â Â Â Â alarm(0)==0;
    Â Â Â Â if(inputKey==waypoint||inputKey=="empty")
        {
    Â Â Â Â Â Â Â Â waypoint="wrong";
        }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â waypoint="right";
        }
    Â Â Â Â stage="CHECK";
        alarm(1);
    }

**checkPoint()** se usa para verificar la entrada del botÃ³n; si no se presiona
el botÃ³n o se presiona el botÃ³n en la misma direcciÃ³n de la flecha, el
resultado del waypoint es "wrong" y aparece "x" en la matriz de puntos. De lo
contrario, el waypoint es "right" y la matriz de puntos muestra "âˆš". AquÃ­ el
**stage** es **CHECK**, y se puede configurar una funciÃ³n de alarma de 1 segundo.

**alarm()** se llama "alarma", en la cual se puede configurar un temporizador, y
envÃ­a seÃ±ales **SIGALRM** al proceso cuando el tiempo definido se acaba.

.. code-block:: c

    voidÂ getKey(){
    Â Â Â Â ifÂ (digitalRead(AButtonPin)==1&&digitalRead(BButtonPin)==0)
        {checkPoint("right");}
    Â Â Â Â elseÂ ifÂ (digitalRead(AButtonPin)==0&&digitalRead(BButtonPin)==1)
        {checkPoint("left");}
    }

**getKey()** lee los estados de estos dos botones; si se presiona el botÃ³n derecho,
el parÃ¡metro de la funciÃ³n **checkPoint()** es "right" y si se presiona el
botÃ³n izquierdo, el parÃ¡metro es "left".

.. code-block:: c

    voidÂ timer(){
    Â Â Â Â ifÂ (stage=="PLAY"){
            checkPoint("empty");
        }
    Â Â Â Â elseÂ if(stage=="CHECK"){
            createGlyph();
        }
    }

Previamente, **timer()** se llamaba cuando se alcanzaba el tiempo configurado
en **alarm()**. Luego, en el modo "PLAY", se llama a **checkPoint()** para
evaluar el resultado. Si el programa estÃ¡ configurado en el modo "CHECK",
deberÃ­a llamarse a la funciÃ³n **createGlyph()** para seleccionar nuevos patrones.

.. code-block:: c

    voidÂ main(){
        setup();
    Â Â Â Â signal(SIGALRM,timer);
        createGlyph();
    Â Â Â Â charÂ *codeÂ =Â NULL;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â ifÂ (stageÂ ==Â "PLAY")
            {
    Â Â Â Â Â Â Â Â Â Â Â Â code=lookup(waypoint,arrow,sizeof(arrow)/sizeof(arrow[0]));
                display(code);
                getKey();
            }
    Â Â Â Â Â Â Â Â elseÂ if(stageÂ ==Â "CHECK")
            {
    Â Â Â Â Â Â Â Â Â Â Â Â codeÂ =Â lookup(waypoint,check,sizeof(check)/sizeof(check[0]));
                display(code);
            }
        }
    }

La funciÃ³n **signal(SIGALRM, timer)**: llama a la funciÃ³n **timer()** 
cuando se recibe una seÃ±al **SIGALRM** (generada por la funciÃ³n de alarma **alarm()**).

Cuando el programa inicia, llama a **createGlyph()** una vez y luego
empieza el bucle.

En el bucle: en modo PLAY, la matriz de puntos muestra los patrones de
flecha y verifica el estado del botÃ³n; si estÃ¡ en modo CHECK, lo que se
muestra es "x" o "âˆš".

