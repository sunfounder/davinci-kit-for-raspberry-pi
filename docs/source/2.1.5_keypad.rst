.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Explorez en profondeur les Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Avant-premi√®res exclusives** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des promotions sp√©ciales et des tirages au sort.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !


2.1.5 Keypad
================


Introduction
--------------

Un clavier num√©rique est une matrice rectangulaire de boutons. Dans ce projet, nous l'utiliserons pour saisir des caract√®res.

Composants
-----------

.. image:: img/list_2.1.5_keypad.png


Principe
---------

**Clavier num√©rique**

Un clavier num√©rique est une matrice rectangulaire de 12 ou 16 boutons OFF-(ON). 
Leurs contacts sont accessibles via un connecteur adapt√© √† une connexion avec un 
c√¢ble ruban ou une insertion dans un circuit imprim√©. Dans certains claviers, chaque 
bouton se connecte √† un contact s√©par√© dans le connecteur, tandis que tous les boutons 
partagent une masse commune.

.. image:: img/image314.png


Souvent, les boutons sont encod√©s en matrice, ce qui signifie que chacun d'eux relie une 
paire unique de conducteurs dans une matrice. Cette configuration est adapt√©e pour un 
microcontr√¥leur, qui peut √™tre programm√© pour envoyer une impulsion de sortie √† chacun 
des quatre fils horizontaux √† tour de r√¥le. Pendant chaque impulsion, il v√©rifie les 
quatre fils verticaux restants pour d√©terminer lequel, le cas √©ch√©ant, transporte un 
signal. Des r√©sistances pullup ou pulldown doivent √™tre ajout√©es aux fils d'entr√©e pour 
emp√™cher les entr√©es du microcontr√¥leur de se comporter de mani√®re impr√©visible lorsqu'aucun 
signal n'est pr√©sent.

Sch√©ma de c√¢blage
----------------------

.. image:: img/image315.png


.. image:: img/image316.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image186.png
    :width: 800



Pour les utilisateurs de C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.5/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.5_Keypad.cpp -lwiringPi

**√âtape 4 :** Ex√©cutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, les valeurs des boutons press√©s sur le clavier 
(Valeur du bouton) seront affich√©es √† l'√©cran.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur s'affiche : \"wiringPi.h : Aucun fichier ou r√©pertoire de ce type\", veuillez consulter :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define ROWS  4 
    #define COLS  4
    #define BUTTON_NUM (ROWS * COLS)

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

    void keyRead(unsigned char* result);
    bool keyCompare(unsigned char* a, unsigned char* b);
    void keyCopy(unsigned char* a, unsigned char* b);
    void keyPrint(unsigned char* a);
    void keyClear(unsigned char* a);
    int keyIndexOf(const char value);

    void init(void) {
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
    }

    int main(void){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];

        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;  
    }

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

    void keyPrint(unsigned char* a){
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

    void keyClear(unsigned char* a){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = 0;
        }
    }

    int keyIndexOf(const char value){
        for (int i=0; i<BUTTON_NUM; i++){
            if ((const char)KEYS[i] == value){
                return i;
            }
        }
        return -1;
    }
**Explication du Code**

.. code-block:: c

    unsigned char KEYS[BUTTON_NUM] {  
    '1','2','3','A',
    '4','5','6','B',
    '7','8','9','C',
    '*','0','#','D'};

    unsigned char rowPins[ROWS] = {1, 4, 5, 6}; 
    unsigned char colPins[COLS] = {12, 3, 2, 0};

D√©clarez chaque touche du clavier matriciel dans le tableau keys[] et d√©finissez 
les broches de chaque ligne et colonne.

.. code-block:: c

    while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                keyPrint(pressed_keys);
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }

Ceci est la partie de la fonction principale qui lit et affiche la valeur des touches.

La fonction keyRead() lira l'√©tat de chaque touche.

keyCompare() et keyCopy() sont utilis√©es pour d√©terminer si l'√©tat d'une touche a chang√© 
(c'est-√†-dire si une touche a √©t√© appuy√©e ou rel√¢ch√©e).

keyPrint() affichera la valeur de la touche dont le niveau actuel est √©lev√© (la touche est 
enfonc√©e).

.. code-block:: c

    void keyRead(unsigned char* result){
        int index;
        int count = 0;
        keyClear(result);
        for(int i=0 ; i<ROWS ; i++ ){
            digitalWrite(rowPins[i], HIGH);
            for(int j =0 ; j < COLS ; j++){
                index = i * ROWS + j;
                if(digitalRead(colPins[j]) == 1){
                    result[count]=KEYS[index];
                    count += 1;
                }
            }
            delay(1);
            digitalWrite(rowPins[i], LOW);
        }
    }

Cette fonction attribue un niveau √©lev√© √† chaque ligne √† tour de r√¥le, et lorsque la 
touche dans la colonne est enfonc√©e, la colonne obtient un niveau √©lev√©. Apr√®s la 
double boucle de v√©rification, l'√©tat des touches compil√© g√©n√©rera un tableau (result[]).

Lorsque vous appuyez sur la touche 3 :

.. image:: img/image187.png


RowPin [0] √©crit un niveau √©lev√©, et colPin[2] re√ßoit le niveau √©lev√©. Les autres 
colPin obtiennent un niveau bas.

Cela donne 0,0,1,0. Lorsque rowPin[1], rowPin[2] et rowPin[3] sont √©crits en niveau 
√©lev√©, les colPin recevront tous un niveau bas.

Apr√®s la boucle, un tableau est g√©n√©r√© :

.. code-block:: c

    result[BUTTON_NUM] {  
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};

.. code-block:: c

    bool keyCompare(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            if (a[i] != b[i]){
                return false;
            }
        }
        return true;
    }

    void keyCopy(unsigned char* a, unsigned char* b){
        for (int i=0; i<BUTTON_NUM; i++){
            a[i] = b[i];
        }
    }

Ces deux fonctions sont utilis√©es pour v√©rifier si l'√©tat des touches a chang√©, par 
exemple lorsque vous rel√¢chez la touche '3' ou appuyez sur '2', keyCompare() renverra false.

KeyCopy() r√©√©crit la valeur actuelle de la touche dans le tableau a 
(last_key_pressed[BUTTON_NUM]) apr√®s chaque comparaison pour permettre une 
comparaison la prochaine fois.

.. code-block:: c

    void keyPrint(unsigned char* a){
    //printf("{");
        if (a[0] != 0){
            printf("%c",a[0]);
        }
        for (int i=1; i<BUTTON_NUM; i++){
            if (a[i] != 0){
                printf(", %c",a[i]);
            }
        }
        printf("\n");
    }

Cette fonction est utilis√©e pour afficher la valeur de la touche actuellement 
enfonc√©e. Si la touche '1' est enfonc√©e, '1' sera affich√©. Si vous appuyez sur 
'1' et ensuite sur '3', '1, 3' sera affich√©.


Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.5_Keypad.py

Apr√®s l'ex√©cution du code, les valeurs des touches press√©es sur le clavier 
(valeur des boutons) seront affich√©es √† l'√©cran.



**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source du code, tel que ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # D√©finir une fonction destroy pour nettoyer tout apr√®s la fin du script
    def destroy():
        # Lib√©rer les ressources
        GPIO.cleanup() 

    if __name__ == '__main__':     # Le programme commence ici
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # Lorsque 'Ctrl+C' est press√©, la fonction destroy() sera ex√©cut√©e.
            destroy()
**Explication du Code**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

D√©clarez chaque touche du clavier matriciel dans le tableau keys[] et d√©finissez 
les broches pour chaque ligne et colonne.

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

Voici la partie de la fonction principale qui lit et affiche la valeur des boutons press√©s.

La fonction keyRead() lira l'√©tat de chaque bouton.

La condition if len(pressed_keys) != 0 and last_key_pressed != pressed_keys est 
utilis√©e pour v√©rifier

si une touche est enfonc√©e et si l'√©tat de la touche press√©e a chang√©. 
(Si vous appuyez sur "3" apr√®s avoir appuy√© sur "1", cette condition est vraie.)

Affiche la valeur de la touche actuellement press√©e lorsque la condition est remplie.

L'instruction last_key_pressed = pressed_keys attribue l'√©tat de chaque jugement 
√† un tableau last_key_pressed pour faciliter le prochain tour de jugement conditionnel.

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

Cette fonction affecte un niveau haut √† chaque ligne √† tour de r√¥le, et lorsque le 
bouton d'une colonne est enfonc√©, la colonne dans laquelle la touche se trouve re√ßoit 
un niveau haut. Apr√®s la v√©rification en boucle, la valeur du bouton dont l'√©tat est 1 
est stock√©e dans le tableau pressed_keys.

Si vous appuyez sur la touche "3" :

.. image:: img/image187.png

rowPins[0] est √©crit en niveau haut, et colPins[2] obtient un niveau haut.

colPins[0], colPins[1], colPins[3] obtiennent un niveau bas.

Il y a quatre √©tats : 0, 0, 1, 0 ; et nous √©crivons "3" dans pressed_keys.

Lorsque rowPins[1], rowPins[2] et rowPins[3] sont √©crits en niveau haut, colPins[0] ~ colPins[4] obtiennent un niveau bas.

La boucle s'arr√™te et retourne pressed_keys = '3'.

Si vous appuyez sur les touches '1' et '3', pressed_keys retournera = ['1', '3'].

Image du Ph√©nom√®ne
----------------------

.. image:: img/image188.jpeg
