.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi & Arduino & ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, d'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Recevez des annonces anticip√©es sur les nouveaux produits et des aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et tirages au sort** : Participez √† des concours et promotions pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

3.1.2 Bienvenue
===============

Introduction
------------

Dans ce projet, nous utiliserons un capteur PIR pour d√©tecter le mouvement des pi√©tons, 
ainsi qu'un servo, une LED et un buzzer pour simuler le fonctionnement de la porte 
automatique d'un magasin. Lorsque le pi√©ton entre dans la zone de d√©tection du capteur 
PIR, le voyant s'allume, la porte s'ouvre, et le buzzer joue une m√©lodie d'ouverture.

Composants
------------

.. image:: img/list_Welcome.png
    :align: center

Sch√©ma
--------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO18       Pin 12   1        18
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
============ ======== ======== ===

.. image:: img/Schematic_three_one2.png
   :align: center

Proc√©dures exp√©rimentales
-------------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image239.png
    :alt: C:\Users\sunfounder\Desktop\3.1.4_Welcome_bb.png3.1.4_Welcome_bb
    :width: 800
    :align: center

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.2/

**√âtape 3 :** Compilation.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.2_Welcome.c -lwiringPi

**√âtape 4 :** Ex√©cution.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Une fois le code ex√©cut√©, si le capteur PIR d√©tecte quelqu'un passant √† proximit√©, 
la porte s'ouvrira automatiquement (simul√©e par le servo), le voyant s'allumera et 
la m√©lodie de la sonnette retentira. Apr√®s la m√©lodie, le syst√®me refermera 
automatiquement la porte et √©teindra le voyant, en attente du prochain passage.

Le module PIR est √©quip√© de deux potentiom√®tres : l'un pour r√©gler la sensibilit√© 
et l'autre pour ajuster la distance de d√©tection. Pour optimiser le fonctionnement 
du module PIR, vous devez les tourner compl√®tement dans le sens antihoraire.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur : \"wiringPi.h: No such file or directory\", veuillez consulter :ref:`C code is not working?`.
**Explication du code**

.. code-block:: c

    void setAngle(int pin, int angle){    // Cr√©er une fonction pour contr√¥ler l'angle du servo.
        if(angle < 0)
            angle = 0;
        if(angle > 180)
            angle = 180;
        softPwmWrite(pin,Map(angle, 0, 180, 5, 25));   
    } 

Cr√©ation de la fonction setAngle pour d√©finir l'angle du servo entre 0 et 180 degr√©s.

.. code-block:: c

    void doorbell(){
    for(int i=0;i<sizeof(song)/4;i++){
            softToneWrite(BuzPin, song[i]); 
            delay(beat[i] * 250);
        }

Cr√©ation de la fonction doorbell pour faire jouer une m√©lodie par le buzzer.

.. code-block:: c

    void closedoor(){
    digitalWrite(ledPin, LOW);   // √âteindre la LED
    for(int i=180;i>-1;i--){  // Faire pivoter le servo de l'angle maximum √† l'angle minimum
        setAngle(servoPin,i);
        delay(1);
        }
    }

Cr√©ation de la fonction closedoor pour simuler la fermeture de la porte, √©teindre la LED et faire pivoter le servo de 180 degr√©s √† 0 degr√©.

.. code-block:: c

    void opendoor(){
        digitalWrite(ledPin, HIGH);   // Allumer la LED
        for(int i=0;i<181;i++){  // Faire pivoter le servo de l'angle minimum √† l'angle maximum
            setAngle(servoPin,i);
            delay(1);
        }
        doorbell();
        closedoor();
    }

La fonction opendoor() comporte plusieurs √©tapes : allumer la lumi√®re indicatrice, 
faire pivoter le servo (simulant l'ouverture de la porte), jouer la m√©lodie de la 
sonnette et appeler la fonction closedoor() apr√®s la musique.

.. code-block:: c

        int main(void)
    {
        if(wiringPiSetup() == -1){ // Si l'initialisation de wiringPi √©choue, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
    ......

Dans la fonction main(), initialisez la biblioth√®que wiringPi et configurez softTone, 
puis d√©finissez ledPin en mode sortie et pirPin en mode entr√©e. Si le capteur PIR d√©tecte 
une personne passant √† proximit√©, la fonction opendoor sera appel√©e pour simuler 
l'ouverture de la porte.



**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changer de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cuter.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.2_Welcome.py

Une fois le code ex√©cut√©, si le capteur PIR d√©tecte le passage d'une personne, 
la porte s'ouvrira automatiquement (simul√©e par le servo), la lumi√®re indicatrice 
s'allumera et la m√©lodie de la sonnette retentira. Apr√®s la m√©lodie, le syst√®me 
refermera automatiquement la porte et √©teindra la lumi√®re indicatrice, en attente 
du prochain passage.

Le module PIR est √©quip√© de deux potentiom√®tres : l'un pour r√©gler la sensibilit√© 
et l'autre pour ajuster la distance de d√©tection. Pour optimiser le fonctionnement 
du module PIR, tournez-les compl√®tement dans le sens antihoraire.

**code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin du code source tel que ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    SERVO_MIN_PULSE = 500
    SERVO_MAX_PULSE = 2500

    ledPin = 18    # d√©finir le ledPin
    pirPin = 17    # d√©finir le sensorPin
    servoPin = 22  # d√©finir le servoPin
    buzPin = 27    # d√©finir le buzzerPin


    CL = [0, 131, 147, 165, 175, 196, 211, 248]        # Fr√©quences des notes C basses

    CM = [0, 262, 294, 330, 350, 393, 441, 495]        # Fr√©quences des notes C moyennes

    CH = [0, 525, 589, 661, 700, 786, 882, 990]        # Fr√©quences des notes C hautes

    song = [    CH[5],CH[2],CM[6],CH[2],CH[3],CH[6],CH[3],CH[5],CH[3],CM[6],CH[2]    ]

    beat = [    1,1,1,1,1,2,1,1,1,1,1,]

    def setup():
        global p
        global Buzz                        # D√©claration d'une variable globale pour remplacer GPIO.PWM 
        GPIO.setmode(GPIO.BCM)             # Num√©rotation des GPIOs par leur emplacement physique
        GPIO.setup(ledPin, GPIO.OUT)       # Configuration de ledPin en mode sortie
        GPIO.setup(pirPin, GPIO.IN)        # Configuration de pirPin en mode entr√©e
        GPIO.setup(servoPin, GPIO.OUT)     # Configuration de servoPin en mode sortie
        GPIO.output(servoPin, GPIO.LOW)    # Mise du servoPin √† l'√©tat bas
        GPIO.setup(buzPin, GPIO.OUT)       # Configuration de buzPin en mode sortie

        Buzz = GPIO.PWM(buzPin, 440)       # 440 est la fr√©quence initiale.
        Buzz.start(50)                     # D√©marrage du buzzer avec un rapport cyclique de 50 %

        p = GPIO.PWM(servoPin, 50)         # R√©glage de la fr√©quence √† 50 Hz
        p.start(0)                         # Rapport cyclique √† 0

    def map(value, inMin, inMax, outMin, outMax):
        return (outMax - outMin) * (value - inMin) / (inMax - inMin) + outMin

        
    def setAngle(angle):                   # Faire tourner le servo √† un angle sp√©cifique (0-180 degr√©s)
        angle = max(0, min(180, angle))
        pulse_width = map(angle, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE)
        pwm = map(pulse_width, 0, 20000, 0, 100)
        p.ChangeDutyCycle(pwm)              # Conversion de l'angle en rapport cyclique et sortie vers le servo
        
    def doorbell():
        for i in range(1, len(song)):       # Jouer la chanson 1
            Buzz.ChangeFrequency(song[i])   # Changer la fr√©quence selon les notes de la chanson
            time.sleep(beat[i] * 0.25)      # D√©lai correspondant au battement * 0,25 s
        time.sleep(1)                       # Attendre une seconde avant la chanson suivante.

    def closedoor():
        GPIO.output(ledPin, GPIO.LOW)
        for i in range(180, -1, -1):        # Faire pivoter le servo de 180 √† 0 degr√©s
            setAngle(i)
            time.sleep(0.001)
        time.sleep(1)
    
    def opendoor():
        GPIO.output(ledPin, GPIO.LOW)
        for i in range(0, 181, 1):          # Faire pivoter le servo de 0 √† 180 degr√©s
            setAngle(i)                     # Commande au servo
            time.sleep(0.001)
        time.sleep(1)
        doorbell()
        closedoor()

    def loop():
        while True:
            if GPIO.input(pirPin)==GPIO.HIGH:
                opendoor()

    def destroy():
        GPIO.cleanup()                      # Lib√©ration des ressources
        p.stop()
        Buzz.stop()

    if __name__ == '__main__':              # Le programme commence ici
        setup()
        try:
            loop()
        except KeyboardInterrupt:           # Lorsque 'Ctrl+C' est press√©, la fonction destroy() sera ex√©cut√©e.
            destroy()

**Explication du code**

.. code-block:: python

    def setup():
        global p
        global Buzz                        # D√©claration d'une variable globale pour remplacer GPIO.PWM
        GPIO.setmode(GPIO.BCM)             # Num√©rotation des GPIOs par leur emplacement physique
        GPIO.setup(ledPin, GPIO.OUT)       # Configuration de ledPin en mode sortie
        GPIO.setup(pirPin, GPIO.IN)        # Configuration de pirPin en mode entr√©e
        GPIO.setup(buzPin, GPIO.OUT)       # Configuration de buzPin en mode sortie
        Buzz = GPIO.PWM(buzPin, 440)       # 440 est la fr√©quence initiale.
        Buzz.start(50)                     # D√©marrage du buzzer avec un rapport cyclique de 50 %
        GPIO.setup(servoPin, GPIO.OUT)     # Configuration de servoPin en mode sortie
        GPIO.output(servoPin, GPIO.LOW)    # Mise du servoPin √† l'√©tat bas
        p = GPIO.PWM(servoPin, 50)         # R√©glage de la fr√©quence √† 50 Hz
        p.start(0)                         # Rapport cyclique √† 0

Ces instructions sont utilis√©es pour initialiser les broches de chaque composant.

.. code-block:: python

    def setAngle(angle):                   # Faire tourner le servo √† un angle sp√©cifique (0-180 degr√©s)
        angle = max(0, min(180, angle))
        pulse_width = map(angle, 0, 180, SERVO_MIN_PULSE, SERVO_MAX_PULSE)
        pwm = map(pulse_width, 0, 20000, 0, 100)
        p.ChangeDutyCycle(pwm)              # Conversion de l'angle en rapport cyclique et sortie vers le servo

Cr√©ation d'une fonction servowrite pour √©crire l'angle dans le servo entre 0 et 180 degr√©s.

.. code-block:: python

    def doorbell():
        for i in range(1,len(song)):        # Jouer la chanson 1
            Buzz.ChangeFrequency(song[i])   # Changer la fr√©quence selon les notes de la chanson
            time.sleep(beat[i] * 0.25)      # D√©lai d'une note pour beat * 0,25 s

Cr√©ation d'une fonction doorbell pour permettre au buzzer de jouer de la musique.

.. code-block:: python

    def closedoor():
        GPIO.output(ledPin, GPIO.LOW)
        Buzz.ChangeFrequency(1)
        for i in range(180, -1, -1):        # Faire pivoter le servo de 180 √† 0 degr√©s
            setAngle(i)
            time.sleep(0.001)

Fermer la porte et √©teindre le voyant lumineux.

.. code-block:: python

    def opendoor():
        GPIO.output(ledPin, GPIO.LOW)
        for i in range(0, 181, 1):          # Faire pivoter le servo de 0 √† 180 degr√©s
            setAngle(i)                     # Commande au servo
            time.sleep(0.001)
        doorbell()
        closedoor()

La fonction opendoor() comporte plusieurs √©tapes : allumer le voyant, faire pivoter 
le servo (pour simuler l'ouverture de la porte), jouer la musique de la sonnette et 
appeler la fonction closedoor() apr√®s la musique.

.. code-block:: python

    def loop():
    while True:
        if GPIO.input(pirPin)==GPIO.HIGH:
            opendoor()

Lorsque le capteur PIR d√©tecte une personne passant √† proximit√©, il appelle la fonction 
opendoor().

Image du ph√©nom√®ne
--------------------

.. image:: img/image240.jpeg
   :align: center
