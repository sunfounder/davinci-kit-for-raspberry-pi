.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder d√©di√©e aux passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers du Raspberry Pi, d'Arduino et d'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et relevez des d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de remises exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des tirages au sort et √† des promotions sp√©ciales pour les f√™tes.

    üëâ Pr√™t(e) √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.1.4 Potentiom√®tre
=====================

Introduction
---------------

La fonction ADC peut √™tre utilis√©e pour convertir des signaux analogiques en 
signaux num√©riques. Dans cette exp√©rience, nous utilisons l'ADC0834 pour r√©aliser 
cette conversion. Ici, nous mettons en ≈ìuvre ce processus √† l'aide d'un potentiom√®tre. 
Le potentiom√®tre modifie la grandeur physique ‚Äî la tension ‚Äî qui est convertie par 
la fonction ADC.

Composants
--------------

.. image:: img/list_2.1.4_potentiometer.png


Principe
----------

**ADC0834**

L'ADC0834 est un convertisseur analogique-num√©rique 8 bits de type 
`approximation successive <https://cn.bing.com/dict/search?q=successive approximations&FORM=BDVSP6&mkt=zh-cn>`__ 
√©quip√© d'un multiplexeur multicanal configurable en entr√©e et d'une interface d'entr√©e/sortie s√©rie. L'interface s√©rie est 
con√ßue pour interagir avec des registres √† d√©calage standard ou des microprocesseurs.

.. image:: img/image309.png


**S√©quence d'op√©ration**

Une conversion est lanc√©e en mettant CS √† un niveau bas, ce qui active tous les 
circuits logiques. CS doit √™tre maintenu bas pendant toute la dur√©e du processus 
de conversion. Une horloge d'entr√©e est alors envoy√©e par le processeur. √Ä chaque 
transition de l'horloge de bas en haut, les donn√©es sur DI sont horodat√©es dans le 
registre de d√©calage d'adressage du multiplexeur. Le premier niveau logique haut 
est le bit de d√©part. Un mot d'affectation de 3 √† 4 bits suit ce bit de d√©part. √Ä 
chaque transition de l'horloge de bas en haut, le bit de d√©part et le mot d'affectation 
sont d√©cal√©s dans le registre de d√©calage. Lorsque le bit de d√©part atteint la position 
de d√©marrage du registre du multiplexeur, le canal d'entr√©e est s√©lectionn√© et la 
conversion commence. La sortie de statut du SAR (SARS) passe √† un niveau haut pour 
indiquer qu'une conversion est en cours, et DI est d√©sactiv√© pendant toute la dur√©e 
de la conversion.

Une p√©riode d'horloge est automatiquement ins√©r√©e pour permettre au canal multiplex√© 
s√©lectionn√© de se stabiliser. La sortie de donn√©es DO quitte l'√©tat haute imp√©dance 
et fournit un niveau bas initial pour cette p√©riode d'horloge de stabilisation. Le 
comparateur du SAR compare successivement les sorties de l'√©chelle r√©sistive avec le 
signal analogique d'entr√©e. La sortie du comparateur indique si l'entr√©e analogique 
est sup√©rieure ou inf√©rieure √† la sortie de l'√©chelle r√©sistive. Au fur et √† mesure 
que la conversion avance, les donn√©es de conversion sont simultan√©ment sorties par 
la broche de sortie DO, avec le bit de poids fort (MSB) en premier.

Apr√®s huit p√©riodes d'horloge, la conversion est termin√©e et la sortie SARS passe √† 
un niveau bas. Enfin, les donn√©es sont √©mises en ordre du bit de poids faible apr√®s 
la s√©quence MSB en premier.

.. image:: img/image175.png
    :width: 800
    :align: center


**Table de contr√¥le d'adresse du MUX de l'ADC0834**

.. image:: img/image176.png
    :width: 800
    :align: center


**Potentiom√®tre**

Le potentiom√®tre est un composant r√©sistif √† trois bornes dont la valeur de r√©sistance 
peut √™tre ajust√©e selon une variation r√©guli√®re. Il se compose g√©n√©ralement d'une 
r√©sistance et d'une brosse mobile. Lorsque la brosse se d√©place le long de la r√©sistance, 
une certaine r√©sistance ou tension de sortie est g√©n√©r√©e en fonction du d√©placement.

.. image:: img/image310.png
    :width: 300
    :align: center


Les fonctions du potentiom√®tre dans le circuit sont les suivantes :

1. Fonction de diviseur de tension.

Le potentiom√®tre est une r√©sistance r√©glable en continu. Lorsque vous ajustez l'axe ou 
la poign√©e de glissement du potentiom√®tre, le contact mobile se d√©place sur la r√©sistance. 
√Ä ce moment, une tension peut √™tre √©mise en fonction de la tension appliqu√©e sur le 
potentiom√®tre et de l'angle ou de la distance parcourue par le bras mobile.

Sch√©ma de c√¢blage
----------------------

.. image:: img/image311.png


.. image:: img/image312.png


Proc√©dures exp√©rimentales
-------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/image180.png
    :width: 800

.. note::
    Veuillez placer la puce en vous r√©f√©rant √† la position correspondante indiqu√©e 
    sur l'image. Notez que les encoches de la puce doivent √™tre √† gauche lorsqu'elle 
    est positionn√©e.

**√âtape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.1.4/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.4_Potentiometer.c -lwiringPi

**√âtape 4 :** Ex√©cutez le programme.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, tournez le bouton du potentiom√®tre et l'intensit√© de 
la LED changera en cons√©quence.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur 
    indiquant : \"wiringPi.h: No such file or directory\", veuillez consulter :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de d√©marrage
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Mode Single End
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD (Impair)
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // S√©lection
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        uchar analogVal;
        if(wiringPiSetup() == -1){ // lorsque l'initialisation de wiringPi √©choue, afficher un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        softPwmCreate(LedPin,  0, 100);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            delay(100);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }
        return 0;
    }
**Explication du Code**

.. code-block:: c

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

D√©finit les broches CS, CLK et DIO de l'ADC0834, connect√©es respectivement 
√† GPIO0, GPIO1 et GPIO2. Puis, la LED est attach√©e √† GPIO3.

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de d√©marrage
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Mode Single End
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD (Impair)
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // S√©lection
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

Cette fonction de l'ADC0834 effectue la conversion analogique-num√©rique (ADC). 
Le flux de travail d√©taill√© est le suivant :

.. code-block:: c

    digitalWrite(ADC_CS, 0);

Met CS √† un niveau bas pour commencer √† activer la conversion analogique-num√©rique.

.. code-block:: c

    // Bit de d√©marrage
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Lors de la premi√®re transition du signal d'horloge de bas √† haut, DIO est mis √† 1 comme bit de d√©marrage. Au cours des trois √©tapes suivantes, 3 bits d'affectation sont envoy√©s.

.. code-block:: c

    // Mode Single End
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Lors de la deuxi√®me transition de bas √† haut du signal d'horloge, DIO est √† nouveau d√©fini √† 1, ce qui active le mode Single End.

.. code-block:: c

    // ODD
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Lorsque cette op√©ration se produit pour la troisi√®me fois, la valeur de DIO est d√©termin√©e par la variable **odd**.

.. code-block:: c

    //S√©lection
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);

Lors du quatri√®me changement de niveau du signal d'horloge de bas √† haut, 
la valeur de DIO est d√©termin√©e par la variable **sel**.

Lorsque channel=0, sel=0, odd=0, les formules de calcul pour **sel** et **odd** 
sont les suivantes :

.. code-block:: c

    int sel = channel > 1 & 1;
    int odd = channel & 1;

Pour la condition channel=1, sel=0, odd=1, r√©f√©rez-vous au tableau de la 
logique de contr√¥le d'adresse ci-dessous. Ici, CH1 est s√©lectionn√©, et le 
bit de d√©marrage est d√©cal√© dans la position de d√©part du registre du multiplexeur, 
et la conversion commence.

.. image:: img/image313.png


.. code-block:: c

    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

Ici, DIO est mis √† 1 deux fois, cette op√©ration peut √™tre ignor√©e.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

Dans la premi√®re boucle for(), d√®s que le cinqui√®me changement de niveau du 
signal CLK de haut √† bas se produit, DIO est d√©fini en mode entr√©e. La conversion 
commence alors, et la valeur convertie est stock√©e dans la variable dat1. Apr√®s 
huit cycles d'horloge, la conversion est termin√©e.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

Dans la deuxi√®me boucle for(), les valeurs converties sont envoy√©es via DO 
apr√®s huit autres cycles d'horloge et stock√©es dans la variable dat2.

.. code-block:: c

    digitalWrite(ADC_CS,1);
    pinMode(ADC_DIO, OUTPUT);
    return(dat1==dat2) ? dat1 : 0;

return(dat1==dat2) ? dat1 : 0 est utilis√© pour comparer la valeur obtenue 
pendant la conversion avec la valeur de sortie. Si elles sont √©gales, la 
valeur convertie dat1 est retourn√©e, sinon la valeur retourn√©e est 0. Ici, 
le flux de travail de l'ADC0834 est termin√©.

.. code-block:: c

    softPwmCreate(LedPin,  0, 100);

Cette fonction permet de cr√©er par logiciel une broche PWM, LedPin. La largeur 
d'impulsion initiale est fix√©e √† 0, et la p√©riode du signal PWM est d√©finie √† 100 x 100 us.

.. code-block:: c

    while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }

Dans le programme principal, la valeur du canal 0, qui est connect√© √† un 
potentiom√®tre, est lue et stock√©e dans la variable analogVal, puis elle 
est √©crite dans LedPin. Vous pouvez ainsi observer la variation de la 
luminosit√© de la LED en fonction de la valeur du potentiom√®tre.

