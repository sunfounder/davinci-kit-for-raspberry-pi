.. note::

    Bonjour et bienvenue dans la communautÃ© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez au cÅ“ur de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez les problÃ¨mes aprÃ¨s-vente et les dÃ©fis techniques avec l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & partager** : Ã‰changez des astuces et des tutoriels pour amÃ©liorer vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits.
    - **Remises spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des tirages au sort et Ã  des promotions spÃ©ciales.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.13 JEU â€“ 10 Secondes
==============================

Introduction
-------------------

Ensuite, suivez-moi pour fabriquer un dispositif de jeu qui dÃ©fiera votre 
concentration. Attachez le commutateur d'inclinaison Ã  un bÃ¢ton pour en faire 
une baguette magique. Secouez la baguette, l'afficheur 4 chiffres commencera 
Ã  compter ; secouez Ã  nouveau pour arrÃªter le comptage. Si vous rÃ©ussissez Ã  
garder le compteur affichÃ© sur **10.00**, vous gagnez. Jouez avec vos amis pour 
voir qui est le maÃ®tre du temps.

Composants
----------------

.. image:: img/list_GAME_10_Second.png
    :align: center

SchÃ©ma de Connexion
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: img/Schematic_three_one13.png
   :align: center

ProcÃ©dure ExpÃ©rimentale
---------------------------------

**Ã‰tape 1** : Construisez le circuit.

.. image:: img/image277.png
   :alt: 10 second_bb
   :width: 800

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2** : AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.13/

**Ã‰tape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 3.1.13_GAME_10Second.c -lwiringPi

**Ã‰tape 4** : ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Secouez la baguette, l'afficheur 4 chiffres commencera Ã  compter ; secouez Ã  
nouveau pour arrÃªter le comptage. Si vous parvenez Ã  atteindre **10.00**, vous 
gagnez. Secouez encore une fois pour lancer la manche suivante.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution, ou si un message d'erreur indique : \"wiringPi.h: Aucun fichier ou rÃ©pertoire de ce type", veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.

**Explication du code**

.. code-block:: c

    voidÂ stateChange(){
    Â Â Â Â ifÂ (gameStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â counterÂ =Â 0;
            delay(1000);
            ualarm(10000,10000); 
        }else{
            alarm(0);
            delay(1000);
        }
    Â Â Â Â gameStateÂ =Â (gameStateÂ +Â 1)%2;
    }

Le jeu est divisÃ© en deux modes :

gameState=0 est le mode "dÃ©marrage", dans lequel le temps est mesurÃ© et affichÃ© 
sur l'afficheur Ã  segments, et le commutateur d'inclinaison est secouÃ© pour entrer 
dans le mode "affichage".

GameState=1 est le mode "affichage", qui arrÃªte le chronomÃ©trage et montre le 
temps sur l'afficheur. Secouer Ã  nouveau le commutateur d'inclinaison rÃ©initialise 
le chronomÃ¨tre et relance le jeu.

.. code-block:: c

    voidÂ loop(){
    Â Â Â Â intÂ currentStateÂ =0;
    Â Â Â Â intÂ lastState=0;
        while(1){
            display();
    Â Â Â Â Â Â Â Â currentState=digitalRead(sensorPin);
    Â Â Â Â Â Â Â Â if((currentState==0)&&(lastState==1)){
                stateChange();
            }
    Â Â Â Â Â Â Â Â lastState=currentState;
        }
    }

Loop() est la fonction principale. Elle affiche le temps sur l'afficheur Ã  4 
segments et lit la valeur du commutateur d'inclinaison. Si l'Ã©tat du commutateur 
change, stateChange() est appelÃ©.

**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2** : AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Ã‰tape 3** : ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.13_GAME_10Second.py

Secouez la baguette, l'afficheur 4 chiffres commencera Ã  compter ; secouez Ã  
nouveau pour arrÃªter le comptage. Si vous parvenez Ã  atteindre **10.00**, vous 
gagnez. Secouez encore une fois pour lancer la manche suivante.

**Code**

.. note::

    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant cela, vous devez aller au chemin du code source comme ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    sensorPin = 26

    SDI = 24
    RCLK = 23
    SRCLK = 18

    placePin = (10, 22, 27, 17)
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    counter = 0
    timer =0
    gameState =0

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)    

    def hc595_shift(data): 
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

    def display():
        global counter                    
        clearDisplay() 
        pickDigit(0)  
        hc595_shift(number[counter % 10])

        clearDisplay()
        pickDigit(1)
        hc595_shift(number[counter % 100//10])

        clearDisplay()
        pickDigit(2)
        hc595_shift(number[counter % 1000//100]-0x80)

        clearDisplay()
        pickDigit(3)
        hc595_shift(number[counter % 10000//1000])

    def stateChange():
        global gameState
        global counter
        global timer1
        if gameState == 0:
            counter = 0
            time.sleep(1)
            timer() 
        elif gameState ==1:
            timer1.cancel()
            time.sleep(1)
        gameState = (gameState+1)%2

    def loop():
        global counter
        currentState = 0
        lastState = 0
        while True:
            display()
            currentState=GPIO.input(sensorPin)
            if (currentState == 0) and (lastState == 1):
                stateChange()
            lastState=currentState

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for i in placePin:
            GPIO.setup(i, GPIO.OUT)
        GPIO.setup(sensorPin, GPIO.IN)

    def destroy():   # Quand "Ctrl+C" est pressÃ©, la fonction est exÃ©cutÃ©e.
        GPIO.cleanup()
        global timer1
        timer1.cancel()

    if __name__ == '__main__':  # Le programme commence ici
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    defÂ stateChange():
    Â Â Â Â globalÂ gameState
    Â Â Â Â globalÂ counter
    Â Â Â Â globalÂ timer1
    Â Â Â Â ifÂ gameStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â counterÂ =Â 0
            time.sleep(1)
            timer() 
    Â Â Â Â elifÂ gameStateÂ ==1:
            timer1.cancel()
            time.sleep(1)
    Â Â Â Â gameStateÂ =Â (gameState+1)%2

Le jeu est divisÃ© en deux modes :

gameState=0 est le mode "dÃ©marrage", oÃ¹ le temps est chronomÃ©trÃ© et affichÃ© sur 
l'afficheur Ã  segments, et le commutateur d'inclinaison est secouÃ© pour passer 
au mode "affichage".

GameState=1 est le mode "affichage", qui arrÃªte le chronomÃ©trage et montre le 
temps sur l'afficheur. Secouer Ã  nouveau le commutateur d'inclinaison rÃ©initialisera 
le chronomÃ¨tre et redÃ©marrera le jeu.

.. code-block:: python

    defÂ loop():
    Â Â Â Â globalÂ counter
    Â Â Â Â currentStateÂ =Â 0
    Â Â Â Â lastStateÂ =Â 0
    Â Â Â Â whileÂ True:
            display()
            currentState=GPIO.input(sensorPin)
    Â Â Â Â Â Â Â Â ifÂ (currentStateÂ ==Â 0)Â andÂ (lastStateÂ ==Â 1):
                stateChange()
            lastState=currentState

Loop() est la fonction principale. D'abord, le temps est affichÃ© sur l'afficheur 
4 chiffres et la valeur du commutateur d'inclinaison est lue. Si l'Ã©tat du commutateur 
change, stateChange() est appelÃ©.

.. code-block:: python

    def timer():  
        global counter
        global timer1
        timer1 = threading.Timer(0.01, timer) 
        timer1.start()  
        counter += 1

AprÃ¨s que l'intervalle atteigne 0,01s, la fonction timer est appelÃ©e ; on ajoute 1 
au compteur, et le timer est utilisÃ© Ã  nouveau pour s'exÃ©cuter lui-mÃªme toutes les 0,01s.

Photo de PhÃ©nomÃ¨ne
-----------------------

.. image:: img/image278.jpeg
   :align: center



