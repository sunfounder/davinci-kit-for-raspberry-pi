.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder d√©di√©e aux passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, d'Arduino et d'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour d√©velopper vos comp√©tences.
    - **Aper√ßus exclusifs** : Profitez d'un acc√®s anticip√© aux annonces de nouveaux produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de remises exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des concours et √† des promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.1.4 Afficheur 7 segments
=============================

Introduction
---------------

Essayons de piloter un afficheur √† 7 segments pour afficher des chiffres de 0 √† 9 ainsi que les lettres de A √† F.

Composants
------------

.. image:: img/list_7_segment.png

Principe
-----------

**Afficheur 7 segments**

Un afficheur √† 7 segments est un composant en forme de ¬´ 8 ¬ª qui regroupe 7 LED. 
Chaque LED est appel√©e un segment et, lorsqu'elle est activ√©e, un segment forme 
une partie d'un chiffre ou d'une lettre √† afficher.

Il existe deux types de connexions de broches : Cathode Commune (CC) et Anode Commune (CA). 
Comme son nom l'indique, un afficheur CC a toutes les cathodes des 7 LED connect√©es ensemble, 
tandis qu'un afficheur CA a toutes les anodes connect√©es ensemble. Dans ce kit, nous utilisons 
la version Cathode Commune (CC).

.. image:: img/image70.jpeg
   :width: 3.89514in
   :height: 3.32222in
   :align: center

Chaque LED de l'afficheur est associ√©e √† un segment √©tiquet√© de "a" √† "g", repr√©sentant 
chacune des LED individuelles. L'autre broche est la broche commune pour toutes les LED. 
En polarisant correctement les broches des segments LED dans un ordre sp√©cifique, certains 
segments s'allument et d'autres restent √©teints, permettant ainsi d'afficher le caract√®re 
correspondant.

**Codes d'affichage**

Pour mieux comprendre comment les afficheurs 7 segments (Cathode Commune) affichent les 
chiffres et lettres, nous avons cr√©√© le tableau suivant. Les chiffres repr√©sentent les 
nombres 0-F affich√©s sur l'afficheur 7 segments ; (DP) GFEDCBA indique les segments LED 
correspondants configur√©s en 0 ou 1. Par exemple, 00111111 signifie que DP et G sont √† 0, 
tandis que les autres segments sont √† 1. Ainsi, le chiffre 0 est affich√© sur l'afficheur 7 
segments, tandis que le code HEX correspond au num√©ro hexad√©cimal.

.. image:: img/common_cathode.png

**74HC595**

Le 74HC595 est compos√© d'un registre √† d√©calage 8 bits et d'un registre de stockage avec 
des sorties parall√®les √† trois √©tats. Il convertit les entr√©es s√©rie en sorties parall√®les, 
ce qui permet d'√©conomiser les ports E/S d'un microcontr√¥leur.

Lorsque MR (broche 10) est au niveau haut et OE (broche 13) au niveau bas, les donn√©es sont 
saisies sur le front montant de SHcp et transf√©r√©es au registre de m√©moire via le front 
montant de SHcp. Si les deux horloges sont connect√©es ensemble, le registre de d√©calage 
a toujours une impulsion d'avance sur le registre de m√©moire. Il y a une broche d'entr√©e 
de d√©calage s√©rie (Ds), une broche de sortie s√©rie (Q) et un bouton de r√©initialisation 
asynchrone (niveau bas) dans le registre de m√©moire. Le registre de m√©moire fournit une 
sortie parall√®le 8 bits avec trois √©tats. Lorsque OE est activ√© (niveau bas), les donn√©es 
du registre de m√©moire sont envoy√©es au bus.

.. image:: img/74hc595_sche.png
   :width: 400
   :align: center

**Broches du 74HC595 et leurs fonctions** :

* **Q0-Q7** : Broches de sortie parall√®le 8 bits, capables de contr√¥ler directement 8 LED ou 8 broches d'un afficheur √† 7 segments.

* **Q7‚Äô** : Broche de sortie s√©rie, connect√©e au DS d'un autre 74HC595 pour connecter plusieurs 74HC595 en s√©rie.

* **MR** : Broche de r√©initialisation, active √† bas niveau.

* **SHcp** : Entr√©e d'horloge du registre √† d√©calage. Sur le front montant, les donn√©es du registre de d√©calage se d√©placent d'un bit.

* **STcp** : Entr√©e d'horloge du registre de stockage. Sur le front montant, les donn√©es du registre de d√©calage sont transf√©r√©es au registre de stockage.

* **CE** : Broche d'activation de sortie, active √† bas niveau.
* **DS** : Broche d'entr√©e de donn√©es s√©rie.
* **VCC** : Tension d'alimentation positive.
* **GND** : Masse.

Sch√©ma de c√¢blage
---------------------

Connectez la broche ST_CP du 74HC595 au GPIO18 du Raspberry Pi, SH_CP au GPIO27, et DS 
au GPIO17. Reliez les ports de sortie parall√®les aux 8 segments de l'afficheur 7 segments. 
Entrez les donn√©es dans la broche DS lorsque SH_CP (l'horloge d'entr√©e du registre de 
d√©calage) est sur le front montant, et transf√©rez-les dans le registre de m√©moire lorsque 
ST_CP (l'horloge d'entr√©e du registre de m√©moire) est sur le front montant. Vous pouvez 
ensuite contr√¥ler les √©tats de SH_CP et ST_CP via les GPIO du Raspberry Pi pour convertir 
les donn√©es d'entr√©e s√©rie en donn√©es de sortie parall√®le, √©conomisant ainsi les GPIO du 
Raspberry Pi tout en pilotant l'afficheur.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: img/schematic_7_segment.png
    :width: 800

Proc√©dures exp√©rimentales
------------------------------

**√âtape 1** : Construisez le circuit.

.. image:: img/image73.png
    :width: 800


**√âtape 2** : Acc√©dez au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.1.4/

**√âtape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.4_7-Segment.c -lwiringPi

**√âtape 4** : Ex√©cutez le fichier compil√©.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, vous verrez l'afficheur 7 segments afficher les chiffres de 0 √† 9 et les lettres de A √† F.

.. note::

    Si cela ne fonctionne pas apr√®s ex√©cution, ou si un message d'erreur appara√Æt : "wiringPi.h: Aucun fichier ou r√©pertoire de ce type", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define   SDI   0   // entr√©e de donn√©es s√©rie
    #define   RCLK  1   // entr√©e d'horloge de la m√©moire (STCP)
    #define   SRCLK 2   // entr√©e d'horloge du registre √† d√©calage (SHCP)
    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

    void hc595_shift(unsigned char dat){
        int i;
        for(i=0;i<8;i++){
            digitalWrite(SDI, 0x80 & (dat << i));
            digitalWrite(SRCLK, 1);
            delay(1);
            digitalWrite(SRCLK, 0);
        }
            digitalWrite(RCLK, 1);
            delay(1);
            digitalWrite(RCLK, 0);
    }

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ // lorsqu'initialisation du wiring √©choue, affiche un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        init();
        while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }
        return 0;
    }

**Explication du code**

unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
Tableau des codes des segments de 0 √† F en hexad√©cimal (Cathode commune).

.. code-block:: c

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT); 
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

D√©finir les trois broches SDI, RCLK, et SRCLK en tant que sorties, avec un √©tat initial √† 0.



    void hc595_shift(unsigned char dat){}

Attribuer une valeur de 8 bits au registre √† d√©calage du 74HC595.

.. code-block:: c

    digitalWrite(SDI, 0x80 & (dat << i));

Attribuer la donn√©e **dat** √† SDI (DS) bit √† bit. Si dat = 0x3f (0011 1111), lorsque i = 2, 0x3f se d√©cale de 2 bits vers la gauche (<<). 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, ce qui est vrai.

.. code-block:: c

    digitalWrite(SRCLK, 1);

La valeur initiale de SRCLK est 0, ici elle passe √† 1 pour g√©n√©rer une impulsion montante, ce qui d√©place les donn√©es DS dans le registre de d√©calage.

.. code-block:: c
        
    digitalWrite(RCLK, 1);

La valeur initiale de RCLK est 0, ici elle passe √† 1 pour g√©n√©rer une impulsion montante, ce qui d√©place les donn√©es du registre de d√©calage vers le registre de stockage.

.. code-block:: c

    while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }

Dans cette boucle for, nous utilisons "%1X" pour afficher **i** en tant que nombre hexad√©cimal. Utilisez **i** pour trouver le code correspondant dans le tableau SegCode[], et employez **hc595_shift()** pour transf√©rer le code correspondant dans le registre √† d√©calage du 74HC595.

