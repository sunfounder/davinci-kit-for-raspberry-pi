.. note::

    Bonjour et bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans le monde du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux annonces de nouveaux produits et √† des avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des concours et des promotions sp√©ciales lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !


1.1.2 LED RGB
=====================

Introduction
---------------

Dans cette le√ßon, nous allons apprendre √† utiliser une LED RGB pour afficher une vari√©t√© de couleurs en utilisant la programmation.

Composants
--------------

.. image:: img/list_rgb_led.png
    :align: center

Principe
--------------

**PWM**

La modulation de largeur d'impulsion (PWM) est une technique permettant d'obtenir 
des r√©sultats analogiques √† l'aide de moyens num√©riques. Le contr√¥le num√©rique est 
utilis√© pour cr√©er une onde carr√©e, un signal alternant entre marche et arr√™t. Ce 
sch√©ma marche-arr√™t peut simuler des tensions interm√©diaires entre le niveau de 
tension maximum (5 Volts) et la tension nulle (0 Volts) en modifiant la dur√©e 
pendant laquelle le signal reste actif par rapport √† celle pendant laquelle il 
reste inactif. La dur√©e d'activation est appel√©e "largeur d'impulsion". Pour obtenir 
diff√©rentes valeurs analogiques, il suffit de moduler cette largeur. Si vous r√©p√©tez 
ce sch√©ma marche-arr√™t suffisamment rapidement avec un dispositif tel qu'une LED, le 
r√©sultat sera per√ßu comme une tension constante contr√¥lant la luminosit√© de la LED.

**Cycle de service**

Le cycle de service correspond au pourcentage d'une p√©riode durant laquelle un 
signal est actif. Une p√©riode est le temps n√©cessaire pour qu'un signal effectue 
un cycle complet marche-arr√™t. La formule suivante exprime le cycle de service :

.. image:: img/image56.png
   :width: 1.16667in
   :height: 0.36458in
   :align: center

O√π **D** est le cycle de service, **T** est la dur√©e d'activation du signal, et 
**P** est la p√©riode totale du signal. Ainsi, un cycle de service de 60 % signifie 
que le signal est actif 60 % du temps et inactif 40 % du temps. La dur√©e d'activation 
pour un cycle de service de 60 % peut √™tre une fraction de seconde, une journ√©e, ou 
m√™me une semaine, selon la dur√©e de la p√©riode.

.. image:: img/image57.jpeg
   :width: 4.325in
   :height: 5.49167in
   :align: center

**LED RGB**

.. image:: img/rgb_led_sch.png
    :width: 500
    :align: center

Les trois couleurs primaires de la LED RGB peuvent se m√©langer pour produire diverses 
nuances en ajustant leur intensit√©. La luminosit√© de chaque LED peut √™tre ajust√©e √† 
l'aide du PWM. Le Raspberry Pi ne dispose que d'un seul canal pour la sortie PWM 
mat√©rielle, mais il en faut trois pour contr√¥ler la LED RGB, ce qui complique son 
contr√¥le via le PWM mat√©riel. Heureusement, la biblioth√®que softPwm simule le PWM 
par programmation. Il suffit d'inclure le fichier d'en-t√™te softPwm.h (pour les 
utilisateurs du langage C) et d'utiliser l'API fournie pour contr√¥ler facilement 
la LED RGB via une sortie PWM multicanal, permettant ainsi d'afficher une multitude 
de couleurs.

Sch√©ma de c√¢blage
-----------------------

Apr√®s avoir connect√© les broches R, G et B √† une r√©sistance limitant le courant, 
connectez-les respectivement aux GPIO17, GPIO18 et GPIO27. La broche la plus longue 
(GND) de la LED se connecte √† la masse (GND) du Raspberry Pi. Lorsque les trois 
broches re√ßoivent diff√©rentes valeurs PWM, la LED RGB affiche diff√©rentes couleurs.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: img/rgb_led_schematic.png

Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construire le circuit.

.. image:: img/image61.png
   :width: 6.59097in
   :height: 4.29722in

**√âtape 2 :** Acc√©der au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.1.2/

**√âtape 3 :** Compiler le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.2_rgbLed.c -lwiringPi

.. note::

    Lors de l'ex√©cution de la commande ¬´ gcc ¬ª, si l'option ¬´ -o ¬ª n'est pas sp√©cifi√©e, le fichier ex√©cutable sera nomm√© ¬´ a.out ¬ª.

**√âtape 4 :** Ex√©cuter le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out


Apr√®s l'ex√©cution du code, vous verrez la LED RGB afficher les couleurs rouge, 
vert, bleu, jaune, rose et cyan.

.. note::

    Si le programme ne fonctionne pas apr√®s l'ex√©cution, ou si un message d'erreur appara√Æt : ¬´ wiringPi.h: Aucun fichier ou r√©pertoire de ce type ¬ª, veuillez consulter : :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softPwm.h>
    #include <stdio.h>
    #define uchar unsigned char
    #define LedPinRed    0
    #define LedPinGreen  1
    #define LedPinBlue   2

    void ledInit(void){
        softPwmCreate(LedPinRed,  0, 100);
        softPwmCreate(LedPinGreen,0, 100);
        softPwmCreate(LedPinBlue, 0, 100);
    }

    void ledColorSet(uchar r_val, uchar g_val, uchar b_val){
        softPwmWrite(LedPinRed,   r_val);
        softPwmWrite(LedPinGreen, g_val);
        softPwmWrite(LedPinBlue,  b_val);
    }

    int main(void){

        if(wiringPiSetup() == -1){ // lorsque l'initialisation de wiring √©choue, affiche un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }

        ledInit();
        while(1){
            printf("Red\n");
            ledColorSet(0xff,0x00,0x00);   //rouge     
            delay(500);
            printf("Green\n");
            ledColorSet(0x00,0xff,0x00);   //vert
            delay(500);
            printf("Blue\n");
            ledColorSet(0x00,0x00,0xff);   //bleu
            delay(500);
            printf("Yellow\n");
            ledColorSet(0xff,0xff,0x00);   //jaune
            delay(500);
            printf("Purple\n");
            ledColorSet(0xff,0x00,0xff);   //violet
            delay(500);
            printf("Cyan\n");
            ledColorSet(0xc0,0xff,0x3e);   //cyan
            delay(500);
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    #include <softPwm.h>

Biblioth√®que utilis√©e pour impl√©menter la fonction PWM via un logiciel.

.. code-block:: c

    void ledInit(void){
        softPwmCreate(LedPinRed,  0, 100);
        softPwmCreate(LedPinGreen,0, 100);
        softPwmCreate(LedPinBlue, 0, 100);
    }

Cette fonction permet de cr√©er une broche PWM par programmation, et de d√©finir sa p√©riode entre 0x100us et 100x100us.

Le prototype de la fonction softPwmCreate(LedPinRed, 0, 100) est le suivant :

.. code-block:: c

    int softPwmCreate(int pin,int initialValue,int pwmRange);

* **Param√®tre pin :** N'importe quelle broche GPIO du Raspberry Pi peut √™tre d√©finie comme une broche PWM.
* **Param√®tre initialValue :** La largeur d'impulsion initiale est √©gale √† initialValue multipli√© par 100us.
* **Param√®tre pwmRange :** La p√©riode du PWM est √©gale √† pwmRange multipli√© par 100us.

.. code-block:: c

    void ledColorSet(uchar r_val, uchar g_val, uchar b_val){
        softPwmWrite(LedPinRed,   r_val);
        softPwmWrite(LedPinGreen, g_val);
        softPwmWrite(LedPinBlue,  b_val);
    }

Cette fonction sert √† d√©finir les couleurs de la LED. En utilisant le syst√®me RGB, 
le param√®tre formel **r_val** repr√©sente la luminosit√© du rouge, **g_val** celle 
du vert, et **b_val** celle du bleu.

Le prototype de la fonction softPwmWrite(LedPinBlue, b_val) est le suivant :

.. code-block:: c

    void softPwmWrite (int pin, int value) ;

* **Param√®tre pin :** N'importe quelle broche GPIO du Raspberry Pi peut √™tre d√©finie comme une broche PWM.
* **Param√®tre value :** La largeur d'impulsion du PWM est √©gale √† value multipli√© par 100us. Notez que value ne peut pas d√©passer pwmRange, d√©fini pr√©c√©demment. Si value est sup√©rieur √† pwmRange, la valeur sera fix√©e √† pwmRange.

.. code-block:: c

    ledColorSet(0xff,0x00,0x00);

Appel de la fonction d√©finie pr√©c√©demment. √âcrit 0xff dans LedPinRed, 0x00 dans 
LedPinGreen et LedPinBlue. Seule la LED rouge s'allume apr√®s l'ex√©cution de ce 
code. Si vous souhaitez allumer les LED d'une autre couleur, il suffit de modifier 
les param√®tres.

