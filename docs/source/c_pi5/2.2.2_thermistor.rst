.. note::

    Bonjour, bienvenue dans la communaut√© Facebook des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 ! Plongez au c≈ìur de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et vos d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux avant-go√ªts.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et concours** : Participez √† des concours et promotions √† l'occasion des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

2.2.2 Thermistor
===================

Introduction
---------------

Tout comme une photor√©sistance peut d√©tecter la lumi√®re, une thermistance est 
un dispositif √©lectronique sensible √† la temp√©rature qui permet de r√©aliser des 
fonctions de contr√¥le de temp√©rature, comme la cr√©ation d'une alarme de surchauffe.

Composants
-------------

.. image:: img/list_2.2.2_thermistor.png


Principe
------------

Une thermistance est une r√©sistance thermosensible qui pr√©sente un changement pr√©cis 
et pr√©visible de sa r√©sistance proportionnel √† de petites variations de temp√©rature. 
L'ampleur de ce changement d√©pend de sa composition sp√©cifique. Les thermistances font 
partie d'un groupe plus large de composants passifs. Contrairement aux composants actifs, 
les dispositifs passifs ne peuvent pas fournir de gain de puissance ou d'amplification 
dans un circuit.

La thermistance est un √©l√©ment sensible, et elle existe sous deux formes : Coefficient de 
Temp√©rature N√©gatif (CTN) et Coefficient de Temp√©rature Positif (CTP), aussi connus sous 
les abr√©viations CTN et CTP. Sa r√©sistance varie de mani√®re significative avec la temp√©rature. 
La r√©sistance de la thermistance CTP augmente avec la temp√©rature, tandis que celle de la 
CTN fait l'inverse. Dans cette exp√©rience, nous utilisons une CTN.

.. image:: img/image325.png


Le principe est que la r√©sistance de la thermistance CTN varie en fonction de la 
temp√©rature de l'environnement ext√©rieur. Elle d√©tecte la temp√©rature en temps r√©el 
de l'environnement. Lorsque la temp√©rature augmente, la r√©sistance de la thermistance 
diminue. Ensuite, les donn√©es de tension sont converties en quantit√©s num√©riques via 
l'adaptateur A/D. La temp√©rature, en degr√©s Celsius ou Fahrenheit, est ensuite affich√©e 
gr√¢ce √† la programmation.

Dans cette exp√©rience, une thermistance et une r√©sistance de rappel de 10k sont utilis√©es. 
Chaque thermistance a une r√©sistance nominale. Ici, elle est de 10k ohms, mesur√©e √† 25 
degr√©s Celsius.

Voici la relation entre la r√©sistance et la temp√©rature :

R\ :sub:`T` =R\ :sub:`N` exp\ :sup:`B(1/TK ‚Äì 1/TN)`

**R\ T** est la r√©sistance de la thermistance CTN √† la temp√©rature **T\ K**.

**R\ N** est la r√©sistance de la thermistance CTN √† la temp√©rature nominale 
**T\ N**. Ici, la valeur de **R\ N** est de 10k.

**T\ K** est la temp√©rature en Kelvin, avec une unit√© en K. Ici, la valeur de 
**T\ K** est 273,15 + degr√©s Celsius.

**T\ N** est une temp√©rature nominale en Kelvin ; l'unit√© est √©galement K. Ici, 
la valeur de **T\ N** est 273,15 + 25.

Et **B**\ (b√™ta), la constante mat√©rielle de la thermistance CTN, est √©galement 
appel√©e indice de sensibilit√© thermique, avec une valeur num√©rique de 3950.

**exp** est l'abr√©viation d'exponentielle, et le nombre de base **e** est un 
nombre naturel qui vaut environ 2,7.

Convertissez cette formule
T\ :sub:`K`\ =1/(ln(R\ :sub:`T`/R\ :sub:`N`)/B+1/T\ :sub:`N`) pour obtenir la 
temp√©rature en Kelvin, √† laquelle il faut soustraire 273,15 pour obtenir les degr√©s Celsius.

Cette relation est une formule empirique. Elle est pr√©cise uniquement lorsque la 
temp√©rature et la r√©sistance se situent dans une plage effective.

Sch√©ma de c√¢blage
---------------------

.. image:: img/image323.png


.. image:: img/image324.png


Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/image202.png
    :width: 800


**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.2/

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.2_Thermistor.c -lwiringPi -lm

.. note::
    -lm permet de charger la biblioth√®que math√©matique. Ne l'omettez pas, sinon vous obtiendrez une erreur.

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le programme ex√©cut√©, la thermistance d√©tecte la temp√©rature ambiante, qui 
sera affich√©e √† l'√©cran √† la fin du calcul du programme.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution, ou s'il y a un message d'erreur indiquant : "wiringPi.h: Aucun fichier ou r√©pertoire de ce type", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <math.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Bit de d√©marrage
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Mode entr√©e unique
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // Impair
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // S√©lectionner
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        unsigned char analogVal;
        double Vr, Rt, temp, cel, Fah;
        if(wiringPiSetup() == -1){ // En cas d'√©chec d'initialisation de wiringPi, affichez un message √† l'√©cran
            printf("setup wiringPi failed !");
            return 1;
        }
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            Vr = 5 * (double)(analogVal) / 255;
            Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
            temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
            cel = temp - 273.15;
            Fah = cel * 1.8 +32;
            printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);
            delay(100);
        }
        return 0;
    }

**Explication du Code**

.. code-block:: c

    #include <math.h>

Il s'agit d'une biblioth√®que math√©matique en C qui d√©clare un ensemble de fonctions permettant de r√©aliser des op√©rations et des transformations math√©matiques courantes.

.. code-block:: c

    analogVal = get_ADC_Result(0);

Cette fonction est utilis√©e pour lire la valeur de la thermistance.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
    cel = temp - 273.15;
    Fah = cel * 1.8 +32;
    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Ces calculs convertissent les valeurs de la thermistance en degr√©s Celsius.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));

Ces deux lignes de code calculent la r√©partition de la tension avec la valeur 
analogique lue afin d'obtenir Rt (r√©sistance de la thermistance).

.. code-block:: c

    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));

Ce code se r√©f√®re √† l'int√©gration de Rt dans la formule
**T\ K\ =1/(ln(R\ T/R\ N)/B+1/T\ N)** pour obtenir la temp√©rature en Kelvin.

.. code-block:: c

    temp = temp - 273.15;

Conversion de la temp√©rature en Kelvin en degr√©s Celsius.

.. code-block:: c

    Fah = cel * 1.8 +32;

Conversion des degr√©s Celsius en Fahrenheit.

.. code-block:: c

    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Affiche les degr√©s Celsius, Fahrenheit et leurs unit√©s √† l'√©cran.
