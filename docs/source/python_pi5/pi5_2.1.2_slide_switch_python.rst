.. note::

    춰Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum칠rgete en el mundo de Raspberry Pi, Arduino y ESP32 junto a otros entusiastas.

    **쯇or qu칠 unirse?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf칤os t칠cnicos con ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Avances Exclusivos**: Accede anticipadamente a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos Especiales**: Aprovecha descuentos exclusivos en nuestros productos m치s recientes.
    - **Promociones Festivas y Sorteos**: Participa en sorteos y promociones especiales.

    游녤 쯃isto para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 칰nete hoy mismo.

.. _2.1.2_py_pi5:

2.1.2 Interruptor Deslizante
==============================

Introducci칩n
----------------

En este proyecto, aprenderemos a utilizar un interruptor deslizante. 
Normalmente, el interruptor deslizante se suelda en una PCB como interruptor 
de encendido, pero aqu칤 lo insertamos en la protoboard para mostrar su 
funcionamiento, aunque puede que no quede ajustado.

Componentes Necesarios
--------------------------

En este proyecto, necesitamos los siguientes componentes. 

.. image:: ../python_pi5/img/2.1.2_slide_switch_list.png

.. raw:: html

   <br/>

Diagrama de Conexi칩n
------------------------

Conecta el pin central del interruptor deslizante al GPIO17, y dos LEDs a los 
pines GPIO22 y GPIO27 respectivamente. Cuando deslizas el interruptor, podr치s 
ver que los dos LEDs se encienden alternadamente.

.. image:: ../python_pi5/img/2.1.2_slide_switch_schematic_1.png


.. image:: ../python_pi5/img/2.1.2_slide_switch_schematic_2.png


Procedimientos del Experimento
-----------------------------------

**Paso 1:** Monta el circuito.

.. image:: ../python_pi5/img/2.1.2_slide_switch_circuit.png

**Paso 2**: Ingresa al directorio del c칩digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**Paso 3**: Ejecuta el c칩digo.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.2_Slider_zero.py

Mientras el c칩digo se est치 ejecutando, si conectas el interruptor hacia 
la izquierda, el LED amarillo se encender치; hacia la derecha, se encender치 el LED rojo.

.. warning::

    Si aparece el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulta :ref:`faq_soc` 

**C칩digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c칩digo a continuaci칩n. Antes de eso, aseg칰rate de estar en la ruta del c칩digo fuente, como ``davinci-kit-for-raspberry-pi/python-pi5``. Despu칠s de modificar el c칩digo, puedes ejecutarlo directamente para ver el efecto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button  # Importa las clases LED y Button para el control de GPIO
   from time import sleep  # Importa la funci칩n sleep para a침adir retardos

   # Inicializa el microinterruptor en el pin GPIO 17 con la resistencia de pull-up deshabilitada
   micro_switch = Button(17, pull_up=False)
   # Inicializa LED1 en el pin GPIO 22
   led1 = LED(22)
   # Inicializa LED2 en el pin GPIO 27
   led2 = LED(27)

   try:
       # Bucle principal para controlar el estado de los LEDs basado en el estado del microinterruptor
       while True:
           if micro_switch.is_pressed:  # Verifica si el microinterruptor est치 presionado
               print('    LED1 ON    ')  # Muestra un mensaje de estado
               led1.on()   # Enciende LED1
               led2.off()  # Apaga LED2
           else:  # Si el microinterruptor no est치 presionado
               print('    LED2 ON    ')  # Muestra un mensaje de estado
               led1.off()  # Apaga LED1
               led2.on()   # Enciende LED2

           sleep(0.5)  # Espera 0.5 segundos antes de volver a verificar el estado del interruptor

   except KeyboardInterrupt:
       # Maneja una interrupci칩n de teclado (Ctrl+C) para una salida limpia del bucle
       pass
   

**Explicaci칩n del C칩digo**

#. Esta l칤nea configura el script para ejecutarse con Python 3. Importa las clases ``LED`` y ``Button`` de la librer칤a ``gpiozero`` para el control de dispositivos GPIO, y ``sleep`` de ``time`` para a침adir retardos.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button  # Importa las clases LED y Button para el control de GPIO
       from time import sleep  # Importa la funci칩n sleep para a침adir retardos

#. Inicializa un microinterruptor conectado al pin GPIO 17 con la resistencia de pull-up deshabilitada, y dos LEDs conectados a los pines GPIO 22 y 27.

   .. code-block:: python

       # Inicializa el microinterruptor en el pin GPIO 17 con la resistencia de pull-up deshabilitada
       micro_switch = Button(17, pull_up=False)
       # Inicializa LED1 en el pin GPIO 22
       led1 = LED(22)
       # Inicializa LED2 en el pin GPIO 27
       led2 = LED(27)

#. El bucle principal verifica el estado del microinterruptor. Si est치 presionado, se enciende LED1 y se apaga LED2; si no est치 presionado, se apaga LED1 y se enciende LED2. El bucle se repite cada 0.5 segundos. Captura una interrupci칩n de teclado (como Ctrl+C) para permitir una terminaci칩n ordenada del script.

   .. code-block:: python

       try:
           # Bucle principal para controlar el estado de los LEDs basado en el estado del microinterruptor
           while True:
               if micro_switch.is_pressed:  # Verifica si el microinterruptor est치 presionado
               print('    LED1 ON    ')  # Muestra un mensaje de estado
                   led1.on()   # Enciende LED1
                   led2.off()  # Apaga LED2
               else:  # Si el microinterruptor no est치 presionado
               print('    LED2 ON    ')  # Muestra un mensaje de estado
                   led1.off()  # Apaga LED1
                   led2.on()   # Enciende LED2

               sleep(0.5)  # Espera 0.5 segundos antes de volver a verificar el estado del interruptor

       except KeyboardInterrupt:
           # Maneja una interrupci칩n de teclado (Ctrl+C) para una salida limpia del bucle
           pass
       
