.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _py_temp:

2.2.2 Thermistor
================

Einf√ºhrung
------------

Genau wie der Fotowiderstand Licht erfassen kann, ist der Thermistor ein temperaturempfindliches elektronisches Ger√§t, mit dem Funktionen der Temperaturregelung wie z. B. ein W√§rmealarm realisiert werden k√∂nnen.

Komponenten
----------------

.. image:: media/list_2.2.2_thermistor.png


Prinzip
---------

Ein Thermistor ist ein w√§rmeempfindlicher Widerstand, der eine pr√§zise und vorhersagbare Widerstands√§nderung proportional zu kleinen Temperatur√§nderungen aufweist. Wie sehr sich sein Widerstand √§ndert, h√§ngt von seiner einzigartigen Zusammensetzung ab. Thermistoren sind Teile einer gr√∂√üeren Gruppe passiver Komponenten. Und im Gegensatz zu ihren Gegenst√ºcken mit aktiven Komponenten k√∂nnen passive Ger√§te keine Leistungsverst√§rkung oder Verst√§rkung f√ºr eine Schaltung bereitstellen.

Der Thermistor ist ein empfindliches Element und es gibt zwei Arten: den negativen Temperaturkoeffizienten (NTC) und den positiven Temperaturkoeffizienten (PTC), auch bekannt als NTC und PTC. Sein Widerstand variiert erheblich mit der Temperatur. Der Widerstand des PTC-Thermistors steigt mit der Temperatur, w√§hrend der Zustand des NTC dem ersteren entgegengesetzt ist. In diesem Experiment verwenden wir NTC.

.. image:: media/image325.png


Das Prinzip ist, dass sich der Widerstand des NTC-Thermistors mit der Temperatur der √§u√üeren Umgebung √§ndert. Es erfasst die Echtzeit-Temperatur der Umgebung. Wenn die Temperatur h√∂her wird, nimmt der Widerstand des Thermistors ab. Anschlie√üend werden die Spannungsdaten vom A / D-Adapter in digitale Gr√∂√üen umgewandelt. Die Temperatur in Celsius oder Fahrenheit wird √ºber die Programmierung ausgegeben.

In diesem Experiment werden ein Thermistor und ein 10k-Pull-up-Widerstand verwendet. Jeder Thermistor hat einen normalen Widerstand. Hier sind es 10 kOhm, die unter 25 Grad Celsius gemessen werden.

Hier ist die Beziehung zwischen dem Widerstand und der Temperatur:

R\ :sub:`T` =R\ :sub:`N` exp\ :sup:`B(1/TK ‚Äì 1/TN)`

**R\ T** ist der Widerstand des NTC-Thermistors bei einer Temperatur von
**T\ K**.

**R\ N** ist der Widerstand des NTC-Thermistors unter der Nenntemperatur **T\ N**. 
Hier betr√§gt der numerische Wert von **R\ N** 10k.

**T\ K** ist eine Kelvin-Temperatur und die Einheit ist K. 
Hier betr√§gt der numerische Wert von **T\ K** 273.15 + Grad Celsius.

**T\ N** ist eine Kelvin-Nenntemperatur; Das Ger√§t ist auch K. 
Hier betr√§gt der numerische Wert von **T\ N** 273.15+25.

Und **B**\ (beta), die Materialkonstante des NTC-Thermistors, 
wird auch als W√§rmeempfindlichkeitsindex mit einem numerischen Wert von 3950 bezeichnet.

**exp** ist die Abk√ºrzung f√ºr exponentiell, 
und die Basisnummer ist eine nat√ºrliche Nummer und entspricht ungef√§hr 2.7.

Konvertieren Sie diese Formel
T\ :sub:`K`\ =1/(ln(R\ :sub:`T`/R\ :sub:`N`)/B+1/T\ :sub:`N`) um eine Kelvin-Temperatur zu erhalten, 
die minus 273.15 Grad Celsius entspricht.

Diese Beziehung ist eine empirische Formel. Sie ist nur dann genau, wenn Temperatur und Widerstand im effektiven Bereich liegen.

Schematische Darstellung
---------------------------------

.. image:: media/image323.png


.. image:: media/image324.png


Experimentelle Verfahren
------------------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: media/image202.png
    :width: 800



F√ºr Benutzer in C-Sprache
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block::

    cd /home/pi/davinci-kit-for-raspberry-pi/c/2.2.2/

Schritt 3: Kompilieren Sie die Kode.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.2_Thermistor.c -lwiringPi -lm

.. note::
    -lm dient zum Laden der Bibliotheksmathematik. Nicht weglassen, sonst wird ein Fehler gemacht.

Schritt 4: F√ºhren Sie die ausf√ºhrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

W√§hrend die Kode ausgef√ºhrt wird, erkennt der Thermistor die Umgebungstemperatur, 
die nach Abschluss der Programmberechnung auf dem Bildschirm angezeigt wird.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <math.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);

        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        unsigned char analogVal;
        double Vr, Rt, temp, cel, Fah;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print messageto screen
            printf("setup wiringPi failed !");
            return 1;
        }
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            Vr = 5 * (double)(analogVal) / 255;
            Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
            temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
            cel = temp - 273.15;
            Fah = cel * 1.8 +32;
            printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);
            delay(100);
        }
        return 0;
    }

**Code Erkl√§rung**

.. code-block:: c

    #include <math.h>

Es gibt eine C-Numerik-Bibliothek, die eine Reihe von Funktionen deklariert, 
um allgemeine mathematische Operationen und Transformationen zu berechnen.

.. code-block:: c

    analogVal = get_ADC_Result(0);

Mit dieser Funktion wird der Wert des Thermistors abgelesen.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));
    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));
    cel = temp - 273.15;
    Fah = cel * 1.8 +32;
    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Diese Berechnungen wandeln die Thermistorwerte in Celsiuswerte um.

.. code-block:: c

    Vr = 5 * (double)(analogVal) / 255;
    Rt = 10000 * (double)(Vr) / (5 - (double)(Vr));

Diese beiden Kodezeilen berechnen die Spannungsverteilung mit dem analogen Lesewert, 
um Rt (Widerstand des Thermistors) zu erhalten.

.. code-block:: c

    temp = 1 / (((log(Rt/10000)) / 3950)+(1 / (273.15 + 25)));

Diese Kode bezieht sich auf das Einstecken von Rt in die Formel
**T\ K\ =1/(ln(R\ T/R\ N)/B+1/T\ N)** ,um die Kelvin-Temperatur zu erhalten.

.. code-block:: c

    temp = temp - 273.15;

Wandeln Sie die Kelvin-Temperatur in Grad Celsius um.

.. code-block:: c

    Fah = cel * 1.8 +32;

Konvertieren Sie Grad Celsius in Fahrenheit.
    
.. code-block:: c

    printf("Celsius: %.2f C  Fahrenheit: %.2f F\n", cel, Fah);

Drucken Sie Celsius, Fahrenheit und ihre Einheiten auf dem Display.

F√ºr Python-Sprachbenutzer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block::

    cd /home/pi/davinci-kit-for-raspberry-pi/python/

Schritt 3: F√ºhren Sie die ausf√ºhrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.2_Thermistor.py

W√§hrend die Kode ausgef√ºhrt wird, erkennt der Thermistor die Umgebungstemperatur, die nach Abschluss der Programmberechnung auf dem Bildschirm angezeigt wird.

**Code**

.. note::

    Sie k√∂nnen den folgenden Code **√Ñndern/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen** . Zuvor m√ºssen Sie jedoch zu einem Quellcodepfad wie ``davinci-kit-for-raspberry-pi/python`` gehen.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    def init():
        ADC0834.setup()

    def loop():
        while True:
            analogVal = ADC0834.getResult()
            Vr = 5 * float(analogVal) / 255
            Rt = 10000 * Vr / (5 - Vr)
            temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
            Cel = temp - 273.15
            Fah = Cel * 1.8 + 32
            print ('Celsius: %.2f C  Fahrenheit: %.2f F' % (Cel, Fah))
            time.sleep(0.2)

    if __name__ == '__main__':
        init()
        try:
            loop()
        except KeyboardInterrupt:
            ADC0834.destroy()

**Code Erkl√§rung**

.. code-block:: python

    import math

Es gibt eine numerische Bibliothek, die eine Reihe von Funktionen deklariert, 
um allgemeine mathematische Operationen und Transformationen zu berechnen.

.. code-block:: python

    analogVal = ADC0834.getResult()

Mit dieser Funktion wird der Wert des Thermistors abgelesen.

.. code-block:: python

    Vr = 5 * float(analogVal) / 255
    Rt = 10000 * Vr / (5 - Vr)
    temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
    Cel = temp - 273.15
    Fah = Cel * 1.8 + 32
    print ('Celsius: %.2f ¬∞C  Fahrenheit: %.2f ‚Ñâ' % (Cel, Fah))

Diese Berechnungen wandeln die Thermistorwerte in Grad Celsius und Fahrenheit um.



.. code-block:: python

    Vr = 5 * float(analogVal) / 255
    Rt = 10000 * Vr / (5 - Vr)

Diese beiden Kodezeilen berechnen die Spannungsverteilung mit dem analogen Lesewert, 
um Rt (Widerstand des Thermistors) zu erhalten.

.. code-block:: python

    temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))

Diese Kode bezieht sich auf das Einstecken von Rt in die Formel
**T\ K\ =1/(ln(R\ T/R\ N)/B+1/T\ N)** ,um die Kelvin-Temperatur zu erhalten.

.. code-block:: python

    temp = temp - 273.15

Wandeln Sie die Kelvin-Temperatur in Grad Celsius um.

.. code-block:: python

    Fah = Cel * 1.8 + 32

Konvertieren Sie den Celsius-Grad in Fahrenheit-Grad.

.. code-block:: python

    print ('Celsius: %.2f ¬∞C  Fahrenheit: %.2f ‚Ñâ' % (Cel, Fah))

Drucken Sie Celsius, Fahrenheit und ihre Einheiten auf dem Display.

Ph√§nomen Bild
------------------

.. image:: media/image203.jpeg