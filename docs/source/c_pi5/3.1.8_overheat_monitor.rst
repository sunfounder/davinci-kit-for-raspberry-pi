.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **ExpertenunterstÃ¼tzung**: LÃ¶sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre FÃ¤higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie frÃ¼hzeitigen Zugang zu neuen ProduktankÃ¼ndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: GenieÃŸen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    ðŸ‘‰ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

3.1.8 Ãœberhitzungsmonitor
===========================

EinfÃ¼hrung
-------------------

MÃ¶glicherweise mÃ¶chten Sie ein ÃœberhitzungsÃ¼berwachungsgerÃ¤t herstellen, das fÃ¼r verschiedene Situationen gilt, z. B. im Werk, wenn wir einen Alarm und das rechtzeitige automatische Ausschalten der Maschine bei Ãœberhitzung des Stromkreises wÃ¼nschen. In dieser Lektion verwenden wir Thermistor, Joystick, Summer, LED und LCD, um ein intelligentes TemperaturÃ¼berwachungsgerÃ¤t zu erstellen, dessen Schwelle einstellbar ist.

Komponenten
-----------------

.. image:: ../img/list_Overheat_Monitor.png
    :align: center

.. image:: ../img/list_Overheat_Monitor2.png
    :align: center

Schematische Darstellung
--------------------------

============ ======== ======== ===
T-Karte Name physisch wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one8.png
   :width: 700
   :align: center

Experimentelle Verfahren
-----------------------------

Schritt 1: Bauen Sie die Schaltung auf.

.. image:: ../img/image258.png
   :width: 800


Schritt 2: Gehen Sie zum Ordner der Kode.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.8/

Schritt 3: Kompilieren Sie der Kode.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

Schritt 4: FÃ¼hren Sie die ausfÃ¼hrbare Datei aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

WÃ¤hrend die Kode ausgefÃ¼hrt wird, 
werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. 
Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, 
werden der Summer und die LED gestartet, um Sie zu alarmieren.


Der Joystick dient zum DrÃ¼cken, um die Hochtemperaturschwelle anzupassen. Durch Umschalten des Joystick in Richtung X-Achse und Y-Achse kann der aktuelle Hochtemperaturschwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.

**Code ErklÃ¤rung**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

Diese Funktion liest die Werte von X und Y. 
Wenn X> 200 ist, wird â€ž1â€œ zurÃ¼ckgegeben. X<50, return â€ž-1â€œ; y> 200, 
geben Sie â€ž-10â€œ zurÃ¼ck, und y<50, geben Sie â€ž10â€œ zurÃ¼ck.

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    write(0,1,str);
    intÂ len;
    Â Â lenÂ =Â strlen(str);
    Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

This function is for adjusting the threshold and displaying it on the I2C LCD1602.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Lesen Sie den Analogwert des CH0 (Thermistor) von ADC0834 ab und wandeln Sie ihn dann in einen Temperaturwert um.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

WÃ¤hrend die Kode ausgefÃ¼hrt wird, werden die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, 
werden der Summer und die LED gestartet, um Sie zu alarmieren.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

Die Funktion ``main()`` enthÃ¤lt den gesamten Programmablauf wie folgt:

1. Wenn das Programm startet, ist der Anfangswert der Stufe 0, und die aktuelle Temperatur und der Hochtemperaturschwellenwert 40 werden auf dem I2C LCD1602 angezeigt. Wenn die aktuelle Temperatur grÃ¶ÃŸer als der Schwellenwert ist, werden der Summer und die LED gestartet, um Sie zu alarmieren.

#. DrÃ¼cken Sie den Joystick, und die Stufe ist 1, und Sie kÃ¶nnen die Hochtemperaturschwelle einstellen. Durch Umschalten des Joysticks in Richtung X-Achse und Y-Achse kann der aktuelle Schwellenwert angepasst (nach oben oder unten gedreht) werden. DrÃ¼cken Sie den Joystick erneut, um den Schwellenwert auf den Anfangswert zurÃ¼ckzusetzen.
