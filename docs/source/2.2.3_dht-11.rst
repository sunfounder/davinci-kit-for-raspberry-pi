.. note:: 

    Ciao, benvenuto nella Community di appassionati SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino e ESP32 insieme ad altri appassionati.

    **Perch√© Unirsi?**

    - **Supporto Esperto**: Risolvi problematiche post-vendita e sfide tecniche grazie all‚Äôaiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Accedi in anteprima agli annunci di nuovi prodotti.
    - **Sconti Speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a omaggi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti subito!

2.2.3 DHT-11
=============

Introduzione
-------------

Il sensore digitale di temperatura e umidit√† DHT11 √® un sensore composito che 
fornisce un'uscita digitale calibrata per temperatura e umidit√†. Grazie all'uso 
di moduli digitali dedicati alla raccolta dei dati e alla tecnologia di 
rilevamento della temperatura e dell'umidit√†, questo sensore garantisce elevata 
affidabilit√† e ottima stabilit√†.

Il DHT11 integra un sensore di umidit√† resistivo e un sensore di temperatura NTC, 
connessi a un microcontrollore a 8 bit ad alte prestazioni.

Componenti
-------------

.. image:: img/list_2.2.3_dht-11.png


Principio
------------

Il DHT11 √® un sensore digitale di base, ultra economico, per rilevare 
temperatura e umidit√†. Utilizza un sensore capacitivo per l‚Äôumidit√† e 
un termistore per misurare l‚Äôaria circostante, generando un segnale 
digitale sul pin dati (non sono necessari pin di ingresso analogici).

.. image:: img/image205.png
    :width: 200

Il sensore dispone solo di tre pin: VCC, GND e DATA. La comunicazione inizia 
quando la linea DATA invia segnali di avvio al DHT11, che li riceve e risponde 
con un segnale di conferma. Successivamente, l'host riceve questo segnale e 
inizia a raccogliere 40 bit di dati relativi all'umidit√† e alla temperatura 
(8 bit per l'umidit√† intera + 8 bit per il decimale dell'umidit√† + 8 bit per 
la temperatura intera + 8 bit per il decimale della temperatura + 8 bit per il 
checksum). Per ulteriori informazioni, consulta il datasheet del DHT11.



Schema Circuitale
---------------------

.. image:: img/image326.png


Procedura Sperimentale
-------------------------

**Passo 1:** Costruisci il circuito.

.. image:: img/image207.png
    :width: 800



Per Utenti Linguaggio C
^^^^^^^^^^^^^^^^^^^^^^^^^

**Passo 2:** Vai alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.3/

**Passo 3:** Compila il codice.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.3_DHT.c -lwiringPi

**Passo 4:** Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Dopo aver eseguito il codice, il programma stamper√† sullo schermo la 
temperatura e l'umidit√† rilevate dal DHT11.

.. note::

    Se il programma non funziona o viene visualizzato un messaggio di errore: \"wiringPi.h: No such file or directory", consulta :ref:`Il codice C non funziona?`.

**Codice**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>

    #define maxTim 85
    #define dhtPin 0

    int dht11_dat[5] = {0,0,0,0,0};

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // Fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // abbassa il pin per 18 millisecondi
        pinMode(dhtPin, OUTPUT);
        digitalWrite(dhtPin, LOW);
        delay(18);
        // poi alzalo per 40 microsecondi
        digitalWrite(dhtPin, HIGH);
        delayMicroseconds(40); 
        // prepara la lettura del pin
        pinMode(dhtPin, INPUT);

        // rileva cambiamenti e leggi i dati
        for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);

            if (counter == 255) break;
            // ignora le prime 3 transizioni
            if ((i >= 4) && (i%2 == 0)) {
                // immagazzina ogni bit nei byte di memoria
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }
        // verifica di aver letto 40 bit (8bit x 5 ) + verifica il checksum nell'ultimo byte
        // stampa i dati se sono validi
        if ((j >= 40) && 
                (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
            Fah = dht11_dat[2] * 9. / 5. + 32;
            printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                    dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
        }
    }

    int main (void) {
        if(wiringPiSetup() == -1){ // in caso di errore nell'inizializzazione, stampa un messaggio a schermo
            printf("setup wiringPi failed !");
            return 1; 
        }
        while (1) {
            readDht11();
            delay(500); // aspetta 1 secondo per aggiornare
        }
        return 0 ;
    }

**Spiegazione del Codice**

.. code-block:: c

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // ...
    }

Questa funzione viene utilizzata per implementare la lettura dei dati dal sensore DHT11.

Generalmente, pu√≤ essere suddivisa in 3 parti:

1. Preparazione per la lettura del pin:

.. code-block:: c

    // abbassa il pin per 18 millisecondi
    pinMode(dhtPin, OUTPUT);
    digitalWrite(dhtPin, LOW);
    delay(18);
    // poi alzalo per 40 microsecondi
    digitalWrite(dhtPin, HIGH);
    delayMicroseconds(40); 
    // preparazione per la lettura del pin
    pinMode(dhtPin, INPUT);

Il flusso di comunicazione √® determinato dal timing operativo.

.. image:: img/image208.png
    :width: 800



Quando il DHT11 si avvia, il microcontrollore invia un segnale a livello 
basso, poi mantiene il segnale a livello alto per 40us. Successivamente 
inizia la rilevazione dell'ambiente esterno.

2. Lettura dei dati:

.. code-block:: c

    // rileva cambiamenti e leggi i dati  
    for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);
            if (counter == 255) break;
            // ignora le prime 3 transizioni
            if ((i >= 4) && (i%2 == 0)) {
                // inserisce ogni bit nei byte di archiviazione
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }

Il ciclo memorizza i dati rilevati nell'array dht11_dat[]. Il DHT11 
trasmette dati in blocchi da 40 bit. I primi 16 bit si riferiscono 
all'umidit√†, i 16 bit centrali alla temperatura, e gli ultimi otto 
bit sono utilizzati per la verifica. Il formato dei dati √®:

**8 bit per i dati interi dell'umidit√†** + **8 bit per i dati decimali 
dell'umidit√†** + **8 bit per i dati interi della temperatura** + 
**8 bit per i dati decimali della temperatura** + **8 bit di checksum**.

3. Stampa di Umidit√† e Temperatura.

.. code-block:: c

    // controlla se sono stati letti 40 bit (8bit x 5) + verifica il checksum nell'ultimo byte
    // stampa i dati se sono corretti
    if ((j >= 40) && 
            (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
        Fah = dht11_dat[2] * 9. / 5. + 32;
        printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
    }

Quando la memoria contiene 40 bit, verifica la validit√† dei dati tramite il 
**checksum (dht11_dat[4])**, quindi stampa la temperatura e l'umidit√†.

Ad esempio, se i dati ricevuti sono 00101011 (8-bit valore intero umidit√†) 
00000000 (8-bit valore decimale umidit√†) 00111100 (8-bit valore intero 
temperatura) 00000000 (8-bit valore decimale temperatura) 01100111 (checksum)

**Calcolo:**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Il risultato finale √® uguale al dato del checksum, quindi i dati ricevuti sono corretti:

Umidit√† = 43%, Temperatura = 60¬∞C.

Se il risultato non √® uguale al checksum, la trasmissione non √® valida e i dati vengono ricevuti di nuovo.

Per Utenti Python
^^^^^^^^^^^^^^^^^^^^

**Passo 2:** Vai alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**Passo 3:** Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Dopo l'esecuzione del codice, il programma stamper√† a schermo la temperatura 
e l'umidit√† rilevate dal DHT11.

**Codice**

.. note::

    Puoi **Modificare/Reimpostare/Copiare/Eseguire/Fermare** il codice qui sotto. Ma prima, assicurati di accedere al percorso del codice sorgente, ad esempio ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    dhtPin = 17

    GPIO.setmode(GPIO.BCM)

    MAX_UNCHANGE_COUNT = 100

    STATE_INIT_PULL_DOWN = 1
    STATE_INIT_PULL_UP = 2
    STATE_DATA_FIRST_PULL_DOWN = 3
    STATE_DATA_PULL_UP = 4
    STATE_DATA_PULL_DOWN = 5

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)

        unchanged_count = 0
        last = -1
        data = []
        while True:
            current = GPIO.input(dhtPin)
            data.append(current)
            if last != current:
                unchanged_count = 0
                last = current
            else:
                unchanged_count += 1
                if unchanged_count > MAX_UNCHANGE_COUNT:
                    break

        state = STATE_INIT_PULL_DOWN

        lengths = []
        current_length = 0

        for current in data:
            current_length += 1

            if state == STATE_INIT_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_INIT_PULL_UP
                else:
                    continue
            if state == STATE_INIT_PULL_UP:
                if current == GPIO.HIGH:
                    state = STATE_DATA_FIRST_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_FIRST_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_DATA_PULL_UP
                else:
                    continue
            if state == STATE_DATA_PULL_UP:
                if current == GPIO.HIGH:
                    current_length = 0
                    state = STATE_DATA_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_PULL_DOWN:
                if current == GPIO.LOW:
                    lengths.append(current_length)
                    state = STATE_DATA_PULL_UP
                else:
                    continue
        if len(lengths) != 40:
            #print ("Data not good, skip")
            return False

        shortest_pull_up = min(lengths)
        longest_pull_up = max(lengths)
        halfway = (longest_pull_up + shortest_pull_up) / 2
        bits = []
        the_bytes = []
        byte = 0

        for length in lengths:
            bit = 0
            if length > halfway:
                bit = 1
            bits.append(bit)
        #print ("bits: %s, length: %d" % (bits, len(bits)))
        for i in range(0, len(bits)):
            byte = byte << 1
            if (bits[i]):
                byte = byte | 1
            else:
                byte = byte | 0
            if ((i + 1) % 8 == 0):
                the_bytes.append(byte)
                byte = 0
        #print (the_bytes)
        checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
        if the_bytes[4] != checksum:
            #print ("Data not good, skip")
            return False

        return the_bytes[0], the_bytes[2]

    def main():

        while True:
            result = readDht11()
            if result:
                humidity, temperature = result
                print ("humidity: %s %%,  Temperature: %s C`" % (humidity, temperature))
            time.sleep(1)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy() 

**Spiegazione del Codice**

.. code-block:: python

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)
        unchanged_count = 0
        last = -1
        data = []
        #...

Questa funzione viene utilizzata per implementare le funzioni del DHT11. 
Memorizza i dati rilevati nell'array `the_bytes[]`. Il DHT11 trasmette 
dati in blocchi da 40 bit. I primi 16 bit si riferiscono all'umidit√†, i 
16 bit centrali alla temperatura e gli ultimi otto bit sono usati per la 
verifica. Il formato dei dati √®:

**8 bit per i dati interi dell'umidit√†** +\ **8 bit per i dati decimali dell'umidit√†**
+\ **8 bit per i dati interi della temperatura** + **8 bit per i dati decimali della temperatura**
+ **8 bit di controllo**.

Quando la validit√† viene rilevata tramite il bit di controllo, la funzione 
restituisce due risultati: 1. errore; 2. umidit√† e temperatura.

.. code-block:: python

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        #print ("Dati non validi, ignora")
        return False

    return the_bytes[0], the_bytes[2]

Per esempio, se i dati ricevuti sono 00101011 (8-bit valore intero umidit√†) 
00000000 (8-bit valore decimale umidit√†) 00111100 (8-bit valore intero 
temperatura) 00000000 (8-bit valore decimale temperatura) 01100111 (bit di 
controllo)

**Calcolo:**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Se il risultato finale √® diverso dal bit di controllo, la trasmissione dei 
dati √® anomala e la funzione restituisce `False`.

Se il risultato finale √® uguale al bit di controllo, i dati ricevuti sono 
corretti e vengono restituiti `the_bytes[0]` e `the_bytes[2]`, con l'output 
"Umidit√† = 43%, Temperatura = 60¬∞C".

Immagine del Fenomeno
-----------------------

.. image:: img/image209.jpeg