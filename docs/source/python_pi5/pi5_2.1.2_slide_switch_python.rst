.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, d'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez & Partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux nouvelles annonces de produits et aux avant-go√ªts exclusifs.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions et concours festifs** : Participez √† des concours et √† des promotions sp√©ciales pour les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

.. _2.1.2_py_pi5:

2.1.2 Interrupteur √† glissi√®re
=================================

Introduction
----------------

Dans ce projet, nous allons apprendre √† utiliser un interrupteur √† glissi√®re. 
Habituellement, l'interrupteur √† glissi√®re est soud√© sur un circuit imprim√© (PCB) 
en tant qu'interrupteur d'alimentation, mais ici nous allons l'ins√©rer dans une 
plaque de prototypage (breadboard), m√™me si cela peut le rendre moins stable. 
Nous l'utiliserons sur la breadboard pour illustrer son fonctionnement.

Composants n√©cessaires
--------------------------

Pour ce projet, nous aurons besoin des composants suivants.

.. image:: ../python_pi5/img/2.1.2_slide_switch_list.png

.. raw:: html

   <br/>

Sch√©ma de circuit
--------------------

Connectez la broche centrale de l'interrupteur √† glissi√®re au GPIO17, 
et deux LEDs respectivement aux broches GPIO22 et GPIO27. Ainsi, lorsque 
vous basculez l'interrupteur, vous verrez les deux LEDs s'allumer en alternance.

.. image:: ../python_pi5/img/2.1.2_slide_switch_schematic_1.png

.. image:: ../python_pi5/img/2.1.2_slide_switch_schematic_2.png


Proc√©dure exp√©rimentale
---------------------------

**√âtape 1 :** Montez le circuit.

.. image:: ../python_pi5/img/2.1.2_slide_switch_circuit.png

**√âtape 2 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3 :** Ex√©cutez le code.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.2_Slider.py

Lorsque le code s'ex√©cute, placez l'interrupteur √† gauche : la LED jaune s'allumera ; 
placez-le √† droite : la LED rouge s'allumera.

.. warning::

    En cas d'erreur ¬´ RuntimeError: Cannot determine SOC peripheral base address ¬ª, veuillez consulter :ref:`faq_soc`.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, assurez-vous de vous rendre dans le r√©pertoire source, tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s modification, vous pouvez ex√©cuter le code pour observer le r√©sultat.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import LED, Button  # Importer les classes LED et Button pour le contr√¥le GPIO
   from time import sleep  # Importer la fonction sleep pour ajouter des d√©lais

   # Initialiser l'interrupteur micro sur la broche GPIO 17 sans r√©sistance pull-up
   micro_switch = Button(17, pull_up=False)
   # Initialiser la LED1 sur la broche GPIO 22
   led1 = LED(22)
   # Initialiser la LED2 sur la broche GPIO 27
   led2 = LED(27)

   try:
       # Boucle principale pour contr√¥ler l'√©tat des LEDs en fonction de l'√©tat de l'interrupteur
       while True:
           if micro_switch.is_pressed:  # V√©rifier si l'interrupteur est press√©
               print('    LED1 ON    ')  # Afficher le message de statut
               led1.on()   # Allumer la LED1
               led2.off()  # √âteindre la LED2
           else:  # Si l'interrupteur n'est pas press√©
               print('    LED2 ON    ')  # Afficher le message de statut
               led1.off()  # √âteindre la LED1
               led2.on()   # Allumer la LED2

           sleep(0.5)  # Attendre 0,5 seconde avant de v√©rifier √† nouveau l'√©tat de l'interrupteur

   except KeyboardInterrupt:
       # G√©rer une interruption clavier (Ctrl+C) pour une sortie propre de la boucle
       pass


**Explication du code**

#. Cette ligne d√©finit le script pour √™tre ex√©cut√© avec Python 3. Elle importe les classes ``LED`` et ``Button`` de ``gpiozero`` pour le contr√¥le des appareils GPIO, ainsi que ``sleep`` du module ``time`` pour ajouter des d√©lais.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import LED, Button  # Importer les classes LED et Button pour le contr√¥le GPIO
       from time import sleep  # Importer la fonction sleep pour ajouter des d√©lais

#. Initialise un micro-interrupteur connect√© √† la broche GPIO 17 sans r√©sistance pull-up, et deux LEDs connect√©es aux broches GPIO 22 et 27.

   .. code-block:: python

       # Initialiser l'interrupteur micro sur la broche GPIO 17 sans r√©sistance pull-up
       micro_switch = Button(17, pull_up=False)
       # Initialiser la LED1 sur la broche GPIO 22
       led1 = LED(22)
       # Initialiser la LED2 sur la broche GPIO 27
       led2 = LED(27)

#. La boucle principale v√©rifie l'√©tat du micro-interrupteur. Si press√©, la LED1 s'allume et la LED2 s'√©teint ; si rel√¢ch√©, la LED1 s'√©teint et la LED2 s'allume. La boucle se r√©p√®te toutes les 0,5 seconde. Capture un ``KeyboardInterrupt`` (comme Ctrl+C) pour une terminaison propre du script.

   .. code-block:: python

       try:
       # Boucle principale pour contr√¥ler l'√©tat des LEDs en fonction de l'√©tat de l'interrupteur
       while True:
           if micro_switch.is_pressed:  # V√©rifier si l'interrupteur est press√©
               print('    LED1 ON    ')  # Afficher le message de statut
               led1.on()   # Allumer la LED1
               led2.off()  # √âteindre la LED2
           else:  # Si l'interrupteur n'est pas press√©
               print('    LED2 ON    ')  # Afficher le message de statut
               led1.off()  # √âteindre la LED1
               led2.on()   # Allumer la LED2

           sleep(0.5)  # Attendre 0,5 seconde avant de v√©rifier √† nouveau l'√©tat de l'interrupteur

       except KeyboardInterrupt:
           # G√©rer une interruption clavier (Ctrl+C) pour une sortie propre de la boucle
           pass
