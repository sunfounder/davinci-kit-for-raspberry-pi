.. note::

    Bonjour et bienvenue dans la communautÃ© SunFounder pour les passionnÃ©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez vos problÃ¨mes aprÃ¨s-vente et vos dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & Partager** : Ã‰changez des astuces et des tutoriels pour perfectionner vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us exclusifs.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des concours et Ã  des promotions spÃ©ciales pendant les fÃªtes.

    ğŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.8 Moniteur de surchauffe
===============================

Introduction
-------------

Vous pourriez vouloir crÃ©er un dispositif de surveillance de surchauffe pour diverses 
situations, par exemple, dans une usine, si vous souhaitez qu'une alarme se dÃ©clenche 
et que la machine s'arrÃªte automatiquement en cas de surchauffe du circuit. Dans cette 
leÃ§on, nous utiliserons une thermistance, un joystick, un buzzer, une LED et un Ã©cran 
LCD pour crÃ©er un dispositif intelligent de surveillance de la tempÃ©rature dont le seuil 
est ajustable.

Composants
----------

.. image:: img/list_Overheat_Monitor.png
    :align: center

.. image:: img/list_Overheat_Monitor2.png
    :align: center

SchÃ©ma de cÃ¢blage
--------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin15    3        22
GPIO23       Pin16    4        23
GPIO24       Pin18    5        24
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: img/Schematic_three_one8.png
   :width: 700
   :align: center

ProcÃ©dures expÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Montez le circuit.

.. image:: img/image258.png
   :alt: Overheat Monitor_bb
   :width: 800

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.8/

**Ã‰tape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.8_OverheatMonitor.c -lwiringPi -lm

**Ã‰tape 4 :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature
 **40** s'affichent sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe 
 ce seuil, le buzzer et la LED se dÃ©clenchent pour vous alerter.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur apparaÃ®t : \"wiringPi.h: Aucun fichier ou dossier de ce type Â», veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.

**Le joystick** vous permet d'ajuster le seuil de haute tempÃ©rature. En dÃ©plaÃ§ant le 
**joystick** sur l'axe X et Y, vous pouvez ajuster (augmenter ou diminuer) le seuil 
de tempÃ©rature. Appuyez Ã  nouveau sur le **joystick** pour rÃ©initialiser le seuil Ã  
sa valeur initiale.

**Explication du code**

.. code-block:: c

    intÂ get_joystick_value(){
    Â Â Â Â ucharÂ x_val;
    Â Â Â Â ucharÂ y_val;
    Â Â Â Â x_valÂ =Â get_ADC_Result(1);
    Â Â Â Â y_valÂ =Â get_ADC_Result(2);
    Â Â Â Â ifÂ (x_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ 1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(x_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ -1;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ >Â 200){
    Â Â Â Â Â Â Â Â returnÂ -10;
    Â Â Â Â }
    Â Â Â Â elseÂ if(y_valÂ <Â 50){
    Â Â Â Â Â Â Â Â returnÂ 10;
    Â Â Â Â }
    Â Â Â Â else{
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    }

Cette fonction lit les valeurs de X et Y. Si **X>200**, elle renvoie "**1**"; **X<50**, 
renvoie "**-1**"; **y>200**, renvoie "**-10**"; et **y<50**, renvoie "**10**".

.. code-block:: c

    voidÂ upper_tem_setting(){
    Â Â Â Â write(0,Â 0,Â "UpperÂ Adjust:");
    Â Â Â Â intÂ changeÂ =Â get_joystick_value();
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change;
    Â Â Â Â charÂ str[6];
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,1,str);
    Â Â Â Â intÂ len;
    Â Â Â Â lenÂ =Â strlen(str);
    Â Â Â Â write(len,1,"Â Â Â Â Â Â Â Â Â Â Â Â Â ");
    Â Â Â Â delay(100);
    }

Cette fonction permet de rÃ©gler le seuil et de l'afficher sur l'Ã©cran **I2C LCD1602**.

.. code-block:: c

    doubleÂ temperature(){
    Â Â Â Â unsignedÂ charÂ temp_value;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â temp_valueÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(temp_value)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â returnÂ cel;
    }

Lit la valeur analogique du **CH0** (thermistance) de **ADC0834** et la convertit en 
valeur de tempÃ©rature.

.. code-block:: c

    voidÂ monitoring_temp(){
    Â Â Â Â charÂ str[6];
    Â Â Â Â doubleÂ celÂ =Â temperature();
    Â Â Â Â snprintf(str,6,"%.2f",cel);
    Â Â Â Â write(0,Â 0,Â "Temp:Â ");
    Â Â Â Â write(6,Â 0,Â str);
    Â Â Â Â snprintf(str,3,"%d",upperTem);
    Â Â Â Â write(0,Â 1,Â "Upper:Â ");
    Â Â Â Â write(7,Â 1,Â str);
    Â Â Â Â delay(100);
    Â Â Â Â if(celÂ >=Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â HIGH);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â HIGH);
    Â Â Â Â }
    Â Â Â Â elseÂ if(celÂ <Â upperTem){
    Â Â Â Â Â Â Â Â digitalWrite(buzzPin,Â LOW);
    Â Â Â Â Â Â Â Â digitalWrite(LedPin,Â LOW);
    Â Â Â Â }
    }

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature 
**40** s'affichent sur **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe ce seuil, 
le buzzer et la LED se dÃ©clenchent pour vous alerter.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ lastStateÂ =1;
    Â Â Â Â intÂ stage=0;
    Â Â Â Â whileÂ (1)
    Â Â Â Â {
    Â Â Â Â Â Â Â Â intÂ currentStateÂ =Â digitalRead(Joy_BtnPin);
    Â Â Â Â Â Â Â Â if(currentState==1Â &&Â lastStateÂ ==Â 0){
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(100);
    Â Â Â Â Â Â Â Â Â Â Â Â lcd_clear();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (stage==1){
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â else{
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp();
    Â Â Â Â Â Â Â Â }
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

La fonction `main()` contient le processus global du programme comme suit :

1) Lorsque le programme dÃ©marre, la valeur initiale de **stage** est **0**, et la 
tempÃ©rature actuelle ainsi que le seuil de haute tempÃ©rature **40** s'affichent sur
 **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe ce seuil, le buzzer et la LED 
 se dÃ©clenchent pour vous alerter.

2) Appuyez sur le joystick, et **stage** passera Ã  **1**, vous permettant d'ajuster 
le seuil de haute tempÃ©rature. En dÃ©plaÃ§ant le joystick sur l'axe X et Y, vous pouvez 
ajuster (augmenter ou diminuer) le seuil actuel. Appuyez Ã  nouveau sur le joystick pour 
rÃ©initialiser le seuil Ã  sa valeur initiale.



**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python/

**Ã‰tape 3 :** ExÃ©cutez le fichier exÃ©cutable.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.8_OverheatMonitor.py

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature 
**40** s'affichent sur l'Ã©cran **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe ce 
seuil, le buzzer et la LED se dÃ©clenchent pour vous alerter.

Le **joystick** vous permet d'ajuster le seuil de haute tempÃ©rature. En dÃ©plaÃ§ant le 
**joystick** sur l'axe X et Y, vous pouvez ajuster (augmenter ou diminuer) le seuil 
de tempÃ©rature. Appuyez Ã  nouveau sur le **joystick** pour rÃ©initialiser le seuil Ã  
sa valeur initiale.

**Code**

.. note::

    Vous pouvez **Modifier/RÃ©initialiser/Copier/ExÃ©cuter/ArrÃªter** le code ci-dessous. Mais avant cela, vous devez vous rendre sur le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import RPi.GPIO as GPIO
    import ADC0834
    import time
    import math

    Joy_BtnPin = 22
    buzzPin = 23
    ledPin = 24


    upperTem = 40

    def setup():
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(ledPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(buzzPin, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(Joy_BtnPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        LCD1602.init(0x27, 1)

    def get_joystick_value():
        x_val = ADC0834.getResult(1)
        y_val = ADC0834.getResult(2)
        if(x_val > 200):
            return 1
        elif(x_val < 50):
            return -1
        elif(y_val > 200):
            return -10
        elif(y_val < 50):
            return 10
        else:
            return 0

    def upper_tem_setting():
        global upperTem
        LCD1602.write(0, 0, 'Upper Adjust: ')
        change = int(get_joystick_value())
        upperTem = upperTem + change
        strUpperTem = str(upperTem)
        LCD1602.write(0, 1, strUpperTem)
        LCD1602.write(len(strUpperTem),1, '              ')
        time.sleep(0.1)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return round(Cel,2)

    def monitoring_temp():
        global upperTem
        Cel=temperature()
        LCD1602.write(0, 0, 'Temp: ')
        LCD1602.write(0, 1, 'Upper: ')
        LCD1602.write(6, 0, str(Cel))
        LCD1602.write(7, 1, str(upperTem))
        time.sleep(0.1)
        if Cel >= upperTem:
            GPIO.output(buzzPin, GPIO.HIGH)
            GPIO.output(ledPin, GPIO.HIGH)
        else:
            GPIO.output(buzzPin, GPIO.LOW)
            GPIO.output(ledPin, GPIO.LOW)       

    def loop():
        lastState=1
        stage=0
        while True:
            currentState=GPIO.input(Joy_BtnPin)
            if currentState==1 and lastState ==0:
                stage=(stage+1)%2
                time.sleep(0.1)    
                LCD1602.clear()
            lastState=currentState
            if stage == 1:
                upper_tem_setting()
            else:
                monitoring_temp()
        
    def destroy():
        LCD1602.clear() 
        ADC0834.destroy()
        GPIO.cleanup()

    if __name__ == '__main__':     # Programme dÃ©marrant ici
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # Quand 'Ctrl+C' est pressÃ©, la fonction destroy() sera exÃ©cutÃ©e.
            destroy()


**Explication du code**

.. code-block:: python

    defÂ get_joystick_value():
    Â Â Â Â x_valÂ =Â ADC0834.getResult(1)
    Â Â Â Â y_valÂ =Â ADC0834.getResult(2)
    Â Â Â Â if(x_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ 1
    Â Â Â Â elif(x_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ -1
    Â Â Â Â elif(y_valÂ >Â 200):
    Â Â Â Â Â Â Â Â returnÂ -10
    Â Â Â Â elif(y_valÂ <Â 50):
    Â Â Â Â Â Â Â Â returnÂ 10
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â returnÂ 0

Cette fonction lit les valeurs de X et Y. Si **X>200**, elle renvoie "**1**"; **X<50**, 
elle renvoie "**-1**"; **y>200**, elle renvoie "**-10**"; et **y<50**, elle renvoie "**10**".

.. code-block:: python

    defÂ upper_tem_setting():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â LCD1602.write(0,Â 0,Â 'UpperÂ Adjust:Â ')
    Â Â Â Â changeÂ =Â int(get_joystick_value())
    Â Â Â Â upperTemÂ =Â upperTemÂ +Â change
    Â Â Â Â LCD1602.write(0,Â 1,Â str(upperTem))
    LCD1602.write(len(strUpperTem),1, '              ')
    Â Â Â Â time.sleep(0.1)

Cette fonction permet d'ajuster le seuil et de l'afficher sur l'Ã©cran **I2C LCD1602**.

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ round(Cel,2)

Lit la valeur analogique du **CH0** (thermistance) de **ADC0834** et la convertit en 
valeur de tempÃ©rature.

.. code-block:: python

    defÂ monitoring_temp():
    Â Â Â Â globalÂ upperTem
    Â Â Â Â Cel=temperature()
    Â Â Â Â LCD1602.write(0,Â 0,Â 'Temp:Â ')
    Â Â Â Â LCD1602.write(0,Â 1,Â 'Upper:Â ')
    Â Â Â Â LCD1602.write(6,Â 0,Â str(Cel))
    Â Â Â Â LCD1602.write(7,Â 1,Â str(upperTem))
    Â Â Â Â time.sleep(0.1)
    Â Â Â Â ifÂ CelÂ >=Â upperTem:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.HIGH)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.HIGH)
    Â Â Â Â else:
    Â Â Â Â Â Â Â Â GPIO.output(buzzPin,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(ledPin,Â GPIO.LOW)

Lorsque le code s'exÃ©cute, la tempÃ©rature actuelle et le seuil de haute tempÃ©rature 
**40** s'affichent sur **I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe ce seuil, 
le buzzer et la LED se dÃ©clenchent pour vous alerter.

.. code-block:: python

    defÂ loop():
    Â Â Â Â lastState=1
    Â Â Â Â stage=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentState=GPIO.input(Joy_BtnPin)
    Â Â Â Â Â Â Â Â ifÂ currentState==1Â andÂ lastStateÂ ==0:
    Â Â Â Â Â Â Â Â Â Â Â Â stage=(stage+1)%2
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.1)Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â LCD1602.clear()
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ stageÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â upper_tem_setting()
    Â Â Â Â Â Â Â Â else:
    Â Â Â Â Â Â Â Â Â Â Â Â monitoring_temp()

La fonction `main()` contient l'ensemble du processus du programme, comme suit :

1) Lorsque le programme dÃ©marre, la valeur initiale de **stage** est **0**, et la 
tempÃ©rature actuelle ainsi que le seuil de haute tempÃ©rature **40** s'affichent sur 
**I2C LCD1602**. Si la tempÃ©rature actuelle dÃ©passe ce seuil, le buzzer et la LED se 
dÃ©clenchent pour vous alerter.

2) Appuyez sur le Joystick, et **stage** passera Ã  **1**, vous permettant d'ajuster le 
seuil de haute tempÃ©rature. En dÃ©plaÃ§ant le Joystick sur l'axe X et Y, vous pouvez ajuster 
(augmenter ou diminuer) le seuil de tempÃ©rature actuel. Appuyez Ã  nouveau sur le Joystick 
pour rÃ©initialiser le seuil Ã  sa valeur initiale.


Image du phÃ©nomÃ¨ne
-----------------------

.. image:: img/image259.jpeg
   :align: center

