.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez dans l'univers du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez des d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux avant-go√ªts.
    - **Remises sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et tirages au sort** : Participez √† des concours et des promotions de saison.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.2.1 Buzzer Actif
=====================

Introduction
---------------

Dans cette le√ßon, nous allons apprendre √† faire bipper un buzzer actif en utilisant 
un transistor PNP.

Composants
-----------

.. image:: img/list_1.2.1.png

Principe
---------

**Buzzer**

Le buzzer est un dispositif √©lectronique avec une structure int√©gr√©e, aliment√© par 
courant continu (DC), largement utilis√© dans les ordinateurs, imprimantes, photocopieuses, 
alarmes, jouets √©lectroniques, dispositifs √©lectroniques automobiles, t√©l√©phones, minuteurs 
et autres appareils √©lectroniques ou de signal sonore. Il existe deux types de buzzers : 
actifs et passifs (voir l'image ci-dessous). Si vous retournez le buzzer, celui avec une 
carte verte est un buzzer passif, tandis que celui recouvert d'un ruban noir est un buzzer 
actif.

La diff√©rence entre un buzzer actif et un buzzer passif :

.. image:: img/image101.png
    :width: 400
    :align: center

La diff√©rence principale est qu'un buzzer actif poss√®de une source d'oscillation int√©gr√©e, 
ce qui lui permet d'√©mettre des sons d√®s qu'il est aliment√©. En revanche, un buzzer passif 
n'a pas de source int√©gr√©e et n√©cessite des signaux carr√©s dont la fr√©quence est comprise 
entre 2K et 5K pour fonctionner. Le buzzer actif est g√©n√©ralement plus co√ªteux en raison de 
ses circuits d'oscillation internes.

Voici le symbole √©lectrique d'un buzzer. Il poss√®de deux broches avec des p√¥les positif et 
n√©gatif. Le signe "+" sur la surface repr√©sente l'anode, tandis que l'autre broche est la 
cathode.

.. image:: img/image102.png
    :width: 150
    :align: center

Vous pouvez v√©rifier les broches du buzzer : la plus longue est l'anode et la plus courte 
est la cathode. Assurez-vous de ne pas les inverser lors du branchement, sinon le buzzer 
ne produira pas de son.

Sch√©ma
---------

Dans cette exp√©rience, un buzzer actif, un transistor PNP et une r√©sistance de 1k ohm sont 
utilis√©s entre la base du transistor et le GPIO pour prot√©ger ce dernier. Lorsque la sortie 
GPIO17 du Raspberry Pi est aliment√©e en niveau bas (0V) via un programme, le transistor 
conduira en raison de la saturation du courant, et le buzzer √©mettra un son. Lorsque la 
sortie GPIO du Raspberry Pi est en niveau haut, le transistor sera bloqu√© et le buzzer ne 
sonnera pas.

.. image:: img/image332.png

Proc√©dure Exp√©rimentale
--------------------------

**√âtape 1** : Montez le circuit (Attention aux p√¥les du buzzer : celui marqu√© d'un "+" est 
le p√¥le positif et l'autre est le p√¥le n√©gatif).

.. image:: img/image104.png
    :width: 800

Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2** : Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.2.1/

**√âtape 3** : Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.1_ActiveBuzzer.c -lwiringPi

**√âtape 4** : Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Apr√®s l'ex√©cution du code, le buzzer √©mettra un bip.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si une erreur appara√Æt, comme : "wiringPi.h : Aucun fichier ou r√©pertoire de ce type", veuillez vous r√©f√©rer √† :ref:`C code is not working?`.
**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>

    #define BeepPin 0
    int main(void){
        if(wiringPiSetup() == -1){ //when initialize wiring failed, print messageto screen
            printf("setup wiringPi failed !");
            return 1;
        }
        
        pinMode(BeepPin, OUTPUT);   // D√©finir GPIO0 en sortie
        while(1){
            //beep on
            printf("Buzzer on\n");
            digitalWrite(BeepPin, LOW);
            delay(100);
            printf("Buzzer off\n");
            //beep off
            digitalWrite(BeepPin, HIGH);
            delay(100);
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    digitalWrite(BeepPin, LOW);

Nous utilisons un buzzer actif dans cette exp√©rience, il √©met donc un son 
automatiquement lorsqu'il est aliment√© en courant continu. Ce programme 
configure le port I/O √† un niveau bas (0V) pour activer le 
transistor et faire sonner le buzzer. 

.. code-block:: c

    digitalWrite(BeepPin, HIGH);

Ici, le port I/O est configur√© √† un niveau haut (3.3V), emp√™chant 
le transistor d'√™tre aliment√©, ce qui emp√™che le buzzer de sonner. 

Pour les utilisateurs Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2** : Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**√âtape 3** : Ex√©cutez le fichier.

.. raw:: html

    <run></run>

.. code-block::

    sudo python3 1.2.1_ActiveBuzzer.py

Le code s'ex√©cute et le buzzer √©met un bip.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin du code source comme ``davinci-kit-for-raspberry-pi/python``. 
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # D√©finir la broche #17 pour le buzzer
    BeepPin = 17

    def setup():
        # Configurer les GPIO en num√©rotation BCM
        GPIO.setmode(GPIO.BCM)
        # Configurer le mode de LedPin en sortie,
        # et le niveau initial √† High (3.3v)
        GPIO.setup(BeepPin, GPIO.OUT, initial=GPIO.HIGH)

    def main():
        while True:
            # Buzzer on (Beep)
            print ('Buzzer On')
            GPIO.output(BeepPin, GPIO.LOW)
            time.sleep(0.1)
            # Buzzer off
            print ('Buzzer Off')
            GPIO.output(BeepPin, GPIO.HIGH)
            time.sleep(0.1)

    def destroy():
        # D√©sactiver le buzzer
        GPIO.output(BeepPin, GPIO.HIGH)
        # Lib√©rer les ressources
        GPIO.cleanup()    

    # Si ce script est ex√©cut√© directement :
    if __name__ == '__main__':
        setup()
        try:
            main()
        # Lorsque 'Ctrl+C' est press√©, la fonction destroy() est ex√©cut√©e.
        except KeyboardInterrupt:
            destroy()

**Explication du code**

.. code-block:: python

    GPIO.output(BeepPin, GPIO.LOW)

Configurer la broche du buzzer √† un niveau bas pour faire sonner le buzzer.

.. code-block:: python

    time.sleep(0.1)

Attendre 0,1 seconde. Modifiez la fr√©quence de commutation en
ajustant ce param√®tre. 

.. note::
    Il ne s'agit pas de la fr√©quence sonore. Le buzzer actif ne peut pas modifier la fr√©quence sonore.

.. code-block:: python

    GPIO.output(BeepPin, GPIO.HIGH)

D√©sactiver le buzzer.

Image du ph√©nom√®ne
-----------------------

.. image:: img/image105.jpeg
