.. note::

    Bonjour, bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez plus profond√©ment dans l'univers du Raspberry Pi, de l'Arduino et de l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Avant-premi√®res exclusives** : B√©n√©ficiez d'un acc√®s anticip√© aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **Remises sp√©ciales** : Profitez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† des tirages au sort et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _py_pi5_10s:

3.1.13 JEU ‚Äì 10 Secondes
==========================

Introduction
------------------

Dans ce projet, nous allons cr√©er un dispositif de jeu pour tester votre 
concentration. Attachez l'interrupteur √† bascule √† un b√¢ton pour en faire 
une baguette magique. Secouez la baguette, l'affichage √† 4 chiffres commencera 
√† compter. Secouez-la √† nouveau pour arr√™ter le compteur. Si vous parvenez √† 
maintenir le compteur sur **10,00** secondes, vous avez gagn√©. Vous pouvez jouer 
√† ce jeu avec vos amis pour voir qui est le ma√Ætre du temps.

Composants n√©cessaires
------------------------------

Dans ce projet, nous aurons besoin des composants suivants.

.. image:: ../python_pi5/img/4.1.18_game_10_second_list.png
    :width: 800
    :align: center

.. Il est certainement plus pratique d'acheter un kit complet, voici le lien : 

.. .. list-table::
..     :widths: 20 20 20
..     :header-rows: 1

..     *   - Nom	
..         - √âL√âMENTS DANS CE KIT
..         - LIEN
..     *   - Kit Raphael
..         - 337
..         - |link_Raphael_kit|

.. Vous pouvez √©galement les acheter s√©par√©ment via les liens ci-dessous.

.. .. list-table::
..     :widths: 30 20
..     :header-rows: 1

..     *   - PR√âSENTATION DES COMPOSANTS
..         - LIEN D'ACHAT

..     *   - :ref:`gpio_extension_board`
..         - |link_gpio_board_buy|
..     *   - :ref:`breadboard`
..         - |link_breadboard_buy|
..     *   - :ref:`wires`
..         - |link_wires_buy|
..     *   - :ref:`resistor`
..         - |link_resistor_buy|
..     *   - :ref:`4_digit`
..         - \-
..     *   - :ref:`74hc595`
..         - |link_74hc595_buy|
..     *   - :ref:`tilt_switch`
..         - \-

Sch√©ma de c√¢blage
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../python_pi5/img/4.1.18_game_10_second_schematic.png
   :align: center

Proc√©dures exp√©rimentales
------------------------------

**√âtape 1** : Construisez le circuit.

.. image:: ../python_pi5/img/4.1.18_game_10_second_circuit.png

**√âtape 2** : Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 3** : Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.13_GAME_10Second.py

Secouez la baguette, l'affichage √† 4 chiffres commencera √† compter, secouez-la 
√† nouveau pour arr√™ter le compteur. Si vous parvenez √† maintenir l'affichage 
sur **10,00** secondes, vous avez gagn√©. Secouez-la encore une fois pour commencer 
un nouveau tour de jeu.

.. warning::

    Si un message d'erreur s'affiche ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez vous r√©f√©rer √† :ref:`faq_soc`.

**Code**

.. note::
    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre √† l'emplacement du code source tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s modification du code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    from gpiozero import OutputDevice, Button
    import time
    import threading

    # Initialisation du bouton connect√© au GPIO 26
    sensorPin = Button(26)

    # D√©finir les broches GPIO connect√©es au registre √† d√©calage 74HC595
    SDI = OutputDevice(24)   # Entr√©e de donn√©es s√©rie
    RCLK = OutputDevice(23)  # Horloge de registre
    SRCLK = OutputDevice(18) # Horloge du registre √† d√©calage

    # D√©finir les broches GPIO pour la s√©lection de chiffre sur l'afficheur √† 7 segments
    placePin = [OutputDevice(pin) pour pin in (10, 22, 27, 17)]

    # D√©finir les codes de segments pour les chiffres de 0 √† 9 sur l'afficheur √† 7 segments
    number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

    # Variables du compteur et du minuteur
    counter = 0
    timer1 = None
    gameState = 0

    def clearDisplay():
        """ Clear all segments on the 7-segment display. """
        for _ in range(8):
            SDI.on()
            SRCLK.on()
            SRCLK.off()
        RCLK.on()
        RCLK.off()

    def hc595_shift(data):
        """ Shift data to the 74HC595 shift register to display a digit. """
        for i in range(8):
            SDI.value = 0x80 & (data << i)
            SRCLK.on()
            SRCLK.off()
        RCLK.on()
        RCLK.off()

    def pickDigit(digit):
        """ Select which digit to display on the 7-segment display. """
        for pin in placePin:
            pin.off()
        placePin[digit].on()

    def display():
        """ Display the current counter value on the 7-segment display. """
        global counter
        clearDisplay()
        pickDigit(0)
        hc595_shift(number[counter % 10])

        clearDisplay()
        pickDigit(1)
        hc595_shift(number[counter % 100 // 10])

        clearDisplay()
        pickDigit(2)
        hc595_shift(number[counter % 1000 // 100] - 0x80)

        clearDisplay()
        pickDigit(3)
        hc595_shift(number[counter % 10000 // 1000])

    def stateChange():
        """ Handle state changes for the counter based on button presses. """
        global gameState, counter, timer1
        if gameState == 0:
            counter = 0
            time.sleep(1)
            timer()
        elif gameState == 1 and timer1 is not None:
            timer1.cancel()
            time.sleep(1)
        gameState = (gameState + 1) % 2

    def loop():
        """ Main loop to check for button presses and update the display. """
        global counter
        currentState = 0
        lastState = 0
        while True:
            display()
            currentState = sensorPin.value
            if (currentState == 0) and (lastState == 1):
                stateChange()
            lastState = currentState

    def timer():
        """ Timer function that increments the counter every 0.01 second. """
        global counter, timer1
        timer1 = threading.Timer(0.01, timer)
        timer1.start()
        counter += 1

    try:
        loop()
    except KeyboardInterrupt:
        if timer1:
            timer1.cancel()


**Explication du Code**

#. Le script commence par importer les modules n√©cessaires. La biblioth√®que ``gpiozero`` est utilis√©e pour interfacer avec des p√©riph√©riques GPIO tels que les boutons, et les modules ``time`` et ``threading`` sont utilis√©s pour g√©rer les t√¢ches li√©es au temps ou les op√©rations concurrentes.

   .. code-block:: python

       #!/usr/bin/env python3

       from gpiozero import OutputDevice, Button
       import time
       import threading

#. Initialisation d'un objet ``Button`` de la biblioth√®que GPIO Zero, connect√© √† la broche GPIO 26. Cette configuration permet de d√©tecter les appuis sur le bouton.

   .. code-block:: python

       # Initialiser le bouton connect√© √† la broche GPIO 26
       sensorPin = Button(26)

#. Configuration des broches GPIO connect√©es aux entr√©es de donn√©es s√©rie (SDI), horloge de registre (RCLK) et horloge de registre √† d√©calage (SRCLK) du registre √† d√©calage 74HC595.

   .. code-block:: python

       # D√©finir les broches GPIO connect√©es au registre √† d√©calage 74HC595
       SDI = OutputDevice(24)   # Entr√©e de donn√©es s√©rie
       RCLK = OutputDevice(23)  # Horloge de registre
       SRCLK = OutputDevice(18) # Horloge du registre √† d√©calage

#. Configuration des broches pour chaque chiffre de l'afficheur √† 7 segments et d√©finition des codes binaires pour afficher les chiffres de 0 √† 9.

   .. code-block:: python

       # D√©finir les broches GPIO pour la s√©lection des chiffres sur l'afficheur √† 7 segments
       placePin = [OutputDevice(pin) pour pin in (10, 22, 27, 17)]

       # D√©finir les codes de segments pour les chiffres de 0 √† 9 sur l'afficheur √† 7 segments
       number = (0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90)

#. Fonctions pour contr√¥ler l'afficheur √† 7 segments. ``clearDisplay`` √©teint tous les segments, ``hc595_shift`` envoie les donn√©es au registre √† d√©calage, et ``pickDigit`` active un chiffre sp√©cifique de l'afficheur.

   .. code-block:: python

       def clearDisplay():
           """ Clear all segments on the 7-segment display. """
           for _ in range(8):
               SDI.on()
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

       def hc595_shift(data):
           """ Shift data to the 74HC595 shift register to display a digit. """
           for i in range(8):
               SDI.value = 0x80 & (data << i)
               SRCLK.on()
               SRCLK.off()
           RCLK.on()
           RCLK.off()

       def pickDigit(digit):
           """ Select which digit to display on the 7-segment display. """
           for pin in placePin:
               pin.off()
           placePin[digit].on()

#. Fonction pour afficher la valeur actuelle du compteur sur l'afficheur √† 7 segments.

   .. code-block:: python

       def display():
           """ Display the current counter value on the 7-segment display. """
           global counter
           clearDisplay()
           pickDigit(0)
           hc595_shift(number[counter % 10])

           clearDisplay()
           pickDigit(1)
           hc595_shift(number[counter % 100 // 10])

           clearDisplay()
           pickDigit(2)
           hc595_shift(number[counter % 1000 // 100] - 0x80)

           clearDisplay()
           pickDigit(3)
           hc595_shift(number[counter % 10000 // 1000])

#. Fonction pour g√©rer les changements d'√©tat (d√©marrage/arr√™t) du compteur en fonction des pressions sur le bouton.

   .. code-block:: python

       def stateChange():
           """ Handle state changes for the counter based on button presses. """
           global gameState, counter, timer1
           if gameState == 0:
               counter = 0
               time.sleep(1)
               timer()
           elif gameState == 1 et timer1 est activ√©:
               timer1.cancel()
               time.sleep(1)
           gameState = (gameState + 1) % 2

#. Boucle principale qui v√©rifie continuellement l'√©tat du bouton et met √† jour l'affichage. Elle appelle ``stateChange`` lorsque l'√©tat du bouton change.

   .. code-block:: python

       def loop():
           """ Main loop to check for button presses and update the display. """
           global counter
           currentState = 0
           lastState = 0
           while True:
               display()
               currentState = sensorPin.value
               if (currentState == 0) and (lastState == 1):
                   stateChange()
               lastState = currentState

#. Fonction de minuterie qui incr√©mente le compteur √† intervalles r√©guliers (toutes les 0,01 seconde).

   .. code-block:: python

       def timer():
           """ Timer function that increments the counter every 0.01 second. """
           global counter, timer1
           timer1 = threading.Timer(0.01, timer)
           timer1.start()
           counter += 1

#. Ex√©cute la boucle principale et permet une sortie propre du programme en utilisant une interruption du clavier (Ctrl+C).

   .. code-block:: python

       try:
           loop()
       except KeyboardInterrupt:
           if timer1:
               timer1.cancel()