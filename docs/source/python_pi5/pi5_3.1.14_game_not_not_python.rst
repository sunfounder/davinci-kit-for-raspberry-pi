.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sum√©rgete junto a otros entusiastas en el fascinante mundo de Raspberry Pi, Arduino y ESP32.

    **¬øPor qu√© unirte?**

    - **Soporte experto**: Resuelve problemas posventa y desaf√≠os t√©cnicos con ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos exclusivos**: Accede anticipadamente a anuncios y adelantos de nuevos productos.
    - **Descuentos especiales**: Aprovecha descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones especiales en d√≠as festivos.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo.

.. _3.1.14_py_pi5:

3.1.14 JUEGO ‚Äì Not Not
========================

Introducci√≥n
---------------------

En esta lecci√≥n, crearemos un divertido dispositivo de juego llamado "Not Not".

Durante el juego, la matriz de puntos mostrar√° una flecha en una direcci√≥n al azar. Debes presionar el bot√≥n en la direcci√≥n opuesta a la flecha dentro de un tiempo limitado. Si el tiempo se acaba o presionas el bot√≥n en la misma direcci√≥n de la flecha, pierdes.

Este juego realmente puede ayudarte a practicar el pensamiento inverso. ¬øListo para intentarlo?

Componentes necesarios
------------------------------

En este proyecto, necesitaremos los siguientes componentes.

.. image:: ../python_pi5/img/3.1.14_game_not_not_list.png
    :width: 800
    :align: center

Diagrama de Esquema
------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO20       Pin 38   28       20
GPIO26       Pin 37   25       26
============ ======== ======== ===

.. image:: ../python_pi5/img/3.1.14_game_not_not_schematic.png
   :align: center

Procedimiento Experimental
-------------------------------

**Paso 1:** Monta el circuito.

.. image:: ../python_pi5/img/3.1.14_game_not_not_circuit.png

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5


**Paso 3:** Ejecuta el programa.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.14_MotionControl_zero.py

Al iniciar el programa, aparece una flecha en la matriz de puntos apuntando 
hacia la derecha o la izquierda. Lo que debes hacer es presionar el bot√≥n en 
la direcci√≥n opuesta a la flecha dentro de un tiempo l√≠mite. Entonces, aparecer√° 
un \"**‚àö**\" en la matriz de puntos. Si se acaba el tiempo o presionas el bot√≥n 
en la misma direcci√≥n que la flecha, pierdes y la matriz de puntos muestra una 
\"x\". Tambi√©n puedes agregar 2 botones nuevos o reemplazarlos por los controles 
de un joystick para tener 4 direcciones: arriba, abajo, izquierda y derecha, 
aumentando as√≠ la dificultad del juego.

.. warning::

    Si aparece el mensaje de error ``RuntimeError: Cannot determine SOC peripheral base address``, consulta la secci√≥n :ref:`faq_soc` 

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Sin embargo, antes de hacerlo, dir√≠gete a la ruta de c√≥digo fuente, como ``davinci-kit-for-raspberry-pi/python-pi5``. Tras realizar cambios, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice, Button
   import time
   import threading
   import random

   # Pines GPIO para el registro de desplazamiento 74HC595
   SDI = OutputDevice(17)   # Entrada de Datos Serial
   RCLK = OutputDevice(18)  # Reloj de Registro
   SRCLK = OutputDevice(27) # Reloj de Registro de Desplazamiento

   # Pines GPIO para los botones
   AButtonPin = Button(20)  # Bot√≥n A
   BButtonPin = Button(26)  # Bot√≥n B

   # Inicializaci√≥n de variables del juego
   timerPlay = 0
   timerCheck = 0
   waypoint = "NULL"
   stage = "NULL"

   # Flechas para la matriz LED
   arrow = {
       "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
       "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
   }

   # Iconos de respuesta para respuestas correctas/incorrectas
   check = {
       "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
       "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
   }

   def hc595_shift(dat):
       """ Shift data to the 74HC595 shift register. """
       for i in range(8):
           SDI.value = 0x80 & (dat << i)
           SRCLK.on()
           SRCLK.off()

   def display(glyphCode):
       """ Display a glyph on the LED matrix. """
       for i in range(0, 8):
           hc595_shift(glyphCode[i])
           hc595_shift(0x80 >> i)
           RCLK.on()
           RCLK.off()

   def creatGlyph():
       """ Create a new glyph for the game and start the play timer. """
       global waypoint, stage, timerPlay
       waypoint = random.choice(list(arrow.keys()))
       stage = "PLAY"
       timerPlay = threading.Timer(2.0, timeOut)
       timerPlay.start()

   def checkPoint(inputKey):
       """ Check player's input and update game state. """
       global waypoint, stage, timerCheck
       if inputKey == "empty" or inputKey == waypoint:
           waypoint = "wrong"
       else:
           waypoint = "right"
       timerPlay.cancel()
       stage = "CHECK"
       timerCheck = threading.Timer(1.0, creatGlyph)
       timerCheck.start()

   def timeOut():
       """ Handle game timeout scenario. """
       checkPoint("empty")

   def getKey():
       """ Detect button press and trigger checkpoint. """
       if AButtonPin.is_pressed and not BButtonPin.is_pressed:
           checkPoint("right")
       elif not AButtonPin.is_pressed and BButtonPin.is_pressed:
           checkPoint("left")

   def main():
       """ Main game loop. """
       creatGlyph()
       while True:
           if stage == "PLAY":
               display(arrow[waypoint])
               getKey()
           elif stage == "CHECK":
               display(check[waypoint])

   def destroy():
       """ Clean up resources on program exit. """
       global timerPlay, timerCheck
       timerPlay.cancel()  # Cancela el temporizador de juego
       timerCheck.cancel()  # Cancela el temporizador de verificaci√≥n

   # Ejecuta el juego, maneja la interrupci√≥n de teclado para salir limpiamente
   try:
       main()
   except KeyboardInterrupt:
       destroy()




**Explicaci√≥n del C√≥digo**

Basado en **1.1.6 Matriz de Puntos LED**, en esta lecci√≥n se a√±aden **2** botones para crear un dispositivo de juego divertido. Si a√∫n no est√°s familiarizado con la matriz de puntos, por favor consulta :ref:`1.1.6_py_pi5`.

#. El c√≥digo comienza importando las librer√≠as necesarias. Se utiliza ``gpiozero`` para interactuar con pines GPIO como botones y dispositivos de salida. ``time`` permite agregar retrasos, ``threading`` habilita la ejecuci√≥n de m√∫ltiples tareas simult√°neamente, y ``random`` es √∫til para introducir aleatoriedad en el proyecto.

   .. code-block:: python

       #!/usr/bin/env python3
       from gpiozero import OutputDevice, Button
       import time
       import threading
       import random

#. Se inicializan los pines GPIO para el registro de desplazamiento (``SDI``, ``RCLK``, ``SRCLK``) y los botones (``AButtonPin``, ``BButtonPin``). El registro de desplazamiento se utiliza para controlar m√∫ltiples LEDs con menos pines GPIO, lo cual es crucial para la pantalla de la matriz LED.

   .. code-block:: python

       # Pines GPIO para el registro de desplazamiento 74HC595
       SDI = OutputDevice(17)   # Entrada de Datos Serial
       RCLK = OutputDevice(18)  # Reloj de Registro
       SRCLK = OutputDevice(27) # Reloj de Registro de Desplazamiento

       # Pines GPIO para los botones
       AButtonPin = Button(20)  # Bot√≥n A
       BButtonPin = Button(26)  # Bot√≥n B

#. Se inicializan variables utilizadas en la l√≥gica del juego, como temporizadores e indicadores de estado del juego.

   .. code-block:: python

       # Inicializaci√≥n de variables del juego
       timerPlay = 0
       timerCheck = 0
       waypoint = "NULL"
       stage = "NULL"

#. Se definen patrones binarios para mostrar flechas y respuestas (correcto/incorrecto) en la matriz LED. Cada elemento del arreglo representa una fila de la matriz LED, donde ``1`` y ``0`` indican si el LED est√° encendido o apagado, respectivamente.

   .. code-block:: python

       # Flechas para la pantalla de la matriz LED
       arrow = {
           "right": [0xFF, 0xEF, 0xDF, 0x81, 0xDF, 0xEF, 0xFF, 0xFF],
           "left": [0xFF, 0xF7, 0xFB, 0x81, 0xFB, 0xF7, 0xFF, 0xFF]
       }

       # √çconos de respuesta para respuestas correctas/incorrectas
       check = {
           "wrong": [0xFF, 0xBB, 0xD7, 0xEF, 0xD7, 0xBB, 0xFF, 0xFF],
           "right": [0xFF, 0xFF, 0xF7, 0xEB, 0xDF, 0xBF, 0xFF, 0xFF]
       }

#. Esta funci√≥n desplaza un byte de datos hacia el registro de desplazamiento 74HC595. Itera sobre cada bit del byte ``dat``, configurando el pin ``SDI`` alto o bajo seg√∫n corresponda, y alterna el pin ``SRCLK`` para desplazar el bit en el registro.

   .. code-block:: python

       def hc595_shift(dat):
           """ Shift data to the 74HC595 shift register. """
           for i in range(8):
               SDI.value = 0x80 & (dat << i)
               SRCLK.on()
               SRCLK.off()

#. Esta funci√≥n muestra un glifo en la matriz LED. Env√≠a cada fila del glifo (representado por ``glyphCode``) y la direcci√≥n de la fila al registro de desplazamiento usando ``hc595_shift``, y luego alterna el pin ``RCLK`` para actualizar la pantalla.

   .. code-block:: python

       def display(glyphCode):
           """ Display a glyph on the LED matrix. """
           for i in range(0, 8):
               hc595_shift(glyphCode[i])
               hc595_shift(0x80 >> i)
               RCLK.on()
               RCLK.off()

#. Esta funci√≥n selecciona un glifo al azar del diccionario ``arrow``, inicia el temporizador de juego y establece el estado del juego en "PLAY". Se utiliza ``threading.Timer`` para el control del tiempo en el juego.

   .. code-block:: python

       def creatGlyph():
           """ Create a new glyph for the game and start the play timer. """
           global waypoint, stage, timerPlay
           waypoint = random.choice(list(arrow.keys()))
           stage = "PLAY"
           timerPlay = threading.Timer(2.0, timeOut)
           timerPlay.start()

#. Esta funci√≥n verifica la entrada del jugador en comparaci√≥n con el glifo actual. Si la entrada es correcta, establece el waypoint en "right", de lo contrario en "wrong". Luego cancela el temporizador de juego actual e inicia un nuevo temporizador para el pr√≥ximo glifo.

   .. code-block:: python

       def checkPoint(inputKey):
           """ Check player's input and update game state. """
           global waypoint, stage, timerCheck
           if inputKey == "empty" or inputKey == waypoint:
               waypoint = "wrong"
           else:
               waypoint = "right"
           timerPlay.cancel()
           stage = "CHECK"
           timerCheck = threading.Timer(1.0, creatGlyph)
           timerCheck.start()

#. Esta funci√≥n se llama cuando se agota el tiempo del juego. Invoca ``checkPoint`` con "empty" para indicar que no se presion√≥ ning√∫n bot√≥n a tiempo.

   .. code-block:: python

       def timeOut():
           """ Handle game timeout scenario. """
           checkPoint("empty")

#. Esta funci√≥n verifica el estado de los botones. Si ``AButtonPin`` est√° presionado (y ``BButtonPin`` no), llama a ``checkPoint`` con "right". Si ``BButtonPin`` est√° presionado (y ``AButtonPin`` no), llama a ``checkPoint`` con "left".

   .. code-block:: python

       def getKey():
           """ Detect button press and trigger checkpoint. """
           if AButtonPin.is_pressed and not BButtonPin.is_pressed:
               checkPoint("right")
           elif not AButtonPin.is_pressed and BButtonPin.is_pressed:
               checkPoint("left")

#. La funci√≥n ``main`` controla el flujo del juego. Comienza creando un glifo, luego verifica continuamente el estado del juego. Si est√° en el estado "PLAY", muestra el glifo actual y verifica las pulsaciones de bot√≥n. En el estado "CHECK", muestra la retroalimentaci√≥n seg√∫n la acci√≥n del jugador.

   .. code-block:: python

       def main():
           """ Main game loop. """
           creatGlyph()
           while True:
               if stage == "PLAY":
                   display(arrow[waypoint])
                   getKey()
               elif stage == "CHECK":
                   display(check[waypoint])

#. Esta funci√≥n cancela cualquier temporizador activo al salir del programa, asegurando un apagado limpio.

   .. code-block:: python

       def destroy():
           """ Clean up resources on program exit. """
           global timerPlay, timerCheck
           timerPlay.cancel()  # Cancela el temporizador de juego
           timerCheck.cancel()  # Cancela el temporizador de verificaci√≥n

#. El juego se ejecuta en un bloque ``try``. Si ocurre una ``KeyboardInterrupt`` (como presionar Ctrl+C), captura la excepci√≥n y llama a ``destroy`` para limpiar antes de salir.

   .. code-block:: python

       # Ejecuta el juego y maneja KeyboardInterrupt para salir limpiamente
       try:
           main()
       except KeyboardInterrupt:
           destroy()


