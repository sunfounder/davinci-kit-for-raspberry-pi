.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez dans l‚Äôunivers du Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et relevez les d√©fis techniques gr√¢ce √† l‚Äôaide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Avant-premi√®res exclusives** : Profitez d'un acc√®s anticip√© aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos derni√®res nouveaut√©s.
    - **Promotions festives et cadeaux** : Participez √† des promotions sp√©ciales et des tirages au sort lors des f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] pour nous rejoindre d√®s aujourd'hui !

.. _1.1.6_py_pi5:

1.1.6 Matrice de LED
========================

Introduction
----------------------

Comme son nom l'indique, une matrice de LED est une grille compos√©e de LED. 
L'allumage et l'extinction des LED permettent de former diff√©rents caract√®res et motifs.

Composants requis
------------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../python_pi5/img/1.1.6_led_dot_matrix_list.png
    :width: 800
    :align: center

.. raw:: html

   <br/>

Principe de fonctionnement
------------------------------

**Matrice de LED**

En g√©n√©ral, les matrices de LED se divisent en deux types : cathode commune (CC) et 
anode commune (CA). Elles se ressemblent, mais pr√©sentent des diff√©rences internes. 
Vous pouvez les diff√©rencier par un test. Nous utilisons ici un mod√®le CA, marqu√© 
¬´ 788BS ¬ª sur le c√¥t√©.

Consultez la figure ci-dessous. Les broches sont dispos√©es aux deux extr√©mit√©s de 
l'arri√®re. Prenez le c√¥t√© marqu√© comme r√©f√©rence : les broches de cette extr√©mit√© 
sont num√©rot√©es de 1 √† 8, et celles de l'autre extr√©mit√© de 9 √† 16.

Vue externe :

.. image:: ../python_pi5/img/1.1.6_led_dot_matrix_1.png
   :width: 400
   :align: center

Les sch√©mas ci-dessous montrent leur structure interne. Dans une matrice CA, ROW repr√©sente 
l'anode de la LED, et COL la cathode ; l'inverse est vrai pour un mod√®le CC. Quel que soit 
le type, les broches 13, 3, 4, 10, 6, 11, 15 et 16 correspondent aux COL, tandis que les 
broches 9, 14, 8, 12, 1, 7, 2 et 5 correspondent aux ROW. Pour allumer la premi√®re LED en 
haut √† gauche, dans une matrice CA, mettez la broche 9 en High et la broche 13 en Low. 
Dans une matrice CC, faites l'inverse : mettez la broche 13 en High et la broche 9 en Low. 
Pour allumer toute la premi√®re colonne, dans une matrice CA, mettez la broche 13 en Low et 
les broches ROW (9, 14, 8, 12, 1, 7, 2, 5) en High ; pour une matrice CC, faites l'inverse.




Sch√©ma interne :

.. image:: ../python_pi5/img/1.1.6_led_dot_matrix_2.png
   :width: 400
   :align: center

Num√©rotation des broches correspondant aux rang√©es et colonnes ci-dessus :

=========== ====== ====== ===== ====== ===== ====== ====== ======
**COL**     **1**  **2**  **3** **4**  **5** **6**  **7**  **8**
**Pin No.** **13** **3**  **4** **10** **6** **11** **15** **16**
**ROW**     **1**  **2**  **3** **4**  **5** **6**  **7**  **8**
**Pin No.** **9**  **14** **8** **12** **1** **7**  **2**  **5**
=========== ====== ====== ===== ====== ===== ====== ====== ======

De plus, deux circuits int√©gr√©s 74HC595 sont utilis√©s ici : l'un pour contr√¥ler les rang√©es de la matrice de LED, et l'autre pour les colonnes.

Sch√©ma de c√¢blage
-------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../python_pi5/img/1.1.6_led_dot_matrix_schematic.png
   :width: 800

Proc√©dure exp√©rimentale
----------------------------

**√âtape 1 :** Construire le circuit. Comme le c√¢blage est complexe, proc√©dons √©tape 
par √©tape. Ins√©rez d'abord le T-Cobbler, la matrice de LED et les deux circuits 74HC595 
dans la plaque de montage. Connectez le 3.3V et le GND du T-Cobbler aux trous situ√©s de 
chaque c√¥t√© de la plaque, puis reliez la broche 16 et la broche 10 des deux 74HC595 au VCC, 
et les broches 13 et 8 au GND.

.. note::
   Dans l'image Fritzing ci-dessus, le c√¥t√© marqu√© est en bas.

.. image:: ../python_pi5/img/1.1.6_LedMatrix_circuit_1.png
   :width: 800

**√âtape 2 :** Connectez la broche 11 des deux 74HC595 ensemble, puis au GPIO27 ; ensuite, 
la broche 12 des deux circuits, au GPIO18 ; et enfin, la broche 14 du 74HC595 de gauche au 
GPIO17 et la broche 9 √† la broche 14 du deuxi√®me 74HC595.

.. image:: ../python_pi5/img/1.1.6_LedMatrix_circuit_2.png
   :width: 800

**√âtape 3 :** Le 74HC595 √† droite contr√¥le les colonnes de la matrice de LED. Consultez le 
tableau ci-dessous pour le mappage. Les broches Q0-Q7 du 74HC595 correspondent respectivement 
aux broches 13, 3, 4, 10, 6, 11, 15 et 16 de la matrice de LED.

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **13** | **3**  | **4**  | **10** | **6**  | **11** | **15** | **16** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

.. image:: ../python_pi5/img/1.1.6_LedMatrix_circuit_3.png
   :width: 800

**√âtape 4 :** Connectez maintenant les ROW de la matrice de LED. Le 74HC595 de gauche 
contr√¥le les rang√©es de la matrice. Consultez le tableau ci-dessous pour le mappage. 
Les broches Q0-Q7 du 74HC595 correspondent respectivement aux broches 9, 14, 8, 12, 1, 7, 2 et 5 de la matrice de LED.

+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **74HC595**        | **Q0** | **Q1** | **Q2** | **Q3** | **Q4** | **Q5** | **Q6** | **Q7** |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+
| **LED Dot Matrix** | **9**  | **14** | **8**  | **12** | **1**  | **7**  | **2**  | **5**  |
+--------------------+--------+--------+--------+--------+--------+--------+--------+--------+

.. image:: ../python_pi5/img/1.1.6_LedMatrix_circuit_4.png
   :width: 800

**√âtape 5 :** Ouvrir le fichier de code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5


**√âtape 6 :** Ex√©cuter le code.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.6_led_dot_matrix_zero.py

Apr√®s l'ex√©cution du code, la matrice de LED s'allumera et s'√©teindra ligne par ligne et colonne par colonne.

.. warning::

    Si un message d'erreur tel que ``RuntimeError: Cannot determine SOC peripheral base address`` s'affiche, veuillez vous r√©f√©rer √† :ref:`faq_soc`.

**Code**

.. note::

    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le r√©pertoire source tel que ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour observer les effets.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   from gpiozero import OutputDevice
   from time import sleep

   # D√©finir les broches GPIO connect√©es au registre √† d√©calage 74HC595
   SDI = OutputDevice(17)   # Entr√©e de donn√©es s√©rie
   RCLK = OutputDevice(18)  # Horloge de registre
   SRCLK = OutputDevice(27) # Horloge de d√©calage

   # D√©finir les motifs d'affichage de la matrice ; ROWs sont les anodes (+), COLs sont les cathodes (-)
   # Mod√®le pour les rang√©es (signaux d'anode)
   code_H = [0x01, 0xff, 0x80, 0xff, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]
   # Mod√®le pour les colonnes (signaux de cathode)
   code_L = [0x00, 0x7f, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f]

   # D√©calage de donn√©es vers le 74HC595
   def hc595_shift(dat):
      """ Shift data to the 74HC595 shift register for displaying on the matrix. """
      for i in range(8):
         # R√©gler la valeur de SDI et d√©clencher l'horloge de d√©calage
         SDI.value = 0x80 & (dat << i)
         SRCLK.on()
         SRCLK.off()
      # D√©clencher l'horloge de registre pour mettre √† jour l'affichage
      RCLK.on()
      sleep(0.001)
      RCLK.off()

   def main():
      """ Main loop for cycling through display patterns. """
      while True:
         # Parcourir les motifs dans l'ordre croissant
         for i in range(len(code_H)):
               hc595_shift(code_L[i])
               hc595_shift(code_H[i])
               sleep(0.1)

         # Parcourir les motifs dans l'ordre d√©croissant
         for i in range(len(code_H)-1, -1, -1):
               hc595_shift(code_L[i])
               hc595_shift(code_H[i])
               sleep(0.1)

   # Ex√©cuter la boucle principale, g√©rer l'interruption du clavier proprement
   try:
      main()
   except KeyboardInterrupt:
      pass




**Explication du Code**

#. Cet extrait de code importe les classes n√©cessaires pour le projet. ``OutputDevice`` de la biblioth√®que ``gpiozero`` est utilis√© pour contr√¥ler les composants mat√©riels connect√©s aux broches GPIO, et ``sleep`` de la biblioth√®que ``time`` est utilis√© pour ajouter des d√©lais.

   .. code-block:: python
 
      #!/usr/bin/env python3
      from gpiozero import OutputDevice
      from time import sleep

#. Cette section initialise les broches GPIO connect√©es au registre √† d√©calage 74HC595. ``SDI`` correspond √† l'entr√©e de donn√©es s√©rie, ``RCLK`` est l'horloge de registre, et ``SRCLK`` est l'horloge de d√©calage. Ces broches sont utilis√©es pour ins√©rer les donn√©es dans le registre et contr√¥ler l'affichage de la matrice LED.

   .. code-block:: python

      # D√©finir les broches GPIO connect√©es au registre √† d√©calage 74HC595
      SDI = OutputDevice(17)   # Entr√©e de donn√©es s√©rie
      RCLK = OutputDevice(18)  # Horloge de registre
      SRCLK = OutputDevice(27) # Horloge de d√©calage

#. ``code_H`` et ``code_L`` d√©finissent les motifs binaires pour contr√¥ler respectivement les rang√©es (anodes) et les colonnes (cathodes) de la matrice LED. Chaque √©l√©ment de ces tableaux repr√©sente un motif binaire qui contr√¥le quels LED doivent √™tre allum√©s ou √©teints dans la matrice.

   .. code-block:: python

      # D√©finir les motifs d'affichage pour la matrice ; ROWs sont les anodes (+), COLs sont les cathodes (-)
      # Motif pour les rang√©es (signaux d'anode)
      code_H = [0x01, 0xff, 0x80, 0xff, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]
      # Motif pour les colonnes (signaux de cathode)
      code_L = [0x00, 0x7f, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f]

#. Cette fonction d√©place un octet de donn√©es (``dat``) dans le registre √† d√©calage 74HC595. Elle parcourt chaque bit de l'octet, d√©finit la broche ``SDI`` sur haut ou bas en fonction de la valeur du bit, et bascule la broche ``SRCLK`` pour ins√©rer le bit dans le registre. Apr√®s avoir ins√©r√© tous les bits, elle bascule la broche ``RCLK`` pour mettre √† jour l'affichage de la matrice LED.

   .. code-block:: python
 
      # D√©placer les donn√©es vers le 74HC595
      def hc595_shift(dat):
         """ Shift data to the 74HC595 shift register for displaying on the matrix. """
         for i in range(8):
            # R√©gler la valeur de SDI et d√©clencher l'horloge de d√©calage
            SDI.value = 0x80 & (dat << i)
            SRCLK.on()
            SRCLK.off()
         # D√©clencher l'horloge de registre pour mettre √† jour l'affichage
         RCLK.on()
         sleep(0.001)
         RCLK.off()

#. La fonction principale contient une boucle infinie qui parcourt les motifs pr√©d√©finis de la matrice LED. Elle utilise la fonction ``hc595_shift`` pour envoyer les motifs de rang√©es et de colonnes (``code_H`` et ``code_L``) au registre √† d√©calage, d'abord dans l'ordre croissant, puis dans l'ordre d√©croissant, cr√©ant ainsi un affichage dynamique.

   .. code-block:: python

      def main():
         """ Main loop for cycling through display patterns. """
         while True:
            # Parcourir les motifs dans l'ordre croissant
            for i in range(len(code_H)):
                  hc595_shift(code_L[i])
                  hc595_shift(code_H[i])
                  sleep(0.1)

            # Parcourir les motifs dans l'ordre d√©croissant
            for i in range(len(code_H)-1, -1, -1):
                  hc595_shift(code_L[i])
                  hc595_shift(code_H[i])
                  sleep(0.1)

#. Ce segment garantit que le programme peut √™tre interrompu √† l'aide d'une interruption clavier (Ctrl+C). Il quitte proprement la boucle principale sans arr√™t brusque ni fuite de ressources.

   .. code-block:: python

      # Ex√©cuter la boucle principale, g√©rer l'interruption clavier proprement
      try:
         main()
      except KeyboardInterrupt:
         pass
