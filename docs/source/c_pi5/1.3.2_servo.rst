.. note::

    Bonjour, bienvenue dans la communaut√© des passionn√©s de SunFounder Raspberry Pi, Arduino et ESP32 sur Facebook ! Explorez plus en profondeur le Raspberry Pi, l'Arduino et l'ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes post-vente et relevez les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : B√©n√©ficiez d'un acc√®s anticip√© aux nouvelles annonces de produits et aux avant-premi√®res.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et cadeaux** : Participez √† des concours et promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.3.2 Servo
===============

Introduction
----------------

Dans cette le√ßon, nous allons apprendre √† faire tourner le servomoteur.

Composants
-------------

.. image:: img/list_1.3.2.png


Principe
-----------

**Servomoteur**

Un servomoteur est g√©n√©ralement compos√© des parties suivantes : un bo√Ætier, un arbre, 
un syst√®me d'engrenages, un potentiom√®tre, un moteur √† courant continu (DC) et une 
carte embarqu√©e.

.. image:: img/image121.png


Son fonctionnement est le suivant : Le microcontr√¥leur envoie des signaux PWM 
(modulation de largeur d'impulsion) au servomoteur, puis la carte int√©gr√©e dans 
le servomoteur re√ßoit les signaux via la broche de signal et contr√¥le le moteur 
interne pour tourner. Par cons√©quent, le moteur entra√Æne le syst√®me d'engrenages, 
qui √† son tour actionne l'arbre apr√®s une r√©duction de vitesse. L'arbre et le 
potentiom√®tre du servomoteur sont reli√©s ensemble. Lorsque l'arbre tourne, il entra√Æne 
le potentiom√®tre, ce qui permet au potentiom√®tre de sortir un signal de tension vers 
la carte int√©gr√©e. Ensuite, la carte d√©termine la direction et la vitesse de 
rotation en fonction de la position actuelle, afin qu'il puisse s'arr√™ter pr√©cis√©ment 
√† la position d√©finie et s'y maintenir.

.. image:: img/image122.png


L'angle est d√©termin√© par la dur√©e d'une impulsion appliqu√©e au fil de commande. 
C'est ce qu'on appelle la modulation de largeur d'impulsion (PWM). Le servomoteur 
s'attend √† recevoir une impulsion toutes les 20 ms. La dur√©e de l'impulsion d√©terminera 
jusqu'o√π le moteur tourne. Par exemple, une impulsion de 1,5 ms fera tourner le moteur
 √† la position de 90 degr√©s (position neutre).

Lorsque l'impulsion envoy√©e est inf√©rieure √† 1,5 ms, le servomoteur tourne vers une 
position et maintient son arbre de sortie √† un certain nombre de degr√©s dans le sens 
antihoraire par rapport au point neutre. Lorsque l'impulsion est sup√©rieure √† 1,5 ms, 
l'effet inverse se produit. La largeur minimale et maximale de l'impulsion pour 
commander le servomoteur √† se d√©placer vers une position valide d√©pend de chaque 
servomoteur. En g√©n√©ral, l'impulsion minimale sera d'environ 0,5 ms et l'impulsion 
maximale sera de 2,5 ms.

.. image:: img/image123.jpeg


Sch√©ma de c√¢blage
-----------------------

.. image:: ../img/image337.png


Proc√©dure exp√©rimentale
---------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../img/image125.png


**√âtape 2 :** Acc√©dez au dossier contenant le code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/1.3.2

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.3.2_Servo.c -lwiringPi

**√âtape 4 :** Ex√©cutez le fichier compil√©.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Une fois le programme ex√©cut√©, le servomoteur tournera de 0 √† 180 degr√©s, 
puis de 180 √† 0 degr√©s, de mani√®re circulaire.

.. note::

    Si le programme ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur s'affiche : ¬´ wiringPi.h: No such file or directory ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softPwm.h>
    #include <stdio.h>

    #define ServoPin    1       // d√©finit le servomoteur sur GPIO1
    long Map(long value, long fromLow, long fromHigh, long toLow, long toHigh){
        return (toHigh-toLow)*(value-fromLow) / (fromHigh-fromLow) + toLow;
    }
    void setAngle(int pin, int angle){    // Cr√©e une fonction pour contr√¥ler l'angle du servomoteur.
        if(angle < 0)
            angle = 0;
        if(angle > 180)
            angle = 180;
        softPwmWrite(pin, Map(angle, 0, 180, 5, 25));   
    } 

    int main(void)
    {
        int i;
        if(wiringPiSetup() == -1){ // en cas d'√©chec de l'initialisation de wiringPi, affiche un message d'erreur √† l'√©cran
            printf("setup wiringPi failed !");
            return 1; 
        }
        softPwmCreate(ServoPin, 0, 200);       // initialise la broche PWM pour le servomoteur
        while(1){
            for(i=0;i<181;i++){     // fait tourner le servomoteur de 0 √† 180 degr√©s.

                delay(2);
            }
            delay(1000);
            for(i=181;i>-1;i--){    // fait tourner le servomoteur de 180 √† 0 degr√©s.

                delay(2);
            }
            delay(1000);
        }
        return 0;
    }

**Explication du code**

.. code-block:: c

    long Map(long value,long fromLow,long fromHigh,long toLow,long toHigh){
        return (toHigh-toLow)*(value-fromLow) / (fromHigh-fromLow) + toLow;
    }

Cr√©e une fonction `Map()` pour mapper la valeur dans le code suivant.

.. code-block:: c

    void setAngle(int pin, int angle){    // Cr√©e une fonction pour contr√¥ler l'angle du servomoteur.
        if(angle < 0)
            angle = 0;
        if(angle > 180)
            angle = 180;
        softPwmWrite(pin, Map(angle, 0, 180, 5, 25));   
    } 

Cr√©e une fonction `setAngle()` pour √©crire l'angle du servomoteur.

.. code-block:: c

    softPwmWrite(pin,Map(angle,0,180,5,25));  

Cette fonction permet de modifier le cycle de service du PWM.

Pour faire tourner le servomoteur de 0 √† 180¬∞, la largeur d'impulsion doit varier 
dans la plage de 0,5 ms √† 2,5 ms lorsque la p√©riode est de 20 ms ; dans la fonction 
`softPwmCreate()`, nous avons d√©fini la p√©riode √† 200 x 100 us = 20 ms, nous devons 
donc mapper 0 ~ 180 √† 5 x 100 us ~ 25 x 100 us.

Le prototype de cette fonction est illustr√© ci-dessous.

.. code-block:: 

    int softPwmCreate(int pin, int initialValue, int pwmRange);

**Param√®tre pin :** N'importe quelle broche GPIO du Raspberry Pi peut √™tre d√©finie comme broche PWM.

**Param√®tre initialValue :** La largeur d'impulsion initiale est √©gale √† initialValue fois 100 us.

**Param√®tre pwmRange :** La p√©riode du PWM est √©gale √† pwmRange fois 100 us.

