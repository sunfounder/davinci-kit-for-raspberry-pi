.. note::

    Bonjour, bienvenue dans la communaut√© SunFounder pour les passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et relevez les d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des conseils et tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Obtenez un acc√®s anticip√© aux nouvelles annonces de produits et √† des avant-premi√®res.
    - **R√©ductions sp√©ciales** : B√©n√©ficiez de r√©ductions exclusives sur nos derniers produits.
    - **Promotions festives et concours** : Participez √† des concours et promotions pendant les f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

.. _2.2.6_py_pi5:

2.2.5 Module MPU6050
=======================

Introduction
----------------

Le MPU-6050 est le premier et le seul dispositif de suivi de mouvement √† 6 axes 
au monde (3 axes de gyroscope et 3 axes d'acc√©l√©rom√®tre), con√ßu pour les smartphones, 
les tablettes et les capteurs portables r√©pondant aux exigences de faible consommation, 
de faible co√ªt et de haute performance.

Dans cette exp√©rience, nous utiliserons le bus I2C pour obtenir les valeurs du capteur 
d'acc√©l√©ration et du gyroscope du MPU6050 et les afficherons √† l'√©cran.


Composants n√©cessaires
-------------------------

Dans ce projet, nous aurons besoin des composants suivants : 

.. image:: ../python_pi5/img/2.2.6_mpu6050_list.png

.. raw:: html

   <br/>

Sch√©ma de c√¢blage
---------------------

Le module MPU6050 communique avec le microcontr√¥leur via l'interface de bus I2C. 
Les broches SDA1 et SCL1 doivent √™tre connect√©es aux broches correspondantes.

.. image:: ../python_pi5/img/2.2.6_mpu6050_schematic.png


Proc√©dure exp√©rimentale
--------------------------

**√âtape 1 :** Montez le circuit.

.. image:: ../python_pi5/img/2.2.6_mpu6050_circuit.png


**√âtape 2 :** Configurez l'I2C (consultez l'annexe :ref:`i2c_config`. Si l'I2C est d√©j√† configur√©, ignorez cette √©tape.)

**√âtape 3 :** Acc√©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python-pi5

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_mpu6050_zero.py

Lorsque le code est ex√©cut√©, l'angle de d√©viation des axes x et y, ainsi que 
l'acc√©l√©ration et la vitesse angulaire sur chaque axe, seront calcul√©s puis 
affich√©s √† l'√©cran.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, ex√©cutez la commande ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` appara√Æt, cela signifie que le module est mal c√¢bl√© ou endommag√©.

.. warning::

    En cas de message d'erreur ``RuntimeError: Cannot determine SOC peripheral base address``, veuillez consulter :ref:`faq_soc`.

**Code**

.. note::

    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez acc√©der au chemin source du code, comme ``davinci-kit-for-raspberry-pi/python-pi5``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   import smbus
   import math
   import time

   # Registres de gestion de l'alimentation
   power_mgmt_1 = 0x6b
   power_mgmt_2 = 0x6c

   def read_byte(adr):
       return bus.read_byte_data(address, adr)

   def read_word(adr):
       high = bus.read_byte_data(address, adr)
       low = bus.read_byte_data(address, adr+1)
       val = (high << 8) + low
       return val

   def read_word_2c(adr):
       val = read_word(adr)
       if (val >= 0x8000):
           return -((65535 - val) + 1)
       else:
           return val

   def dist(a,b):
       return math.sqrt((a*a)+(b*b))

   def get_y_rotation(x,y,z):
       radians = math.atan2(x, dist(y,z))
       return -math.degrees(radians)

   def get_x_rotation(x,y,z):
       radians = math.atan2(y, dist(x,z))
       return math.degrees(radians)


   bus = smbus.SMBus(1) # Initialisation du bus I2C
   address = 0x68       # Adresse obtenue avec la commande i2cdetect

   # Sortir le MPU6050 du mode veille
   bus.write_byte_data(address, power_mgmt_1, 0)

   while True:
       time.sleep(0.1)
       gyro_xout = read_word_2c(0x43)
       gyro_yout = read_word_2c(0x45)
       gyro_zout = read_word_2c(0x47)

       print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
       print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
       print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

       accel_xout = read_word_2c(0x3b)
       accel_yout = read_word_2c(0x3d)
       accel_zout = read_word_2c(0x3f)

       accel_xout_scaled = accel_xout / 16384.0
       accel_yout_scaled = accel_yout / 16384.0
       accel_zout_scaled = accel_zout / 16384.0

       print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
       print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
       print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

       print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
       print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

       time.sleep(1)


**Explication du code**

#. Lire les donn√©es envoy√©es par le MPU6050.

   .. code-block:: python

       def read_word(adr):
           high = bus.read_byte_data(address, adr)
           low = bus.read_byte_data(address, adr+1)
           val = (high << 8) + low
           return val

       def read_word_2c(adr):
           val = read_word(adr)
           if (val >= 0x8000):
               return -((65535 - val) + 1)
           else:
               return val

#. Calculer l'angle de d√©viation sur l'axe y.

   .. code-block:: python

       def get_y_rotation(x,y,z):
           radians = math.atan2(x, dist(y,z))
           return -math.degrees(radians)

#. Calculer l'angle de d√©viation sur l'axe x.

   .. code-block:: python

       def get_x_rotation(x,y,z):
           radians = math.atan2(y, dist(x,z))
           return math.degrees(radians)

#. Lire les valeurs des axes x, y et z du gyroscope, convertir les donn√©es en vitesse angulaire et les afficher.

   .. code-block:: python

       gyro_xout = read_word_2c(0x43)
       gyro_yout = read_word_2c(0x45)
       gyro_zout = read_word_2c(0x47)

       print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
       print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
       print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

#. Lire les valeurs des axes x, y et z de l'acc√©l√©rom√®tre, convertir les donn√©es en acc√©l√©ration (en unit√©s de gravit√©) et les afficher.

   .. code-block:: python

       accel_xout = read_word_2c(0x3b)
       accel_yout = read_word_2c(0x3d)
       accel_zout = read_word_2c(0x3f)

       accel_xout_scaled = accel_xout / 16384.0
       accel_yout_scaled = accel_yout / 16384.0
       accel_zout_scaled = accel_zout / 16384.0

       print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
       print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
       print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

#. Afficher les angles de d√©viation sur les axes x et y.

   .. code-block:: python

       print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
       print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

