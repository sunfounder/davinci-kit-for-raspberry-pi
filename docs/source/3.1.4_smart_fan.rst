.. note::

    Bonjour et bienvenue dans la communautÃ© SunFounder pour les passionnÃ©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionnÃ©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : RÃ©solvez vos problÃ¨mes aprÃ¨s-vente et vos dÃ©fis techniques grÃ¢ce Ã  l'aide de notre communautÃ© et de notre Ã©quipe.
    - **Apprendre & Partager** : Ã‰changez des astuces et des tutoriels pour perfectionner vos compÃ©tences.
    - **AperÃ§us exclusifs** : AccÃ©dez en avant-premiÃ¨re aux annonces de nouveaux produits et aux aperÃ§us exclusifs.
    - **RÃ©ductions spÃ©ciales** : Profitez de rÃ©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez Ã  des concours et des promotions spÃ©ciales pendant les fÃªtes.

    ðŸ‘‰ PrÃªt Ã  explorer et crÃ©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous dÃ¨s aujourd'hui !

3.1.4 Ventilateur intelligent
=============================

Introduction
----------------

Dans ce cours, nous allons utiliser des moteurs, des boutons et des thermistances 
pour crÃ©er un ventilateur intelligent manuel + automatique dont la vitesse de 
ventilation est rÃ©glable.

Composants
-------------

.. image:: img/list_Smart_Fan.png
    :align: center

SchÃ©ma de cÃ¢blage
----------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
GPIO5        Pin 29   21       5
GPIO6        Pin 31   22       6
GPIO13       Pin 33   23       13
============ ======== ======== ===

.. image:: img/Schematic_three_one4.png
    :width: 500
    :align: center

ProcÃ©dures expÃ©rimentales
-----------------------------

**Ã‰tape 1 :** Montez le circuit.

.. image:: img/image245.png
   :alt: Smart Fan_bb
   :width: 800
   :align: center

.. note::
    Le module d'alimentation peut utiliser une batterie de 9V avec le clip 
    de batterie 9V fourni dans le kit. InsÃ©rez le cavalier du module 
    d'alimentation dans les bandes de bus 5V de la breadboard.

.. image:: img/image118.jpeg
   :alt: \_MG_2084
   :width: 2.80694in
   :height: 0.94375in
   :align: center

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.4/

**Ã‰tape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.4_SmartFan.c -lwiringPi -lm

**Ã‰tape 4 :** ExÃ©cutez le fichier exÃ©cutable ci-dessus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'exÃ©cute, dÃ©marrez le ventilateur en appuyant sur le bouton. 
Chaque pression ajuste la vitesse d'un cran vers le haut ou vers le bas. Il y 
a **5** niveaux de vitesse : **0~4**. Lorsque la vitesse atteint le **4\ :sup:`Ã¨me`** 
niveau et que vous appuyez de nouveau, le ventilateur s'arrÃªte avec une vitesse de **0**.

.. note::

    Si cela ne fonctionne pas aprÃ¨s l'exÃ©cution ou si un message d'erreur apparaÃ®t : \"wiringPi.h: Aucun fichier ou dossier de ce type Â», veuillez vous rÃ©fÃ©rer Ã  :ref:`C code is not working?`.

Une variation de tempÃ©rature supÃ©rieure ou infÃ©rieure Ã  2â„ƒ entraÃ®ne automatiquement 
une augmentation ou une diminution d'un cran de la vitesse.


**Explication du code**

.. code-block:: c

    intÂ temperture(){
    Â Â Â Â unsignedÂ charÂ analogVal;
    Â Â Â Â doubleÂ Vr,Â Rt,Â temp,Â cel,Â Fah;
    Â Â Â Â analogValÂ =Â get_ADC_Result(0);
    Â Â Â Â VrÂ =Â 5Â *Â (double)(analogVal)Â /Â 255;
    Â Â Â Â RtÂ =Â 10000Â *Â (double)(Vr)Â /Â (5Â -Â (double)(Vr));
    Â Â Â Â tempÂ =Â 1Â /Â (((log(Rt/10000))Â /Â 3950)+(1Â /Â (273.15Â +Â 25)));
    Â Â Â Â celÂ =Â tempÂ -Â 273.15;
    Â Â Â Â FahÂ =Â celÂ *Â 1.8Â +32;
    Â Â Â Â intÂ t=cel;
    Â Â Â Â returnÂ t;
    }

La fonction `temperture()` convertit les valeurs de la thermistance lues par l'ADC0834 
en valeurs de tempÃ©rature. Pour plus de dÃ©tails, reportez-vous Ã  :ref:`2.2.2 Thermistor`.

.. code-block:: c

    intÂ motor(intÂ level){
    Â Â Â Â if(level==0){
    Â Â Â Â Â Â Â Â digitalWrite(MotorEnable,LOW);
    Â Â Â Â Â Â Â Â returnÂ 0;
    Â Â Â Â }
    Â Â Â Â ifÂ (level>=4){
    Â Â Â Â Â Â Â Â levelÂ =4;
    Â Â Â Â }
    Â Â Â Â digitalWrite(MotorEnable,HIGH);
    Â Â Â Â softPwmWrite(MotorPin1,Â level*25);
    Â Â Â Â returnÂ level;Â Â Â Â 
    }

Cette fonction contrÃ´le la vitesse de rotation du moteur. La plage du **niveau** : **0-4** 
(le niveau **0** arrÃªte le moteur). Chaque ajustement de niveau reprÃ©sente un changement de
 **25%** de la vitesse du ventilateur.

.. code-block:: c

    intÂ main(void)
    {
    Â Â Â Â setup();
    Â Â Â Â intÂ currentState,lastState=0;
    Â Â Â Â intÂ levelÂ =Â 0;
    Â Â Â Â intÂ currentTemp,markTemp=0;
    Â Â Â Â while(1){
    Â Â Â Â Â Â Â Â currentState=digitalRead(BtnPin);
    Â Â Â Â Â Â Â Â currentTemp=temperture();
    Â Â Â Â Â Â Â Â ifÂ (currentTemp<=0){continue;}
    Â Â Â Â Â Â Â Â ifÂ (currentState==1&&lastState==0){
    Â Â Â Â Â Â Â Â Â Â Â Â level=(level+1)%5;
    Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â delay(500);
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â lastState=currentState;
    Â Â Â Â Â Â Â Â ifÂ (level!=0){
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp<=-2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level-1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (currentTemp-markTemp>=2){
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â level=level+1;
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTemp;
    Â Â Â Â Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â }
    Â Â Â Â Â Â Â Â level=motor(level);
    Â Â Â Â }
    Â Â Â Â returnÂ 0;
    }

La fonction **main()** contient le processus global du programme :



1) Lecture constante de l'Ã©tat du bouton et de la tempÃ©rature actuelle.

2) Chaque pression du bouton incrÃ©mente le niveau de **+1** et met Ã  jour la tempÃ©rature. 
Les niveaux vont de **1 Ã  4**.

3) Tant que le ventilateur fonctionne (niveau diffÃ©rent de **0**), la tempÃ©rature est 
surveillÃ©e. Un changement de **2â„ƒ\ +** entraÃ®ne une augmentation ou une diminution du niveau.

4) Le moteur ajuste sa vitesse de rotation en fonction du **niveau**.


**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Ã‰tape 2 :** AccÃ©dez au dossier du code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/python

**Ã‰tape 3 :** ExÃ©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 3.1.4_SmartFan.py

Lorsque le code s'exÃ©cute, dÃ©marrez le ventilateur en appuyant sur le bouton. Chaque 
pression ajuste la vitesse d'un cran vers le haut ou vers le bas. Il y a **5** niveaux 
de vitesse : **0~4**. Lorsque le ventilateur est rÃ©glÃ© sur le **4\ :sup:`Ã¨me`** niveau 
de vitesse et que vous appuyez de nouveau, il s'arrÃªte avec une vitesse de **0**.


Une variation de tempÃ©rature supÃ©rieure ou infÃ©rieure Ã  2â„ƒ entraÃ®ne automatiquement une 
augmentation ou une diminution d'un cran de la vitesse.

**Code**

.. note::

    Vous pouvez **modifier/rÃ©initialiser/copier/exÃ©cuter/arrÃªter** le code ci-dessous. 
    Mais avant cela, vous devez vous rendre sur le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import ADC0834
    import math

    # Configuration des broches
    MotorPin1   = 5
    MotorPin2   = 6
    MotorEnable = 13
    BtnPin  = 22


    def setup():
        global p_M1,p_M2
        ADC0834.setup()
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(MotorPin1, GPIO.OUT)
        GPIO.setup(MotorPin2, GPIO.OUT)
        p_M1=GPIO.PWM(MotorPin1,2000)
        p_M2=GPIO.PWM(MotorPin2,2000)
        p_M1.start(0)
        p_M2.start(0)
        GPIO.setup(MotorEnable, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(BtnPin, GPIO.IN)

    def temperature():
        analogVal = ADC0834.getResult()
        Vr = 5 * float(analogVal) / 255
        Rt = 10000 * Vr / (5 - Vr)
        temp = 1/(((math.log(Rt / 10000)) / 3950) + (1 / (273.15+25)))
        Cel = temp - 273.15
        Fah = Cel * 1.8 + 32
        return Cel

    def motor(level):
        if level == 0:
            GPIO.output(MotorEnable, GPIO.LOW)
            return 0
        if level>=4:
            level = 4
        GPIO.output(MotorEnable, GPIO.HIGH)
        p_M1.ChangeDutyCycle(level*25)
        return level


    def main():
        lastState=0
        level=0
        markTemp = temperature()
        while True:
            currentState =GPIO.input(BtnPin)
            currentTemp=temperature()
            if currentState == 1 and lastState == 0:
                level=(level+1)%5
                markTemp = currentTemp
                time.sleep(0.5)
            lastState=currentState
            if level!=0:
                if currentTemp-markTemp <= -2:
                    level = level -1
                    markTemp=currentTemp            
                if currentTemp-markTemp >= 2:
                    level = level +1
                    markTemp=currentTemp             
            level = motor(level)
            

    def destroy():
        GPIO.output(MotorEnable, GPIO.LOW)
        p_M1.stop()
        p_M2.stop()
        GPIO.cleanup()    

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Explication du code**

.. code-block:: python

    defÂ temperature():
    Â Â Â Â analogValÂ =Â ADC0834.getResult()
    Â Â Â Â VrÂ =Â 5Â *Â float(analogVal)Â /Â 255
    Â Â Â Â RtÂ =Â 10000Â *Â VrÂ /Â (5Â -Â Vr)
    Â Â Â Â tempÂ =Â 1/(((math.log(RtÂ /Â 10000))Â /Â 3950)Â +Â (1Â /Â (273.15+25)))
    Â Â Â Â CelÂ =Â tempÂ -Â 273.15
    Â Â Â Â FahÂ =Â CelÂ *Â 1.8Â +Â 32
    Â Â Â Â returnÂ Cel

La fonction `temperature()` convertit les valeurs de la thermistance lues 
par **ADC0834** en valeurs de tempÃ©rature. Pour plus de dÃ©tails, reportez-vous 
Ã  :ref:`2.2.2 Thermistor`.

.. code-block:: python

    defÂ motor(level):
    Â Â Â Â ifÂ levelÂ ==Â 0:
    Â Â Â Â Â Â Â Â GPIO.output(MotorEnable,Â GPIO.LOW)
    Â Â Â Â Â Â Â Â returnÂ 0
    Â Â Â Â ifÂ levelÂ >=Â 4:
    Â Â Â Â Â Â Â Â levelÂ =Â 4
    Â Â Â Â GPIO.output(MotorEnable,Â GPIO.HIGH)
    Â Â Â Â p_M1.ChangeDutyCycle(levelÂ *Â 25)
    Â Â Â Â returnÂ level

Cette fonction contrÃ´le la vitesse de rotation du moteur. La plage de **niveau** : 
**0-4** (le niveau **0** arrÃªte le moteur). Chaque ajustement de niveau reprÃ©sente un 
changement de **25%** de la vitesse du ventilateur.

.. code-block:: python

    defÂ main():
    Â Â Â Â lastState=0
    Â Â Â Â level=0
    Â Â Â Â markTempÂ =Â temperature()
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentStateÂ =GPIO.input(BtnPin)
    Â Â Â Â Â Â Â Â currentTemp=temperature()
    Â Â Â Â Â Â Â Â ifÂ currentStateÂ ==Â 1Â andÂ lastStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â Â Â Â Â level=(level+1)%5
    Â Â Â Â Â Â Â Â Â Â Â Â markTempÂ =Â currentTemp
    Â Â Â Â Â Â Â Â Â Â Â Â time.sleep(0.5)
    Â Â Â Â Â Â Â Â lastState=currentState
    Â Â Â Â Â Â Â Â ifÂ level!=0:
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ currentTemp-markTempÂ <=Â -2:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â levelÂ =Â levelÂ -1
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTempÂ Â Â Â Â Â Â Â Â Â Â Â 
    Â Â Â Â Â Â Â Â Â Â Â Â ifÂ currentTemp-markTempÂ >=Â 2:
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â levelÂ =Â levelÂ +1
    Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â markTemp=currentTempÂ Â Â Â Â Â Â Â Â Â Â Â Â 
    Â Â Â Â Â Â Â Â levelÂ =Â motor(level)

La fonction **main()** suit le processus global du programme :

1) Lecture constante de l'Ã©tat du bouton et de la tempÃ©rature actuelle.

2) Chaque pression sur le bouton augmente le **niveau** de **+1** et met Ã  jour la tempÃ©rature. Les niveaux vont de **1 Ã  4**.

3) Tant que le ventilateur fonctionne (niveau diffÃ©rent de **0**), la tempÃ©rature est surveillÃ©e. Une variation de **2â„ƒ\ +** entraÃ®ne une augmentation ou une diminution du niveau.

4) Le moteur ajuste sa vitesse de rotation en fonction du **niveau**.

Image du phÃ©nomÃ¨ne
----------------------

.. image:: img/image246.png
   :align: center