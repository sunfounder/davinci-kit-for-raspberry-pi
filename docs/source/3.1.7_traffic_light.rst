.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder pour les passionn√©s de Raspberry Pi, Arduino et ESP32 sur Facebook ! Plongez dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et vos d√©fis techniques gr√¢ce √† l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre & Partager** : √âchangez des astuces et des tutoriels pour perfectionner vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus exclusifs.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos nouveaux produits.
    - **Promotions festives et concours** : Participez √† des concours et √† des promotions sp√©ciales pendant les f√™tes.

    üëâ Pr√™t √† explorer et cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

3.1.7 Feu de circulation
========================

Introduction
---------------

Dans ce projet, nous allons utiliser des LEDs de trois couleurs pour simuler le changement 
des feux de circulation, et un afficheur 7 segments √† quatre chiffres sera utilis√© pour 
afficher le d√©compte de chaque √©tat du feu.

Composants
------------

.. image:: img/list_Traffic_Light.png
    :align: center

Sch√©ma de c√¢blage
--------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
SPIMOSI      Pin 19   12       10
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPICE0       Pin 24   10       8
SPICE1       Pin 26   11       7
============ ======== ======== ===

.. image:: img/Schematic_three_one7.png
   :align: center

Proc√©dures exp√©rimentales
------------------------------

**√âtape 1 :** Montez le circuit.

.. image:: img/image254.png
   :width: 800

**Pour les utilisateurs du langage C**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/davinci-kit-for-raspberry-pi/c/3.1.7/

**√âtape 3 :** Compilez.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.7_TrafficLight.c -lwiringPi

**√âtape 4 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Lorsque le code s'ex√©cute, les LEDs simuleront le changement de couleur des feux de 
circulation. D'abord, la LED rouge s'allume pendant 60s, puis la LED verte pendant 30s, 
et ensuite la LED jaune pendant 5s. Apr√®s cela, la LED rouge se rallume pendant 60s. 
Cette s√©rie d'actions se r√©p√©tera continuellement.

.. note::

    Si cela ne fonctionne pas apr√®s l'ex√©cution ou si un message d'erreur appara√Æt : ¬´ wiringPi.h: Aucun fichier ou dossier de ce type ¬ª, veuillez vous r√©f√©rer √† :ref:`C code is not working?`.

**Explication du code**

.. code-block:: c

    #define     SDI     5 
    #define     RCLK    4  
    #define     SRCLK    1   

    const int placePin[] = {12, 3, 2, 0};
    unsigned char number[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90};

    void pickDigit(int digit);
    void hc595_shift(int8_t data);
    void clearDisplay();
    void display();

Ces codes sont utilis√©s pour r√©aliser l'affichage des chiffres sur un afficheur 7 segments 
√† 4 chiffres. R√©f√©rez-vous √† :ref:`1.1.5 4-Digit 7-Segment Display` du document pour plus 
de d√©tails. Ici, les codes servent √† afficher le d√©compte du temps des feux de circulation.

.. code-block:: c

    const int ledPin[] = {6, 10, 11};  

    int colorState = 0;

    void lightup()
    {
        for(int i=0;i<3;i++){
            digitalWrite(ledPin[i],HIGH);
        }
        digitalWrite(ledPin[colorState],LOW);    
    }

Ces codes servent √† allumer et √©teindre les LEDs.

.. code-block:: c

    int greenLight = 30;
    int yellowLight = 5;
    int redLight = 60;
    int colorState = 0;
    char *lightColor[]={"Red","Green","Yellow"};
    int counter = 60;

    void timer(int timer1){       // Fonction du minuteur
        if(timer1 == SIGALRM){   
            counter --;         
            alarm(1); 
            if(counter == 0){
                if(colorState == 0) counter = greenLight;
                if(colorState == 1) counter = yellowLight;
                if(colorState == 2) counter = redLight;
                colorState = (colorState+1)%3; 
            }
            printf("counter : %d \t light color: %s \n",counter,lightColor[colorState]);
        }
    }

Ces codes permettent de contr√¥ler le minuteur. R√©f√©rez-vous √† :ref:`1.1.5 4-Digit 7-Segment Display` 
pour plus de d√©tails. Ici, lorsque le minuteur atteint z√©ro, `colorState` change pour alterner les LEDs,
 et le minuteur est r√©initialis√© √† une nouvelle valeur.

.. code-block:: c

    void loop()
    {
        while(1){
        display();
        lightup(); 
        }
    }

    int main(void)
    {
        //‚Ä¶
        signal(SIGALRM,timer);  
        alarm(1); 
        loop();
        return 0;
    }

Le minuteur est lanc√© dans la fonction `main()`. Dans la fonction `loop()`, une boucle
 **while(1)** est utilis√©e pour appeler les fonctions de l'afficheur 7 segments et des LEDs.


**Pour les utilisateurs du langage Python**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python/

**√âtape 3 :** Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 3.1.7_TrafficLight.py

Lorsque le code s'ex√©cute, les LEDs simuleront le changement de couleur des feux de 
circulation. D'abord, la LED rouge s'allume pendant 60s, puis la LED verte pendant 30s, 
et ensuite la LED jaune pendant 5s. Apr√®s cela, la LED rouge se rallume pendant 60s. 
Ce cycle se r√©p√©tera continuellement. Pendant ce temps, l'afficheur 7 segments √† 4 chiffres 
affiche en continu le d√©compte du temps.

**Code**

.. note::

    Vous pouvez **modifier/r√©initialiser/copier/ex√©cuter/arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre sur le chemin du code source comme ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    import threading

    # D√©finir les broches connect√©es au 74HC595
    SDI   = 24      # entr√©e de donn√©es s√©rie (DS)
    RCLK  = 23     # entr√©e de l'horloge de m√©moire (STCP)
    SRCLK = 18      # entr√©e de l'horloge du registre √† d√©calage (SHCP)
    number = (0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90)

    placePin = (10,22,27,17)
    ledPin =(25,8,7)

    greenLight = 30
    yellowLight = 5
    redLight = 60
    lightColor=("Red","Green","Yellow")

    colorState=0
    counter = 60
    timer1 = 0


    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT)
        GPIO.setup(RCLK, GPIO.OUT)
        GPIO.setup(SRCLK, GPIO.OUT)
        for pin in placePin:
            GPIO.setup(pin,GPIO.OUT)
        for pin in ledPin:
            GPIO.setup(pin,GPIO.OUT)
        global timer1
        timer1 = threading.Timer(1.0,timer)
        timer1.start()

    def clearDisplay():
        for i in range(8):
            GPIO.output(SDI, 1)
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def hc595_shift(data):
        for i in range(8):
            GPIO.output(SDI, 0x80 & (data << i))
            GPIO.output(SRCLK, GPIO.HIGH)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        GPIO.output(RCLK, GPIO.LOW)

    def pickDigit(digit):
        for i in placePin:
            GPIO.output(i,GPIO.LOW)
        GPIO.output(placePin[digit], GPIO.HIGH)

    def timer():        # Fonction minuteur
        global counter
        global colorState
        global timer1
        timer1 = threading.Timer(1.0,timer)
        timer1.start()
        counter-=1
        if (counter is 0):
            if(colorState is 0):
                counter= greenLight
            if(colorState is 1):
                counter=yellowLight
            if (colorState is 2):
                counter=redLight
            colorState=(colorState+1)%3
        print ("counter : %d    color: %s "%(counter,lightColor[colorState]))

    def lightup():
        global colorState
        for i in range(0,3):
            GPIO.output(ledPin[i], GPIO.HIGH)
        GPIO.output(ledPin[colorState], GPIO.LOW)

    def display():
        global counter

        a = counter % 10000 // 1000 + counter % 1000 // 100
        b = counter % 10000 // 1000 + counter % 1000 // 100 + counter % 100 // 10
        c = counter % 10000 // 1000 + counter % 1000 // 100 + counter % 100 // 10 + counter % 10

        if (counter % 10000//1000 == 0):
            clearDisplay()
        else:
            clearDisplay()
            pickDigit(3)
            hc595_shift(number[counter % 10000//1000])

        if (a == 0):
            clearDisplay()
        else:
            clearDisplay()
            pickDigit(2)
            hc595_shift(number[counter % 1000//100])

        if (b == 0):
            clearDisplay()
        else:
            clearDisplay()
            pickDigit(1)
            hc595_shift(number[counter % 100//10])

        if(c == 0):
            clearDisplay()
        else:
            clearDisplay()
            pickDigit(0)
            hc595_shift(number[counter % 10])

    def loop():
        while True:
            display()
            lightup()

    def destroy():   # Quand "Ctrl+C" est press√©, la fonction est ex√©cut√©e.
        global timer1
        GPIO.cleanup()
        timer1.cancel()      # Annuler le minuteur

    if __name__ == '__main__': # Programme d√©marrant ici
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()


**Explication du code**

.. code-block:: python

    SDI   = 24      # entr√©e de donn√©es s√©rie (DS)
    RCLK  = 23     # entr√©e de l'horloge de m√©moire (STCP)
    SRCLK = 18      # entr√©e de l'horloge du registre √† d√©calage (SHCP)
    number = (0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90)
    placePin = (10,22,27,17)   

    def clearDisplay():
    def hc595_shift(data): 
    def pickDigit(digit):
    def display():

Ces codes sont utilis√©s pour r√©aliser l'affichage des chiffres sur un afficheur 7 
segments √† 4 chiffres. R√©f√©rez-vous √† :ref:`1.1.5 4-Digit 7-Segment Display` du 
document pour plus de d√©tails. Ici, les codes servent √† afficher le d√©compte du temps 
des feux de circulation.

.. code-block:: python

    ledPin =(25,8,7) 
    colorState=0
        
    def lightup():
        global colorState
        for i in range(0,3):
            GPIO.output(ledPin[i], GPIO.HIGH)
        GPIO.output(ledPin[colorState], GPIO.LOW)

Ces codes permettent de g√©rer l'allumage et l'extinction des LEDs.

.. code-block:: python

    greenLight = 30
    yellowLight = 5
    redLight = 60
    lightColor=("Red","Green","Yellow")

    colorState=0
    counter = 60      
    timer1 = 0         

    def timer():        # Fonction minuteur
        global counter
        global colorState
        global timer1
        timer1 = threading.Timer(1.0,timer)  
        timer1.start()     
        counter-=1                          
        if (counter is 0):
            if(colorState is 0):
                counter= greenLight
            if(colorState is 1):
                counter=yellowLight
            if (colorState is 2):
                counter=redLight
            colorState=(colorState+1)%3
        print ("counter : %d    color: %s "%(counter,lightColor[colorState]))

Ces codes permettent de contr√¥ler le minuteur. R√©f√©rez-vous √† :ref:`1.1.5 4-Digit 7-Segment Display` 
pour plus de d√©tails. Ici, lorsque le minuteur atteint z√©ro, `colorState` change pour alterner les LEDs, 
et le minuteur est r√©initialis√© √† une nouvelle valeur.

.. code-block:: python

    def setup():
        # ... 
        global timer1
        timer1 = threading.Timer(1.0,timer)   
        timer1.start()  

    def loop():
        while True:
            display()
            lightup()
            
    def destroy():   # Quand "Ctrl+C" est press√©, la fonction est ex√©cut√©e.
        global timer1
        GPIO.cleanup()      
        timer1.cancel()      # Annuler le minuteur

    if __name__ == '__main__': # Programme d√©marrant ici
        setup() 
        try:
            loop()  
        except KeyboardInterrupt:  
            destroy()  

Dans la fonction `setup()`, le minuteur est d√©marr√©. Dans la fonction `loop()`, une 
boucle ``while True`` est utilis√©e pour appeler les fonctions relatives de l'afficheur 
7 segments et des LEDs de mani√®re circulaire.

Image du ph√©nom√®ne
----------------------

.. image:: img/IMG_8319.jpg
    :width: 800
    :align: center