.. note::

    Bonjour et bienvenue dans la communaut√© SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts sur Facebook ! Plongez plus profond√©ment dans l'univers de Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi nous rejoindre ?**

    - **Support d'experts** : R√©solvez vos probl√®mes apr√®s-vente et vos d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprenez et partagez** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Profitez d'un acc√®s anticip√© aux annonces de nouveaux produits et √† des avant-premi√®res.
    - **R√©ductions exclusives** : B√©n√©ficiez de r√©ductions sur nos derniers produits.
    - **Promotions festives et cadeaux** : Participez √† des promotions et √† des cadeaux lors des f√™tes.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez sur [|link_sf_facebook|] et rejoignez-nous d√®s aujourd'hui !

1.1.1 LED clignotante
===========================

Introduction
---------------

Dans cette le√ßon, nous allons apprendre √† programmer une LED clignotante.
Gr√¢ce √† vos param√®tres, votre LED peut produire une s√©rie de ph√©nom√®nes int√©ressants. Allons-y !

Composants
-------------

.. image:: img/blinking_led_list.png
    :width: 800
    :align: center

.. note::
    Pour que tout se passe bien, vous devez disposer de votre propre Raspberry Pi, 
    carte TF et alimentation Raspberry Pi.

Principe
------------

**Plaque d'essai**

Une plaque d'essai est une base de construction pour le prototypage √©lectronique. 
Elle est utilis√©e pour construire et tester des circuits rapidement avant de finaliser 
un design. Elle comporte de nombreux trous dans lesquels peuvent √™tre ins√©r√©s des 
composants tels que des circuits int√©gr√©s (CI), des r√©sistances et des fils de connexion. 
La plaque d'essai permet de brancher et de retirer facilement les composants.

L'image montre la structure interne d'une plaque d'essai compl√®te. Bien que les trous 
semblent ind√©pendants, ils sont en r√©alit√© connect√©s entre eux par des bandes m√©talliques 
√† l'int√©rieur.

.. image:: img/image41.png

**LED**

Une LED est un type de diode. Elle ne brillera que si sa patte longue est connect√©e 
au p√¥le positif et sa patte courte au p√¥le n√©gatif.

.. |image42| image:: img/image42.png

.. |image43| image:: img/image43.png

|image42|\ |image43|

La LED ne doit pas √™tre connect√©e directement √† l'alimentation, car cela pourrait 
endommager le composant. Une r√©sistance de 160Œ© ou plus (pour un fonctionnement en 5V) 
doit √™tre plac√©e en s√©rie dans le circuit.

**R√©sistance**

Une r√©sistance est un √©l√©ment √©lectronique qui limite le courant dans une branche de 
circuit. Une r√©sistance fixe est un type de r√©sistance dont la valeur ne peut pas √™tre 
modifi√©e, tandis que celle d'un potentiom√®tre ou d'une r√©sistance variable peut √™tre ajust√©e.

Dans ce kit, nous utilisons des r√©sistances fixes. Elles sont essentielles pour prot√©ger 
les composants connect√©s dans le circuit. Les images ci-dessous montrent une r√©sistance 
de 220Œ© et deux symboles de circuit couramment utilis√©s pour repr√©senter une r√©sistance. 
L'unit√© de la r√©sistance est l'ohm (Œ©), et les unit√©s sup√©rieures incluent KŒ© et MŒ©. 
Voici leurs √©quivalences : 1 MŒ© = 1000 KŒ©, 1 KŒ© = 1000 Œ©. En g√©n√©ral, la valeur de la 
r√©sistance est marqu√©e dessus. Si vous voyez ces symboles dans un circuit, cela signifie 
qu'une r√©sistance est pr√©sente.

.. image:: img/image44.png

.. |image45| image:: img/image45.png

.. |image46| image:: img/image46.png

|image45|\ |image46|

Pour utiliser une r√©sistance, il est important de conna√Ætre sa valeur. Voici deux 
m√©thodes : observer les bandes color√©es sur la r√©sistance ou utiliser un multim√®tre 
pour mesurer la valeur. Nous recommandons la premi√®re m√©thode, plus rapide et pratique. 
Utilisez un multim√®tre pour mesurer la r√©sistance si n√©cessaire.

Comme montr√© sur la carte, chaque couleur repr√©sente un chiffre.

.. image:: img/image47.jpeg

Sch√©ma de montage
---------------------

Dans cette exp√©rience, connectez une r√©sistance de 220Œ© √† l'anode (la patte longue de la 
LED), puis reliez la r√©sistance √† 3,3V, et connectez la cathode (la patte courte) de la 
LED au GPIO17 du Raspberry Pi. Pour allumer la LED, nous devons r√©gler GPIO17 sur bas (0V). 
Nous pouvons obtenir ce comportement par programmation.

.. note::

    **Pin11** d√©signe la 11e broche du Raspberry Pi de gauche √† droite, et ses num√©ros de 
    broches correspondants **wiringPi** et **BCM** sont indiqu√©s dans le tableau ci-dessous.

Dans le contenu li√© au langage C, nous consid√©rons que GPIO0 est √©quivalent √† 0 dans 
wiringPi. Dans le contenu Python, BCM 17 correspond √† 17 dans la colonne BCM du tableau 
suivant. Ils correspondent √©galement √† la 11e broche du Raspberry Pi, Pin 11.

============ ======== ======== ====
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ====

.. image:: img/image48.png
    :width: 800
    :align: center

Proc√©dures exp√©rimentales
----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: img/image49.png
    :width: 800
    :align: center

Pour les utilisateurs du langage C
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code.

1) Si vous utilisez un √©cran, nous vous recommandons de suivre les √©tapes suivantes.

Acc√©dez √† **~/** et trouvez le dossier **davinci-kit-for-raspberry-pi**.

Trouvez le dossier **C**, faites un clic droit dessus et s√©lectionnez **Ouvrir dans le Terminal**.

.. image:: img/image50.png
    :width: 800
    :align: center

Une fen√™tre appara√Ætra comme ci-dessous. Vous √™tes maintenant dans le chemin du code **1.1.1_BlinkingLed.c**.

.. image:: img/image51.png
    :width: 800
    :align: center

Dans les prochaines le√ßons, nous utiliserons une commande pour acc√©der au fichier de 
code au lieu d'un clic droit. Cependant, vous pouvez choisir la m√©thode que vous pr√©f√©rez.

2) Si vous vous connectez au Raspberry Pi √† distance, utilisez la commande ``cd`` pour changer de r√©pertoire :

.. raw:: html

   <run></run>

.. code-block::

   cd ~/davinci-kit-for-raspberry-pi/c/1.1.1/

.. note::
    Changez le r√©pertoire pour acc√©der au chemin du code de cette exp√©rience via cd.

Dans tous les cas, vous √™tes maintenant dans le dossier C. Les √©tapes suivantes, bas√©es 
sur ces deux m√©thodes, sont les m√™mes. Continuons.

**√âtape 3 :** Compilez le code.

.. raw:: html

   <run></run>

.. code-block::

   gcc 1.1.1_BlinkingLed.c -o BlinkingLed -lwiringPi

.. note::
    gcc est le GNU Compiler Collection. Ici, il sert √† compiler le fichier 
    C *1_BlinkingLed.c* et √† g√©n√©rer un fichier ex√©cutable.

Dans la commande, ``-o`` signifie output (le caract√®re imm√©diatement apr√®s -o est 
le nom du fichier ex√©cutable g√©n√©r√© apr√®s compilation, ici nomm√© ``BlinkingLed``), 
et ``-lwiringPi`` permet de charger la biblioth√®que wiringPi (``l`` est l'abr√©viation 
de library).

**√âtape 4 :** Ex√©cutez le fichier ex√©cutable g√©n√©r√© √† l'√©tape pr√©c√©dente.

.. raw:: html

   <run></run>

.. code-block::

   sudo ./BlinkingLed

.. note::

   Pour contr√¥ler les GPIO, vous devez ex√©cuter le programme avec la commande sudo 
   (superuser do). Le ``./`` indique le r√©pertoire actuel. La commande compl√®te 
   ex√©cute donc ``BlinkingLed`` dans le r√©pertoire actuel.

.. image:: img/image52.png
    :width: 800
    :align: center

Apr√®s ex√©cution du code, vous verrez la LED clignoter.

.. note::

   Si cela ne fonctionne pas apr√®s ex√©cution ou si un message d'erreur du type : "wiringPi.h: No such file or directory" appara√Æt, veuillez consulter :ref:`C code is not working?`.

Si vous souhaitez modifier le fichier de code ``1.1.1_BlinkingLed.c``, appuyez sur 
``Ctrl + C`` pour arr√™ter l'ex√©cution du code. Tapez ensuite la commande suivante 
pour l'ouvrir :

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.c

.. note::
    nano est un outil d'√©dition de texte. Cette commande ouvre le fichier de code 
    ``1.1.1_BlinkingLed.c`` avec cet outil.

Appuyez sur ``Ctrl+X`` pour quitter. Si vous avez modifi√© le code, une invite vous 
demandera si vous souhaitez enregistrer les modifications. Tapez ``Y`` (enregistrer) 
ou ``N`` (ne pas enregistrer), puis appuyez sur ``Entr√©e`` pour quitter. R√©p√©tez les 
√©tapes ¬´ √âtape 3 ¬ª et ¬´ √âtape 4 ¬ª pour voir l'effet apr√®s modification.

.. image:: img/image53.png
    :width: 800
    :align: center

**Code**

Le code du programme est le suivant :

.. code-block:: c

   #include <wiringPi.h>  
   #include <stdio.h>
   #define LedPin      0
   int main(void)
   {
      // Si l'initialisation de wiringPi √©choue, afficher un message √† l'√©cran
      if(wiringPiSetup() == -1){
         printf("setup wiringPi failed !");
         return 1;
      }
      pinMode(LedPin, OUTPUT); // D√©finir LedPin comme sortie pour y √©crire une valeur
      while(1){
         // LED allum√©e
         digitalWrite(LedPin, LOW);
         printf("...LED on\n");
         delay(500);
         // LED √©teinte
         digitalWrite(LedPin, HIGH);
         printf("LED off...\n");
         delay(500);
      }
      return 0;
   }

**Explication du code**

.. code-block:: c

   include <wiringPi.h>

La biblioth√®que de gestion mat√©rielle con√ßue pour le langage C du Raspberry Pi 
permet l'initialisation du mat√©riel, la gestion des E/S, du PWM, etc.

.. code-block:: c

   #include <stdio.h>

Biblioth√®que d'entr√©es/sorties standard. La fonction printf utilis√©e pour afficher 
des donn√©es √† l'√©cran est impl√©ment√©e via cette biblioth√®que. Il existe de nombreuses 
autres fonctions √† explorer.

.. code-block:: c

   #define LedPin 0

La broche GPIO17 du T_Extension Board correspond √† GPIO0 dans wiringPi. Nous assignons 
GPIO0 √† LedPin, qui repr√©sentera GPIO0 dans le code.

.. code-block:: c

    if(wiringPiSetup() == -1){
        printf("setup wiringPi failed !");
        return 1;

Cette fonction initialise wiringPi en supposant que le programme utilise la num√©rotation 
des broches de wiringPi.

Cette fonction doit √™tre appel√©e avec des privil√®ges root.
Si l'initialisation √©choue, un message est affich√© √† l'√©cran. La fonction "return" permet 
de sortir de la fonction courante. Utiliser return dans la fonction main() termine le 
programme.

.. code-block:: c

   pinMode(LedPin, OUTPUT);

D√©finir LedPin comme sortie pour y √©crire une valeur.

.. code-block:: c

   digitalWrite(LedPin, LOW);

D√©finir GPIO0 √† 0V (niveau bas). Comme la cathode de la LED est connect√©e √† GPIO0, 
la LED s'allumera si GPIO0 est en niveau bas. Inversement, en le mettant en niveau 
haut (digitalWrite (LedPin, HIGH)), la LED s'√©teindra.

.. code-block:: c

   printf("...LED¬†off\n");

La fonction printf est une fonction standard et son prototype est d√©fini dans le fichier 
d'en-t√™te "stdio.h". La cha√Æne de contr√¥le de format est utilis√©e pour sp√©cifier le format 
de sortie, et se compose de cha√Ænes format√©es et non format√©es. Ce qui est utilis√© ici est 
une cha√Æne non format√©e, suivie de "\n" pour indiquer un retour √† la ligne.

.. code-block:: c

   delay(500);

Le d√©lai (500) maintient l'√©tat actuel (HAUT ou BAS) pendant 500ms.

C'est une fonction qui suspend le programme pendant une certaine dur√©e. La vitesse du 
programme est d√©termin√©e par le mat√©riel. Ici, nous allumons ou √©teignons la LED. 
Sans cette fonction, le programme s'ex√©cuterait tr√®s rapidement et en boucle continue. 
Nous utilisons donc la fonction de d√©lai pour faciliter l'√©criture et le d√©bogage du 
programme.

.. code-block:: c

   return 0;

Ce code se trouve √† la fin de la fonction main(), indiquant que le programme se termine avec succ√®s.

Pour les utilisateurs de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**√âtape 2 :** Acc√©dez au dossier du code et ex√©cutez-le.

1. Si vous utilisez un √©cran, suivez les √©tapes suivantes.

Trouvez le fichier 1.1.1_BlinkingLed.py et double-cliquez dessus pour l'ouvrir. Vous √™tes maintenant dans le fichier.

Cliquez sur **Ex√©cuter** ->\ **Ex√©cuter le module** dans la fen√™tre et le contenu suivant 
appara√Ætra.

Pour arr√™ter l'ex√©cution, cliquez simplement sur le bouton X en haut √† droite pour fermer 
la fen√™tre, puis vous reviendrez au code. Si vous modifiez le code, avant de cliquer sur
 **Ex√©cuter le module (F5)**, vous devez l'enregistrer d'abord. Ensuite, vous pourrez voir 
 les r√©sultats.

2. Si vous vous connectez √† distance au Raspberry Pi, tapez la commande suivante :

.. raw:: html

   <run></run>

.. code-block::

   cd ~/davinci-kit-for-raspberry-pi/python

.. note::
    Changez le r√©pertoire vers le chemin du code de cette exp√©rience via ``cd``.

**√âtape 3 :** Ex√©cutez le code

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 1.1.1_BlinkingLed.py

.. note::
    Ici, sudo signifie superuser do, et python signifie ex√©cuter le fichier avec Python.

Apr√®s l'ex√©cution du code, vous verrez la LED clignoter.

**√âtape 4 :** Si vous souhaitez modifier le fichier de code 1.1.1_BlinkingLed.py, 
appuyez sur ``Ctrl + C`` pour arr√™ter l'ex√©cution du code. Tapez ensuite la commande 
suivante pour ouvrir 1.1.1_BlinkingLed.py :

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.py

.. note::
    nano est un outil d'√©dition de texte. Cette commande ouvre le fichier de 
    code 1.1.1_BlinkingLed.py avec cet outil.

Appuyez sur ``Ctrl+X`` pour quitter. Si vous avez modifi√© le code, une invite 
vous demandera si vous souhaitez enregistrer les modifications. Tapez ``Y`` (enregistrer) 
ou ``N`` (ne pas enregistrer).

Ensuite, appuyez sur ``Entr√©e`` pour quitter. Tapez √† nouveau ``nano 1.1.1_BlinkingLed.py`` 
pour voir l'effet apr√®s modification.

**Code**

.. note::

   Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin du code source, comme ``davinci-kit-for-raspberry-pi/python``.

.. raw:: html
   
   <run></run>

.. code-block:: python

   import RPi.GPIO as GPIO
   import time
   LedPin = 17
   def setup():
      # D√©finir les modes GPIO sur la num√©rotation BCM
      GPIO.setmode(GPIO.BCM)
      # D√©finir le mode de LedPin en sortie et initialiser le niveau √† High (3.3V)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
   # D√©finir une fonction principale pour le processus principal
   def main():
      while True:
         print ('...LED ON')
         # Allumer la LED
         GPIO.output(LedPin, GPIO.LOW)
         time.sleep(0.5)
         print ('LED OFF...')
         # √âteindre la LED
         GPIO.output(LedPin, GPIO.HIGH)
         time.sleep(0.5)
   # D√©finir une fonction destroy pour nettoyer tout apr√®s l'ex√©cution du script
   def destroy():
      # √âteindre la LED
      GPIO.output(LedPin, GPIO.HIGH)
      # Lib√©rer les ressources
      GPIO.cleanup()                   
   # Si ce script est ex√©cut√© directement, faire :
   if __name__ == '__main__':
      setup()
      try:
         main()
      # Lorsque 'Ctrl+C' est press√©, la fonction destroy() sera ex√©cut√©e.
      except KeyboardInterrupt:
         destroy()

**Explication du code**

.. code-block:: python

   #!/usr/bin/env python3

Lorsque le syst√®me d√©tecte cette ligne, il cherchera le chemin
d'installation de Python dans les param√®tres env, puis appellera 
l'interpr√©teur correspondant pour ex√©cuter le script. Cela permet 
d'√©viter que l'utilisateur n'installe Python dans le chemin par d√©faut /usr/bin.

.. code-block:: python

   import RPi.GPIO as GPIO

De cette mani√®re, on importe la biblioth√®que RPi.GPIO, puis on d√©finit une 
variable GPIO pour remplacer RPI.GPIO dans le code suivant.

.. code-block:: python

   import time

On importe la biblioth√®que time, qui est utilis√©e pour les fonctions de 
temporisation dans le programme.

.. code-block:: python

   LedPin = 17

La LED est connect√©e au GPIO17 de la carte d'extension en forme de T, soit BCM 17.

.. code-block:: python

   def setup():
      GPIO.setmode(GPIO.BCM)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)

D√©finit le mode de LedPin en sortie et initialise le niveau √† High (3.3V).

Il existe deux mani√®res de num√©roter les broches d'E/S sur un Raspberry Pi 
avec RPi.GPIO : les num√©ros BOARD et les num√©ros BCM. Dans nos le√ßons, nous 
utilisons les num√©ros BCM. Vous devez d√©finir chaque canal que vous utilisez 
en entr√©e ou en sortie.

.. code-block:: python

   GPIO.output(LedPin, GPIO.LOW)

D√©finir GPIO17 (BCM17) sur 0V (niveau bas). Comme la cathode de la LED est 
connect√©e √† GPIO17, la LED s'allume.

.. code-block:: python

   time.sleep(0.5)

Temporisation de 0,5 seconde. Ici, l'instruction est similaire √† la fonction 
delay en langage C, et l'unit√© est la seconde.

.. code-block:: python

   def destroy():
      GPIO.cleanup()

D√©finir une fonction destroy pour nettoyer tout apr√®s l'ex√©cution du script.

.. code-block:: python

   if __name__ == '__main__':
      setup()
      try:
         main()
      # Lorsque 'Ctrl+C' est press√©, la fonction destroy() sera ex√©cut√©e.
      except KeyboardInterrupt:
         destroy()

Ceci est la structure g√©n√©rale d'ex√©cution du code. Lorsque le programme commence 
√† s'ex√©cuter, il initialise la broche via setup(), puis ex√©cute le code dans la 
fonction main() pour r√©gler la broche sur des niveaux haut et bas. Lorsque 'Ctrl+C' 
est press√©, la fonction destroy() est ex√©cut√©e.

Image du ph√©nom√®ne
-----------------------

.. image:: img/image54.jpeg
    :width: 800
    :align: center