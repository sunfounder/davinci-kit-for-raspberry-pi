.. note::

    隆Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Profundiza en el uso de Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **驴Por qu茅 unirte?**

    - **Soporte de expertos**: Resuelve problemas postventa y desaf铆os t茅cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas exclusivas**: Obt茅n acceso anticipado a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m谩s recientes.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

     驴Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y 煤nete hoy.

M贸dulo 2.2.6 MPU6050
======================

Introducci贸n
---------------

El MPU-6050 es el primer y 煤nico dispositivo de seguimiento de 
movimiento de 6 ejes (giroscopio de 3 ejes y aceler贸metro de 3 ejes) 
dise帽ado para smartphones, tablets y sensores port谩tiles que requieren 
bajo consumo, bajo costo y alto rendimiento.

En este experimento, utilizaremos I2C para obtener los valores del sensor 
de aceleraci贸n de tres ejes y del giroscopio de tres ejes del MPU6050, y 
los mostraremos en pantalla.

Componentes
--------------

.. image:: img/list_2.2.6.png


Principio
------------

**MPU6050**

El MPU-6050 es un dispositivo de seguimiento de movimiento de 6 ejes 
(combina giroscopio de 3 ejes y aceler贸metro de 3 ejes).

Sus tres sistemas de coordenadas est谩n definidos de la siguiente manera:

Coloca el MPU6050 plano sobre una mesa, asegurando que la cara con la 
etiqueta est茅 hacia arriba y el punto en la esquina superior izquierda. 
La direcci贸n vertical hacia arriba es el eje Z del chip. La direcci贸n de 
izquierda a derecha se considera el eje X, y de atr谩s hacia adelante es 
el eje Y.

.. image:: img/image223.png


**Aceler贸metro de 3 ejes**

El aceler贸metro funciona mediante el efecto piezoel茅ctrico, la capacidad de 
ciertos materiales para generar una carga el茅ctrica en respuesta a una tensi贸n 
mec谩nica aplicada.

Imagina una caja rectangular con una peque帽a bola dentro, como en la imagen. 
Las paredes de esta caja est谩n hechas de cristales piezoel茅ctricos. Cuando 
inclinas la caja, la bola se mueve en la direcci贸n de la inclinaci贸n debido 
a la gravedad. La pared con la que colisiona la bola genera peque帽as corrientes 
piezoel茅ctricas. Cada par de paredes opuestas representa un eje en el espacio 
3D: ejes X, Y y Z. Seg煤n la corriente generada, se determina la direcci贸n y 
magnitud de la inclinaci贸n.

.. image:: img/image224.png

Podemos utilizar el MPU6050 para detectar la aceleraci贸n en cada eje (en estado 
estacionario, la aceleraci贸n en el eje Z es 1 unidad de gravedad, y en los ejes 
X e Y es 0). Si se inclina o est谩 en condiciones de peso cero o sobrepeso, la 
lectura correspondiente cambiar谩.

Hay cuatro rangos de medici贸n seleccionables program谩ticamente: +/-2g, +/-4g, 
+/-8g y +/-16g (por defecto es 2g), con valores de -32768 a 32767.

La lectura del aceler贸metro se convierte en valor de aceleraci贸n mapeando el 
rango de lecturas al rango de medici贸n.

Aceleraci贸n = (Lectura cruda del eje del aceler贸metro / 65536 * Rango de aceleraci贸n total) g

Ejemplo en el eje X: cuando la lectura del aceler贸metro en el eje X es 16384 y el rango es +/-2g:

**Aceleraci贸n en el eje X = (16384 / 65536 * 4) g**  **= 1g**

**Giroscopio de 3 ejes**

Los giroscopios operan bajo el principio de la aceleraci贸n de Coriolis. 
Imagina una estructura similar a un tenedor en constante movimiento de 
vaiv茅n, sostenida por cristales piezoel茅ctricos. Cuando intentas inclinar 
esta disposici贸n, los cristales experimentan una fuerza en la direcci贸n de 
la inclinaci贸n, generando una corriente seg煤n el efecto piezoel茅ctrico, y 
esta corriente se amplifica.

.. image:: img/image225.png
    :width: 800
    :align: center

El giroscopio tambi茅n tiene cuatro rangos de medici贸n: +/- 250, +/- 500, +/- 
1000, +/- 2000. El m茅todo de c谩lculo es similar al del aceler贸metro.

La f贸rmula para convertir la lectura en velocidad angular es:

Velocidad angular = (Lectura cruda del eje del giroscopio / 65536 * Rango total 
del giroscopio) 掳/s

Ejemplo en el eje X: cuando la lectura cruda en el eje X es 16384 y el rango 
es +/- 250掳/s:

**Velocidad angular en el eje X = (16384 / 65536 * 500)掳/s** **= 125掳/s**

Diagrama de Circuito
------------------------

El MPU6050 se comunica con el microcontrolador mediante la interfaz de bus I2C. 
Los pines SDA1 y SCL1 deben conectarse al pin correspondiente.

.. image:: img/image330.png
    :width: 600
    :align: center


Procedimiento Experimental
-------------------------------

**Paso 1:** Construye el circuito.

.. image:: img/image227.png
    :width: 800



**Paso 2**: Configura I2C (ver Ap茅ndice. Si ya configuraste I2C, omite este paso).


Para Usuarios de C
^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 3:** Ve a la carpeta del c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/c/2.2.6/

**Paso 4:** Compila el c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.6_mpu6050.c -lwiringPi -lm

**Paso 5:** Ejecuta el archivo.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Al ejecutar el c贸digo, el 谩ngulo de desviaci贸n en los ejes X e Y, junto 
con la aceleraci贸n y velocidad angular en cada eje medida por el MPU6050, 
se mostrar谩 en pantalla despu茅s de ser calculada.

.. note::

    Si no funciona despu茅s de ejecutar el c贸digo, o si aparece un mensaje de error como: \"wiringPi.h: No such file or directory\", consulta la secci贸n :ref:`c code is not working?`.
**Explicaci贸n del C贸digo**

.. code-block:: c

    #include  <wiringPiI2C.h>
    #include <wiringPi.h>
    #include  <stdio.h>
    #include  <math.h>
    int fd;
    int acclX, acclY, acclZ;
    int gyroX, gyroY, gyroZ;
    double acclX_scaled, acclY_scaled, acclZ_scaled;
    double gyroX_scaled, gyroY_scaled, gyroZ_scaled;

    int read_word_2c(int addr)
    {
    int val;
    val = wiringPiI2CReadReg8(fd, addr);
    val = val << 8;
    val += wiringPiI2CReadReg8(fd, addr+1);
    if (val >= 0x8000)
        val = -(65536 - val);
    return val;
    }

    double dist(double a, double b)
    {
    return sqrt((a*a) + (b*b));
    }

    double get_y_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(x, dist(y, z));
    return -(radians * (180.0 / M_PI));
    }

    double get_x_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(y, dist(x, z));
    return (radians * (180.0 / M_PI));
    }

    int main()
    {
    fd = wiringPiI2CSetup (0x68);
    wiringPiI2CWriteReg8 (fd,0x6B,0x00); // desactivar el modo de suspensi贸n
    printf("set 0x6B=%X\n",wiringPiI2CReadReg8 (fd,0x6B));
    
    while(1) {

        gyroX = read_word_2c(0x43);
        gyroY = read_word_2c(0x45);
        gyroZ = read_word_2c(0x47);

        gyroX_scaled = gyroX / 131.0;
        gyroY_scaled = gyroY / 131.0;
        gyroZ_scaled = gyroZ / 131.0;

        // Imprimir los valores de los ejes X, Y y Z del sensor de giroscopio.
        printf("My gyroX_scaled: %f\n", gyroY X_scaled);
        delay(100);
        printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
        delay(100);
        printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);
        delay(100);

        acclX = read_word_2c(0x3B);
        acclY = read_word_2c(0x3D);
        acclZ = read_word_2c(0x3F);

        acclX_scaled = acclX / 16384.0;
        acclY_scaled = acclY / 16384.0;
        acclZ_scaled = acclZ / 16384.0;
        
        // Imprimir los valores X, Y y Z del sensor de aceleraci贸n.
        printf("My acclX_scaled: %f\n", acclX_scaled);
        delay(100);
        printf("My acclY_scaled: %f\n", acclY_scaled);
        delay(100);
        printf("My acclZ_scaled: %f\n", acclZ_scaled);
        delay(100);

        printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
        delay(100);
        printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
        delay(100);
        
        delay(100);
    }
    return 0;
    }

**Explicaci贸n del C贸digo**

.. code-block:: c

    int read_word_2c(int addr)
    {
    int val;
    val = wiringPiI2CReadReg8(fd, addr);
    val = val << 8;
    val += wiringPiI2CReadReg8(fd, addr+1);
    if (val >= 0x8000)
        val = -(65536 - val);
    return val;
    }

Lee los datos del sensor enviados desde el MPU6050.

.. code-block:: c

    double get_y_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(x, dist(y, z));
    return -(radians * (180.0 / M_PI));
    }

Obtiene el 谩ngulo de deflexi贸n en el eje Y.

.. code-block:: c

    double get_x_rotation(double x, double y, double z)
    {
    double radians;
    radians = atan2(y, dist(x, z));
    return (radians * (180.0 / M_PI));
    }

Calcula el 谩ngulo de deflexi贸n en el eje X.

.. code-block:: c

    gyroX = read_word_2c(0x43);
    gyroY = read_word_2c(0x45);
    gyroZ = read_word_2c(0x47);

    gyroX_scaled = gyroX / 131.0;
    gyroY_scaled = gyroY / 131.0;
    gyroZ_scaled = gyroZ / 131.0;

    // Imprime los valores de los ejes X, Y y Z del sensor de giroscopio.
    printf("My gyroX_scaled: %f\n", gyroY X_scaled);
    printf("My gyroY_scaled: %f\n", gyroY Y_scaled);
    printf("My gyroZ_scaled: %f\n", gyroY Z_scaled);

Lee los valores de los ejes x, y y z en el sensor de giroscopio, convierte los datos en valores de velocidad angular y luego los imprime.

.. code-block:: c

    acclX = read_word_2c(0x3B);
    acclY = read_word_2c(0x3D);
    acclZ = read_word_2c(0x3F);

    acclX_scaled = acclX / 16384.0;
    acclY_scaled = acclY / 16384.0;
    acclZ_scaled = acclZ / 16384.0;
        
    // Imprime los valores de los ejes X, Y y Z del sensor de aceleraci贸n.
    printf("My acclX_scaled: %f\n", acclX_scaled);
    printf("My acclY_scaled: %f\n", acclY_scaled);
    printf("My acclZ_scaled: %f\n", acclZ_scaled);

Lee los valores de los ejes x, y y z en el sensor de aceleraci贸n, 
convierte los datos en valores de velocidad de aceleraci贸n (unidad 
de gravedad), y luego los imprime.

.. code-block:: c

    printf("My X rotation: %f\n", get_x_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));
    printf("My Y rotation: %f\n", get_y_rotation(acclX_scaled, acclY_scaled, acclZ_scaled));

Imprime los 谩ngulos de deflexi贸n de los ejes x e y.

Para Usuarios de Python
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Paso 3:** Ve a la carpeta del c贸digo.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/davinci-kit-for-raspberry-pi/python

**Paso 4:** Ejecuta el archivo ejecutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.6_mpu6050.py

Con el c贸digo en ejecuci贸n, el 谩ngulo de deflexi贸n de los ejes x e y, 
as铆 como la aceleraci贸n y la velocidad angular en cada eje obtenidos 
por el MPU6050, se mostrar谩n en la pantalla despu茅s de calcularse.

**C贸digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c贸digo a 
    continuaci贸n. Pero antes de hacerlo, debes dirigirte a la ruta del 
    c贸digo fuente, como ``davinci-kit-for-raspberry-pi/python``.
    
.. raw:: html

    <run></run>

.. code-block:: python

    import smbus
    import math
    import time

    # Registros de administraci贸n de energ铆a
    power_mgmt_1 = 0x6b
    power_mgmt_2 = 0x6c

    def read_byte(adr):
        return bus.read_byte_data(address, adr)

    def read_word(adr):
        high = bus.read_byte_data(address, adr)
        low = bus.read_byte_data(address, adr+1)
        val = (high << 8) + low
        return val

    def read_word_2c(adr):
        val = read_word(adr)
        if (val >= 0x8000):
            return -((65535 - val) + 1)
        else:
            return val

    def dist(a,b):
        return math.sqrt((a*a)+(b*b))

    def get_y_rotation(x,y,z):
        radians = math.atan2(x, dist(y,z))
        return -math.degrees(radians)

    def get_x_rotation(x,y,z):
        radians = math.atan2(y, dist(x,z))
        return math.degrees(radians)


    bus = smbus.SMBus(1) # o bus = smbus.SMBus(1) para placas de la Revisi贸n 2
    address = 0x68       # Este es el valor de la direcci贸n le铆do mediante el comando i2cdetect

    # Ahora activa el 6050 ya que comienza en modo de suspensi贸n
    bus.write_byte_data(address, power_mgmt_1, 0)

    while True:
        time.sleep(0.1)
        gyro_xout = read_word_2c(0x43)
        gyro_yout = read_word_2c(0x45)
        gyro_zout = read_word_2c(0x47)

        print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
        print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
        print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

        accel_xout = read_word_2c(0x3b)
        accel_yout = read_word_2c(0x3d)
        accel_zout = read_word_2c(0x3f)

        accel_xout_scaled = accel_xout / 16384.0
        accel_yout_scaled = accel_yout / 16384.0
        accel_zout_scaled = accel_zout / 16384.0

        print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
        print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
        print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

        print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
        print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

        time.sleep(0.5)

**Explicaci贸n del C贸digo**

.. code-block:: python

    def read_word(adr):
        high = bus.read_byte_data(address, adr)
        low = bus.read_byte_data(address, adr+1)
        val = (high << 8) + low
        return val

    def read_word_2c(adr):
        val = read_word(adr)
        if (val >= 0x8000):
            return -((65535 - val) + 1)
        else:
            return val

Lee los datos del sensor enviados desde el MPU6050.

.. code-block:: python

    def get_y_rotation(x,y,z):
        radians = math.atan2(x, dist(y,z))
        return -math.degrees(radians)

Calcula el 谩ngulo de deflexi贸n en el eje y.

.. code-block:: python

    def get_x_rotation(x,y,z):
        radians = math.atan2(y, dist(x,z))
        return math.degrees(radians)

Calcula el 谩ngulo de deflexi贸n en el eje x.

.. code-block:: python

    gyro_xout = read_word_2c(0x43)
    gyro_yout = read_word_2c(0x45)
    gyro_zout = read_word_2c(0x47)

    print ("gyro_xout : ", gyro_xout, " scaled: ", (gyro_xout / 131))
    print ("gyro_yout : ", gyro_yout, " scaled: ", (gyro_yout / 131))
    print ("gyro_zout : ", gyro_zout, " scaled: ", (gyro_zout / 131))

Lee los valores de los ejes x, y y z en el sensor de giroscopio, convierte 
los datos en valores de velocidad angular y luego los imprime.

.. code-block:: python

    accel_xout = read_word_2c(0x3b)
    accel_yout = read_word_2c(0x3d)
    accel_zout = read_word_2c(0x3f)

    accel_xout_scaled = accel_xout / 16384.0
    accel_yout_scaled = accel_yout / 16384.0
    accel_zout_scaled = accel_zout / 16384.0

    print ("accel_xout: ", accel_xout, " scaled: ", accel_xout_scaled)
    print ("accel_yout: ", accel_yout, " scaled: ", accel_yout_scaled)
    print ("accel_zout: ", accel_zout, " scaled: ", accel_zout_scaled)

Lee los valores de los ejes x, y y z en el sensor de aceleraci贸n, 
convierte los datos en valores de velocidad de aceleraci贸n (unidad 
de gravedad) y luego los imprime.

.. code-block:: python

    print ("x rotation: " , get_x_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))
    print ("y rotation: " , get_y_rotation(accel_xout_scaled, accel_yout_scaled, accel_zout_scaled))

Imprime los 谩ngulos de deflexi贸n de los ejes x e y.

Imagen del Fen贸meno
----------------------

.. image:: img/image228.jpeg